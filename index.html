<!DOCTYPE html>
<html>
<head>
<!-- 2016-05-12 jeu. 15:50 -->
<meta  charset="utf-8">
<meta  name="viewport" content="width=device-width, initial-scale=1">
<title>M√©canismes de langages pour √©tendre des interpr√©teurs</title>
<meta  name="generator" content="Org-mode">
<meta  name="author" content="fmdkdd">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="style.css">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<header>
<h1 class="title">M√©canismes de langages pour √©tendre des interpr√©teurs</h1>
</header><nav id="table-of-contents">
<h2>Table des mati√®res</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline5">1. <span class="todo BARE">BARE</span> Introduction</a>
<ul>
<li><a href="#orgheadline1">1.1. Probl√®me: √©tendre un interpr√®teur par de multiple analyses</a></li>
<li><a href="#orgheadline2">1.2. But: m√©canismes pour √©tendre simplement un interpr√©teur en pr√©servant la s√©paration des pr√©occupations</a></li>
<li><a href="#orgheadline3">1.3. Port√©e: interpr√©teurs en JavaScript</a></li>
<li><a href="#orgheadline4">1.4. Survol</a></li>
</ul>
</li>
<li><a href="#orgheadline59">2. √âtat de l&rsquo;art</a>
<ul>
<li><a href="#orgheadline6">2.1. <span class="todo UNSTABLE">UNSTABLE</span> De l&rsquo;ex√©cution du programme au code source</a></li>
<li><a href="#orgheadline7">2.2. <span class="todo UNSTABLE">UNSTABLE</span> Apprivoiser le flot de contr√¥le: la programmation structur√©e</a></li>
<li><a href="#orgheadline13">2.3. Mod√©liser le monde: la programmation objet</a>
<ul>
<li><a href="#orgheadline9">2.3.1. <span class="todo BARE">BARE</span> Smalltak</a></li>
<li><a href="#orgheadline10">2.3.2. <span class="todo BARE">BARE</span> Prototype-based programming</a></li>
<li><a href="#orgheadline12">2.3.3. <span class="todo TRANSLATE">TRANSLATE</span> Self</a></li>
</ul>
</li>
<li><a href="#orgheadline23">2.4. R√©ifier le langage pour s√©parer les pr√©occupations</a>
<ul>
<li><a href="#orgheadline14">2.4.1. <span class="todo TRANSLATE">TRANSLATE</span> Reflection</a></li>
<li><a href="#orgheadline15">2.4.2. <span class="done STABLE">STABLE</span> L&rsquo;impl√©mentation ouverte</a></li>
<li><a href="#orgheadline22">2.4.3. <span class="done STABLE">STABLE</span> La programmation par aspects</a></li>
</ul>
</li>
<li><a href="#orgheadline28">2.5. Tisser les facettes d&rsquo;un artefact d&rsquo;innombrable dimensions</a>
<ul>
<li><a href="#orgheadline25">2.5.1. <span class="todo TRANSLATE">TRANSLATE</span> Literate programming</a></li>
<li><a href="#orgheadline26">2.5.2. <span class="done STABLE">STABLE</span> Hyper/J</a></li>
<li><a href="#orgheadline27">2.5.3. <span class="todo BARE">BARE</span> Information transparency</a></li>
</ul>
</li>
<li><a href="#orgheadline29">2.6. <span class="todo BARE">BARE</span> Limiter les effets de bord: La programmation fonctionnelle</a></li>
<li><a href="#orgheadline35">2.7. La modularit√© du programme n&rsquo;est pas la modularit√© du code source</a>
<ul>
<li><a href="#orgheadline31">2.7.1. <span class="done STABLE">STABLE</span> La modularit√© selon Parnas</a></li>
<li><a href="#orgheadline33">2.7.2. <span class="done STABLE">STABLE</span> La th√©orie de Naur derri√®re le programme</a></li>
<li><a href="#orgheadline34">2.7.3. Notion of modularity</a></li>
</ul>
</li>
<li><a href="#orgheadline47">2.8. Les m√©canismes de recomposition du programme</a>
<ul>
<li><a href="#orgheadline36">2.8.1. <span class="todo BARE">BARE</span> Le probl√®me de l&rsquo;expression</a></li>
<li><a href="#orgheadline37">2.8.2. <span class="todo BARE">BARE</span> Dynamic binding</a></li>
<li><a href="#orgheadline38">2.8.3. <span class="todo BARE">BARE</span> Building from modules</a></li>
<li><a href="#orgheadline39">2.8.4. <span class="todo BARE">BARE</span> Building with monads</a></li>
<li><a href="#orgheadline40">2.8.5. <span class="todo BARE">BARE</span> Bytecode instrumentation</a></li>
<li><a href="#orgheadline46">2.8.6. Superimposition</a></li>
</ul>
</li>
<li><a href="#orgheadline58">2.9. <span class="todo UNSTABLE">UNSTABLE</span> Travaux connexes concernant l&rsquo;instrumentation</a>
<ul>
<li><a href="#orgheadline48">2.9.1. <span class="todo BARE">BARE</span> Domain-specific languages</a></li>
<li><a href="#orgheadline49">2.9.2. <span class="todo BARE">BARE</span> Scripting languages</a></li>
<li><a href="#orgheadline51">2.9.3. <span class="todo TRANSLATE">TRANSLATE</span> Emacs</a></li>
<li><a href="#orgheadline53">2.9.4. <span class="todo TRANSLATE">TRANSLATE</span> Eclipse and other IDEs</a></li>
<li><a href="#orgheadline55">2.9.5. <span class="todo BARE">BARE</span> Web browsers</a></li>
<li><a href="#orgheadline57">2.9.6. <span class="todo TRANSLATE">TRANSLATE</span> Lua</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline60">3. <span class="todo UNSTABLE">UNSTABLE</span> √âtude de cas: extension ad-hoc de Narcissus</a></li>
<li><a href="#orgheadline61">4. <span class="todo UNSTABLE">UNSTABLE</span> Variations sur un interpr√©teur de lambda-calcul extensible</a></li>
<li><a href="#orgheadline100">5. <span class="todo TRANSLATE">TRANSLATE</span> Construire un interpr√©teur extensible</a>
<ul>
<li>
<ul>
<li><a href="#orgheadline62">5.0.1. Finding a core example</a></li>
<li><a href="#orgheadline63">5.0.2. The expression problem</a></li>
<li><a href="#orgheadline64">5.0.3. The expression problem, with a twist</a></li>
<li><a href="#orgheadline65">5.0.4. The modular instrumentation problem</a></li>
</ul>
</li>
<li><a href="#orgheadline79">5.1. Variations</a>
<ul>
<li><a href="#orgheadline78">5.1.1. JavaScript</a></li>
</ul>
</li>
<li><a href="#orgheadline76">5.2. Lisp</a></li>
<li><a href="#orgheadline80">5.3. Haskell</a>
<ul>
<li><a href="#orgheadline94">5.3.1. Building scaffolding with language features</a></li>
<li><a href="#orgheadline95">5.3.2. Extending the syntax</a></li>
</ul>
</li>
<li><a href="#orgheadline99">5.4. Modular monadic interpreters</a>
<ul>
<li><a href="#orgheadline97">5.4.1. The giants</a></li>
<li><a href="#orgheadline98">5.4.2. The bigger picture</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline105">6. <span class="todo TRANSLATE">TRANSLATE</span> Construire un interpr√©teur par modules</a>
<ul>
<li><a href="#orgheadline101">6.1. Ajouter des termes</a></li>
<li><a href="#orgheadline102">6.2. Ajouter des op√©rations</a></li>
<li><a href="#orgheadline103">6.3. Modifier des op√©rations</a></li>
<li><a href="#orgheadline104">6.4. Passer de l&rsquo;√©tat aux op√©rations</a></li>
</ul>
</li>
<li><a href="#orgheadline116">7. Dynamic scoping to build interpreters</a>
<ul>
<li><a href="#orgheadline106">7.1. The base datatype</a></li>
<li><a href="#orgheadline107">7.2. Adding a data variant</a></li>
<li><a href="#orgheadline108">7.3. Adding an operation</a></li>
<li><a href="#orgheadline111">7.4. Adding an operation as a module</a>
<ul>
<li><a href="#orgheadline109">7.4.1. A use-case for <code>with</code></a></li>
<li><a href="#orgheadline110">7.4.2. Selective imports with an IIFE</a></li>
</ul>
</li>
<li><a href="#orgheadline113">7.5. Modifying an operation</a>
<ul>
<li><a href="#orgheadline112">7.5.1. Non-destructive modification</a></li>
</ul>
</li>
<li><a href="#orgheadline114">7.6. Passing state</a></li>
<li><a href="#orgheadline115">7.7. All in one</a></li>
</ul>
</li>
<li><a href="#orgheadline134">8. <span class="done STABLE">STABLE</span> √âtendre un interpr√©teur par manipulation de port√©e</a>
<ul>
<li><a href="#orgheadline120">8.1. Manipuler la port√©e des variables pour l&rsquo;instrumentation</a>
<ul>
<li><a href="#orgheadline117">8.1.1. La port√©e dans le motif module</a></li>
<li><a href="#orgheadline118">8.1.2. Ouvrir le motif module</a></li>
<li><a href="#orgheadline119">8.1.3. Disposer les environnements en couches</a></li>
</ul>
</li>
<li><a href="#orgheadline121">8.2. Ouvrir le motif module en JavaScript</a></li>
<li><a href="#orgheadline127">8.3. √âtendre Narcissus par manipulation de port√©e</a>
<ul>
<li><a href="#orgheadline122">8.3.1. Ajouter l&rsquo;analyse d&rsquo;√©valuation multi-facettes</a></li>
<li><a href="#orgheadline123">8.3.2. Ajouter l&rsquo;analyse de trace</a></li>
<li><a href="#orgheadline124">8.3.3. Ajouter l&rsquo;analyse FlowR</a></li>
<li><a href="#orgheadline125">8.3.4. Ajouter l&rsquo;analyse d&rsquo;environnements</a></li>
<li><a href="#orgheadline126">8.3.5. √âvaluation</a></li>
</ul>
</li>
<li><a href="#orgheadline133">8.4. Discussion</a>
<ul>
<li><a href="#orgheadline128">8.4.1. La tension entre flexibilit√© et s√ªret√©</a></li>
<li><a href="#orgheadline129">8.4.2. D&rsquo;autres fa√ßons d&rsquo;√©tendre l&rsquo;interpr√©teur</a></li>
<li><a href="#orgheadline130">8.4.3. Pourquoi ne pas utiliser la programmation par aspects?</a></li>
<li><a href="#orgheadline131">8.4.4. Appliquer la manipulation de port√©e √† d&rsquo;autres langages</a></li>
<li><a href="#orgheadline132">8.4.5. Inconv√©nients de la manipulation de port√©e avec <code>with</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgheadline137">9. <span class="todo BARE">BARE</span> Synth√®se</a>
<ul>
<li><a href="#orgheadline135">9.1. <span class="todo BARE">BARE</span> S√©paration des pr√©occupations: pourquoi?</a></li>
<li><a href="#orgheadline136">9.2. Locality of concerns and locality of execution are irreconciable in the source text</a></li>
</ul>
</li>
<li><a href="#orgheadline138">R√©f√©rences</a></li>
</ul>
</div>
</nav>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5"><span class="section-number-2">1</span> <span class="todo BARE">BARE</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-orgheadline1" class="outline-3">
<h3 id="orgheadline1"><span class="section-number-3">1.1</span> Probl√®me: √©tendre un interpr√®teur par de multiple analyses</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Contexte de s√©curit√© web.</li>
<li>Scripts de pages web passent par un interpr√©teur.</li>
<li>S√©curiser un script = analyser ses fonctionnalit√©s
<ul class="org-ul">
<li>runtime monitoring</li>
<li>access control</li>
<li>logging</li>
</ul></li>
<li>Une analyse dynamique = une modification de l&rsquo;interpr√©teur</li>
<li>Modification du code source en conflit avec la s√©paration des pr√©occupations
<ul class="org-ul">
<li>perte d&rsquo;extensibilit√©, perte de lisibilit√©, difficult√© de maintenance&#x2026;</li>
</ul></li>
<li>Ajouter une analyse devrait √™tre simple
<ul class="org-ul">
<li>sans requ√©rir des modifications invasives de l&rsquo;interpr√©teur</li>
<li>maximiser la flexibilit√©, minimiser le co√ªt d&rsquo;adoption</li>
</ul></li>
<li>Ajouter une analyse ne doit pas impacter la lisibilit√© du code de l&rsquo;interpr√©teur
<ul class="org-ul">
<li>s√©paration des pr√©occupations</li>
</ul></li>
<li>Analyses peuvent se composer sans effort particulier (lorsqu&rsquo;elles
n&rsquo;interf√®rent pas entre elles)</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2"><span class="section-number-3">1.2</span> But: m√©canismes pour √©tendre simplement un interpr√©teur en pr√©servant la s√©paration des pr√©occupations</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Trouver des m√©canismes, des constructions (patterns) pour √©tendre des interpr√©teurs</li>
<li>Am√©liorer la situation</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3"><span class="section-number-3">1.3</span> Port√©e: interpr√©teurs en JavaScript</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>M√©canismes et patterns g√©n√©riques, pas n√©cessairement li√©s √† un langage
particulier.</li>
<li>Software engineering</li>
<li>Point de vue du programmeur
<ul class="org-ul">
<li>Travail sur le code source, l&rsquo;√©diteur de programmes, les outils du programmeur</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4"><span class="section-number-3">1.4</span> Survol</h3>
</div>
</div>

<div id="outline-container-orgheadline59" class="outline-2">
<h2 id="orgheadline59"><span class="section-number-2">2</span> √âtat de l&rsquo;art</h2>
<div class="outline-text-2" id="text-2">
<p>
Une chronologie de la modularit√© dans les langages de programmation.
</p>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6"><span class="section-number-3">2.1</span> <span class="todo UNSTABLE">UNSTABLE</span> De l&rsquo;ex√©cution du programme au code source</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Pour modifier l&rsquo;ex√©cution d&rsquo;un programme, il est bon de savoir <i>comment</i> le
programme est ex√©cut√© par la machine.  Du point de vue de la machine, un
programme est une simple liste d&rsquo;instructions.  Une s√©quence d&rsquo;additions, de
soustractions, de chargement et stockage de valeurs en m√©moire, et de sauts
conditionnels.  Ces instructions sont pr√©sent√©es √† la machine sous la seule
forme que son processeur est capable de manipuler: des nombres, cod√©s par des
suites de z√©ros et de uns.
</p>

<pre class="example">
...00101011011100101011010101110101011111010100010110100000000110001011101010010101011...
</pre>

<p>
Le programme est alors ex√©cut√© instruction par instruction.  La machine lit une
instruction, puis effectue l&rsquo;op√©ration correspondante ; elle charge
l&rsquo;instruction suivante, la lit, effectue l&rsquo;op√©ration, charge, lit, effectue,
etc.  Cette monomanie contribue √† l&rsquo;utilit√© que nous trouvons √† la machine, car
son processeur agit certes simplement, mais il agit <i>vite</i>.  N&rsquo;importe quel
processeur actuel est capable d&rsquo;effectuer plusieurs milliards d&rsquo;op√©rations par
seconde.  La machine ne diff√©rencie donc pas un programme d&rsquo;un autre; tous se
m√™lent en une immense suite binaire.
</p>

<p>
Le programmeur en revanche cherche √† structurer cette suite de nombres.  Une
suite infinie de z√©ros et de uns est difficile √† appr√©hender pour un cerveau
humain; il lui faut des rep√®res, d√©couper le programme en unit√©s plus
digestibles par nos facult√©s organiques.  Un programmeur manipule donc rarement
des bits afin de d√©clarer ses intentions √† la machine; il utilise plut√¥t un
langage de programmation.
</p>

<div class="org-src-container">
<label class="org-src-name">Un programme (point de vue d&rsquo;un programmeur connaissant le langage JavaScript, vers 2015).</label>
<pre class="src src-js" id="orgsrcblock1"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">fibonacci</span>(<span style="font-weight: bold; font-style: italic;">n</span>) {
  <span style="font-weight: bold;">return</span> n &lt; 2 ? 1 : fibonacci(n-1) + fibonacci(n-2)
}

print(fibonacci(10))
</pre>
</div>

<p>
Dans les langages de programmation exot√©riques, un programme est constitu√©
principalement de lettres plut√¥t que de nombres.  Les lettres, arrang√©es en
permutations judicieuses, nous servent √† <i>nommer</i> les objets de la computation
tels que les variables et constantes, les fonctions, les classes et autres
structures.  Les mots sont plus facilement pronon√ßables, davantage mn√©moniques,
et peuvent surtout communiquer l&rsquo;intention du programmeur par homonymie.  On
peut ainsi, simplement en suivant les mots, supposer que le code <a href="#orgsrcblock1">1</a> calcule et
affiche le onzi√®me nombre de la suite de Fibonacci, sans √™tre vraiment certain
de la s√©mantique de JavaScript.  Les mots <i>√©voquent</i> imm√©diatement du sens alors
que les nombres doivent √™tre d√©cod√©s.
</p>

<aside style="margin-top:-15rem">
<p>
Par opposition aux langages <i>√©sot√©riques</i> qui sont con√ßus davantage pour
d√©montrer la cr√©ativit√© de leur auteur que pour simplifier la conception de
programmes.  [<a href="#Esolang">Eso</a>] recense des sp√©cimens tels que Brainfuck, Piet ou
Whitespace, qui ne manquent pas de nous rappeler qu&rsquo;√™tre Turing-complet n&rsquo;est
pas un crit√®re suffisant pour √™tre un langage <i>utile</i>.
</p>
</aside>

<aside style="margin-top:-5rem">
<p>
Les mots peuvent √©galement √©voquer un contresens; une d√©finition maladroite‚Äìou
intentionnelle‚Äìpeut induire en erreur le lecteur.  Un ami m&rsquo;a racont√© avoir
pass√© tout un apr√®s-midi √† pister une erreur dans du code √©crit en C, pour
finalement d√©couvrir dans un fichier inclus la ligne: <code>#define true false</code>.
</p>
</aside>

<p>
Mais, si le programme ainsi d√©crit est plus confortable pour le programmeur, il
est incompr√©hensible par la machine en tant que tel.  Il faut au pr√©alable
<i>traduire</i> ce programme en code machine avant de pouvoir l&rsquo;ex√©cuter.  L&rsquo;analogie
avec les langues naturelles est pertinente; si je souhaite communiquer le
contenu de ce manuscrit de th√®se √† des non-francophones, soit je r√©dige une
nouvelle version dans une langue qu&rsquo;ils parlent (√©crire le programme en langage
machine), soit j&rsquo;emploie les services d&rsquo;un traducteur.  Heureusement, la
traduction d&rsquo;un programme est une t√¢che moins hasardeuse que la traduction d&rsquo;un
document en langue naturelle.  Les langages de programmation sont d√©finis de
fa√ßon √† √©liminer toute ambigu√Øt√© d&rsquo;interpr√©tation, ce qui permet d&rsquo;effectuer la
traduction en langage machine automatiquement.
</p>

<aside style="margin-top:-7rem">
<p>
Une troisi√®me option serait que les non-francophones apprennent le fran√ßais pour
lire ce manuscrit.  En suivant l&rsquo;analogie, cela correspond √† une machine qui
ex√©cuterait directement un programme JavaScript.  Les deux situations sont
√©galement improbables.
</p>
</aside>

<p>
C&rsquo;est le <i>compilateur</i> qui traduit des programmes d&rsquo;un langage de programmation
vers le langage machine.  Le compilateur lit le texte brut d√©crivant le
programme, v√©rifie que ce texte est conforme aux r√®gles syntaxiques et
grammaticales du langage qu&rsquo;il traduit, puis applique les r√®gles de traduction
en langage machine.  Un compilateur permet donc au programmeur d&rsquo;obtenir un
programme ex√©cutable par la machine √† partir de code √©crit dans le langage de
son choix.
</p>


<figure>
<p><img src="img/compile-pipeline.png" alt="compile-pipeline.png">
</p>
</figure>

<p>
Notons que la compilation n&rsquo;attache aucun sens particulier aux noms choisis par
le programmeur.  Les noms servent juste √† vite remplac√©s par des r√©f√©rences.  On
pourrait √©crire le programme de <a href="#orgsrcblock1">1</a>, de mani√®re totalement √©quivalente:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">xx</span>(<span style="font-weight: bold; font-style: italic;">x</span>){<span style="font-weight: bold;">return</span> x&lt;2?1:xx(x-1)+xx(x-2)}print(xx(10))
</pre>
</div>

<aside style="margin-top:-5rem">
<p>
√Ä ce titre, les archives du concours international d&rsquo;obfuscation de code C [<a href="#IOCCC">IOC</a>]
rec√®lent d&rsquo;exemples √† suivre pour mystifier tout collaborateur.
</p>
</aside>

<p>
Le programme, n&rsquo;a donc pas comme seule vocation √† ordonner la machine, il doit
aussi √™tre lisible par d&rsquo;autres programmeurs
vocations parall√®les:
</p>

<p>
Pour organiser un manuscrit, on recourt aux phrases, aux paragraphes
Lorsqu&rsquo;un texte devient trop long, il devient plus pratique de le d√©couper
en unit√©s ind√©pendantes.
</p>


<figure>
<p><img src="img/bg-map.png" alt="bg-map.png">
</p>
</figure>


<figure>
<p><img src="img/bg-map2.png" alt="bg-map2.png">
</p>
</figure>


<figure>
<p><img src="img/bg-map3.png" alt="bg-map3.png">
</p>
</figure>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7"><span class="section-number-3">2.2</span> <span class="todo UNSTABLE">UNSTABLE</span> Apprivoiser le flot de contr√¥le: la programmation structur√©e</h3>
<div class="outline-text-3" id="text-2-2">
<div class="epigraph">
<p>
At the IFIP Congress in 1971 I had the pleasure of meeting Dr. Eiichi Goto of
Japan, who cheerfully complained that he was always being eliminated. ‚Äî¬†[<a href="#Knu-74">Knu74</a>].
</p>

</div>


<figure>
<p><img src="img/goto.jpg" alt="goto.jpg" title="„Åô„Åø„Åæ„Åõ„Çì„ÄÅÈ´òÊ©ãÁßÄ‰øä„Åï„Çì„ÄÇ">
</p>
<figcaption><span class="figure-number">Figure&nbsp;5&nbsp;:</span> Eiichi Goto (gauche) et Furomu Komo devant le PC-1, vers 1958.</figcaption>
</figure>

<p>
La programmation structur√©e n&rsquo;est pas un ensemble de techniques, ni une m√©thode
de programmation, mais plut√¥t un but √† atteindre.  Dans sa c√©l√®bre lettre √†
l&rsquo;√©diteur des communications de l&rsquo;ACM, &laquo;&nbsp;Go To Statement Considered Harmful&nbsp;&raquo;
[<a href="#Dij-68">Dij68</a>], Dijkstra d√©crit ce but:
</p>

<blockquote>
<p>
Our intellectual powers are rather geared to master static relations and
our powers to visualize processes evolving in time are relatively poorly
developed.  For that reason we should do (as wise programmers aware of our
limitations) our utmost to shorten the conceptual gap between the static program
and the dynamic process, to make the correspondence between the program (spread
out in text space) and the process (spread out in time) as trivial as possible.
</p>
</blockquote>

<div style="margin-top:-18rem" class="side-figure">

<figure>
<p><img src="img/dijkstra-process-program.svg" alt="dijkstra-process-program.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;6&nbsp;:</span> L&rsquo;objet du programmeur est le processus effectu√© par la machine, et manipul√© indirectement via un programme.  Dijkstra tente de construire des programmes qui refl√®tent le comportement du processus.</figcaption>
</figure>

</div>

<p>
Dijkstra commence par √©tablir une distinction cruciale entre le <i>programme</i> tap√©
par le programmeur sous forme de texte, et le <i>processus</i> engendr√© par ce
programme, et ex√©cut√© par la machine.  Le programmeur n&rsquo;a pas de contr√¥le direct
sur le processus, il ne peut que modifier le programme.  Afin de mieux
comprendre le processus engendr√© par le programme, lorsque l&rsquo;on √©crit et relit
le code, il faut que le programme refl√®te au mieux ce processus.  Dijkstra
cherche donc √† √©tablir une correspondance claire entre les instructions
ex√©cut√©es par la machine (la dimension temporelle) et les instructions dict√©es
par le programme (la dimension spatiale).  Et pour lui, <code>goto</code> est une
construction qui va √† l&rsquo;encontre de cette correspondance.
</p>

<div style="margin-top:-8rem" class="side-figure">

<figure>
<p><img src="img/dijkstra-dimensions.svg" alt="dijkstra-dimensions.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;7&nbsp;:</span> Le processus s&rsquo;ex√©cute dans le temps, et le programme d√©crit ce processus dans l&rsquo;espace.  Comme le programmeur manipule et lit le programme, celui-ci doit refl√©ter le plus directement possible le d√©roulement du processus.</figcaption>
</figure>

</div>

<p>
Pour Dijkstra, on comprend un programme en suivant les instructions une √† une.
C&rsquo;est facile √† faire pour un programme qui contient juste une liste
d&rsquo;affectations √† des registres et de simples additions: on met son doigt sur la
premi√®re ligne, puis on suit les instructions, une √† une, jusqu&rsquo;√† la derni√®re.
On peut comme ceci retrouver la valeur d&rsquo;un registre particulier apr√®s la
dixi√®me instruction.  Si on ex√©cute le programme plusieurs fois, le registre √†
cet endroit aura toujours la m√™me valeur.  C&rsquo;est un <i>invariant</i> du
programme √† cet endroit, qui peut √™tre utile pour v√©rifier que le processus
correspond √† une sp√©cification donn√©e.  La correspondance entre le programme et
le processus est directe.
</p>

<p>
On peut continuer de localiser ces invariants dans des programmes plus
complexes.  Si l&rsquo;on consid√®re des conditions introduites par un <code>if then else</code>
ou un <code>cond</code>, suivre le flot d&rsquo;ex√©cution est encore simple: il suffit de prendre
la branche correspondante.  Pour les boucles (<code>while</code>, <code>repeat A until B</code>), il
faudra prendre en compte la valeur actuelle de l&rsquo;indice de boucle pour savoir
s&rsquo;il faut r√©p√©ter le corps de la boucle encore une fois, ou s&rsquo;il faut sortir.
Pour les appels de proc√©dures, on ne peut plus se contenter d&rsquo;utiliser un seul
doigt pour suivre la ligne de code courante, il faut aussi tenir compte de la
pile d&rsquo;appels en cours, pour savoir o√π continuer l&rsquo;ex√©cution lorsque la
proc√©dure actuelle prend fin.
</p>

<p>
L&rsquo;instruction courante, l&rsquo;indice de boucle, et la pile d&rsquo;appels forment ce que
Dijkstra appelle un syst√®me de coordonn√©es de l&rsquo;ex√©cution du processus.  On peut
localiser pr√©cis√©ment un point d&rsquo;ex√©cution du processus en donnant une position
dans ce syst√®me de coordonn√©es.  Et √† un point d&rsquo;ex√©cution du processus on peut
rattacher un invariant, ce qui permet de s&rsquo;assurer de la correction du
programme.
</p>

<p>
Et c&rsquo;est l√† que <code>goto</code> pose probl√®me.  En utilisant un <code>goto</code>, le processus peut
continuer l&rsquo;ex√©cution vers n&rsquo;importe quelle ligne du programme: m√™me au beau
milieu d&rsquo;une proc√©dure, ou d&rsquo;une boucle.  Le syst√®me de coordonn√©e n&rsquo;est plus
suffisant pour conna√Ætre avec certitude l&rsquo;√©tat du processus, les valeurs des
variables.  Il faudrait √©galement savoir √† tout moment le chemin exact emprunt√©
par le processus.  Mais ce n&rsquo;est plus un syst√®me de coordonn√©es: on ne peut plus
raisonner localement dans une boucle ou une proc√©dure, il faut consid√©rer
l&rsquo;int√©gralit√© du programme.
</p>

<p>
Pour Dijkstra, <code>goto</code> est une construction qui permet trop facilement de
transformer le programme en v√©ritable labyrinthe; d&rsquo;obscurcir la correspondance
entre le programme et le processus.  C&rsquo;est une construction qui va donc √†
l&rsquo;encontre du but qu&rsquo;il a fix√© en commen√ßant la lettre.
</p>

<p>
Mais la programmation structur√©e ne se r√©duit pas √† l&rsquo;abolition des <code>goto</code> dans
un programme.  Au contraire, se concentrer sur le <code>goto</code> serait passer
compl√®tement √† c√¥t√© du message initial; Knuth le remarque tr√®s justement [<a href="#Knu-74">Knu74</a>]:
</p>

<blockquote>
<p>
There has been far too much emphasis on GO TO elimination instead of the really
important issues; people have a natural tendency to set up an easily understood
quantitative goal like the abolition of jumps, instead of working directly for a
qualitative goal like good program structure.
</p>
</blockquote>

<p>
La programmation structur√©e tente simplement de r√©soudre les probl√®mes pos√©s par
la complexit√© croissante des programmes.  Les programmes pour les premiers
ordinateurs, √©crits en assembleur ou langage machine, avaient comme principal
objectif d&rsquo;utiliser au mieux les capacit√©s de l&rsquo;ordinateur.  L&rsquo;assembleur est un
langage flexible, qui offre notamment la possibilit√© de changer le programme
charg√© en m√©moire pendant l&rsquo;ex√©cution (<i>self-modifying code</i>).  Pour optimiser
l&rsquo;utilisation de la m√©moire, l&rsquo;affectation des registres se fait √† la main, en
prenant garde qu&rsquo;aucun code n&rsquo;√©crase les registres d&rsquo;un autre.  Plus les
machines deviennent rapides, et moins toutes ces techniques de programmation en
assembleur deviennent n√©cessaires.  Le frein vient surtout de notre capacit√© √†
comprendre et g√©rer de larges programmes √©crits dans des langages de plus
haut niveau.  Wirth [<a href="#Wir-74a">Wir74a</a>] relate ce changement de contraintes:
</p>

<blockquote>
<p>
As the power of computers on the one side, and the complexity and size of the
programmer&rsquo;s task on the other continued to grow with a speed unmatched by any
other technological venture, it was gradually recognized that the true challenge
does not consist in pushing computers to their limits by saving bits and
microseconds, but in being capable of organizing large and complex programs, and
assuring that, they specify a process that for all admitted inputs produces the
desired results.  In short, it became clear that any amount of efficiency is
worthless if we cannot provide <i>reliability</i>.
</p>
</blockquote>

<p>
La programmation structur√©e cherche donc √† produire des programmes fiables avant
toute chose.  Wirth la d√©crit comme un mouvement, une attitude plut√¥t qu&rsquo;une
liste de r√®gles √† suivre:
</p>

<blockquote>
<p>
[Structured programming] is the expression of a conviction that the programmer&rsquo;s
knowledge must not consist of a bag of tricks and trade secrets, but of a
general intellectual ability to tackle problems systematically, and that
particular techniques should be replaced (or augmented) by a method.  At its
heart lies an <i>attitude</i> rather than a recipe: the admission of the limitations
of our minds.  The recognition of these limitations can be used to our
advantage, if we carefully restrict ourselves to writing programs which we can
manage intellectually, where we fully understand the totality of their
implications.
</p>
</blockquote>

<p>
Mais Wirth nous donne n√©anmoins des recettes.
</p>

<p>
Argues for a single entry point into procedures, and single exit point.  Not
jumping directly in the middle, or exiting prematurely.
</p>

<p>
Exemplified by ALGOL, and Pascal [<a href="#Wir-74">Wir74b</a>,<a href="#Wir-74a">Wir74a</a>].
</p>

<p>
On the legacy front, most programmers are cargo-culting the fear of GOTO (though
Knuth argues that it has its uses [<a href="#Knu-74">Knu74</a>]).  Few languages in use today propose
it.  However, the discipline of single-exit is more controversial, as most
modern languages offer constructs for early exits from procedures (return
statement) or from loops (break and continue statements, sometimes with
labels).
</p>

<p>
The fear of GOTO is an example of focusing on the wrong issue: structured
programming is a proposal for clearer programs.  Blindly removing all GOTOs and
labels from an unstructured program does not make it structured.  The focus is
on writing programs that clearly reflect their dynamic process.  As Parnas noted
[<a href="#DBB+03">DBB+03</a>], modularity is solved by improving the design and documentation
processes, not by adding a &laquo;&nbsp;module&nbsp;&raquo; statement to the language.  The same
situation arises here.
</p>

<p>
Knuth finit sa d√©fense du GOTO par imaginer les syst√®mes de manipulation de
programmes du futur:
</p>

<blockquote>
<p>
Program manipulation systems appear to be a promising future tool which will
help programmers to improve their programs, and to enjoy doing it.  Standard
operating procedure nowadays is usually to hand code critical portions of a
routine in assembly language.  Let us hope such assemblers will die out, and we
will see several levels of language instead: At the highest levels we will be
able to write abstract programs, while at the lowest levels we will be able to
control storage and register allocation, and to suppress subscript range
checking, etc.  With an integrated system it will be possible to do debugging
and analysis of the transformed program using a higher level language for
communication.  All levels will, of course, exhibit program structure
syntactically so that our eyes can grasp it.
</p>
</blockquote>

<p>
L&rsquo;id√©e est tentante, mais peut-√™tre trop enthousiaste.  Knuth √©crit en 1974, et
je peux constater que 40 ans plus tard la situation n&rsquo;est pas celle pr√©dite.
Bien qu&rsquo;il existe de nombreux langages de programmation, et beaucoup qui sont
qualifi√©s de &laquo;&nbsp;haut-niveau&nbsp;&raquo;, aucun ne permet de manipuler diff√©rents niveaux
d&rsquo;abstraction comme le d√©crit Knuth.  Aucun ne r√©concilie la perte de contr√¥le
d&rsquo;efficacit√© impliqu√©e avec la mont√©e en abstraction.
</p>

<p>
Mais peut-√™tre que Knuth s&rsquo;en est lui-m√™me rendu compte.  Le langage du futur
√©tait annonc√© pour 1984, l&rsquo;ann√©e o√π il publie son syst√®me de Literate
Programming qui permet de m√™ler une description haut-niveau du programme en
toutes lettres et code machine bas-niveau.
</p>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13"><span class="section-number-3">2.3</span> Mod√©liser le monde: la programmation objet</h3>
<div class="outline-text-3" id="text-2-3">
<div class="full-figure">

<figure>
<p><img src="img/scuola.jpg" alt="scuola.jpg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;8&nbsp;:</span> L&rsquo;√âcole d&rsquo;Ath√®nes. Rapha√´l, 1509&#x2013;1510.</figcaption>
</figure>

</div>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9"><span class="section-number-4">2.3.1</span> <span class="todo BARE">BARE</span> Smalltak</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Design and Implementation [<a href="#Ing-78">Ing78</a>].
</p>

<p>
Opens with a definition of modularity:
</p>
<blockquote>
<p>
No part of a complex system should depend on the internal details of any other
part.
</p>

<p>
[&#x2026;]
</p>

<p>
Objects are created and manipulated by sending messages.  The communication
metaphor supports the principle of modularity, since any attempt to examine or
alter the state of an object is sent as a message to that object, and the sender
need never know about internal representation.
</p>

<p>
[&#x2026;]
</p>

<p>
The class is the natural unit of modularity, as it describes all the external
messages understood by its instances, as well as all the internal details about
methods for computing responses to messages and representation of data in the
instances.
</p>
</blockquote>

<p>
Smalltalk is designed with modularity, as classes encapsulate object
descriptions and methods, and can only interact through messages.
</p>

<p>
An example of extending the system: adding new objects and a printer for them.
Similar to the expression problem.
</p>

<blockquote>
<p>
Adding a new class of data to a programming system is soon followed by the need
to print objects of that class. In many extensible languages, this can be a
difficult task at a time when things should be easy.  One is faced with having
to edit the system print routine which (a) is difficult to understand because it
is full of details about the rest of the system, (b) was written by someone else
and may even be in another language, and (c) will blow the system to bits if you
make one false move.  Fear of this often leads to writing a separate print
routine with a different name which then must be remembered.
</p>

<p>
In our object-oriented system, on the other hand, printing is always effected by
sending the message <code>printon: s</code> (where s is a character stream) to the object
in question.  Therefore the only place where code is needed is right in the new
class description.  If the new code should fail, there is no problem; the
existing system is unmodified, and can continue to provide support.
</p>
</blockquote>

<p>
Changing a field inside <code>Rectangle</code> does not need to change code external to the
object, and global recompilation is avoided.
</p>

<p>
Additional story on the vision of Smalltalk can be found in [<a href="#Kay-93">Kay93</a>]; a larger
perspective is given in [<a href="#Mul-15">MP15</a>].
</p>
</div>

<div id="outline-container-orgheadline8" class="outline-5">
<h5 id="orgheadline8">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline8">
<p>
Subclassing, and reflection.  Everything as an object, so message dispatch is
just a method on the meta class, and can be altered.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10"><span class="section-number-4">2.3.2</span> <span class="todo BARE">BARE</span> Prototype-based programming</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
A collection of (at least) the following papers (or revisions of them):
</p>
<ul class="org-ul">
<li>[<a href="#Tai-97">Tai97</a>]</li>
<li>[<a href="#DMB-98a">DMB98a</a>] (mostly a translation of [<a href="#DMB-98">DMB98b</a>])</li>
<li>[<a href="#GBO+98">GBO+98</a>]</li>
<li>[<a href="#Bor-86">Bor86</a>]</li>
<li>[<a href="#SU-95">SU95</a>]</li>
<li>[<a href="#Smi-95">Smi95</a>]</li>
<li>[<a href="#MMM+98">MMM+98</a>]</li>
<li>[<a href="#Bla-91">Bla91</a>] &amp; [<a href="#Bla-94">Bla94</a>]</li>
<li>[<a href="#Wol-96">Wol96</a>]</li>
<li>[<a href="#Moo-96">Moo96</a>]</li>
<li>[<a href="#Nob-01">Nob01</a>]</li>
<li>[<a href="#DeM-98">Meu98</a>]</li>
</ul>

<p>
[<a href="#Tai-97">Tai97</a>] is a philosophical take on the basis for class-based and prototype-based
languages.  Ascribing to classes is following the school of Plato and Aristotle
[<a href="#Pla-98">Pla98</a>,<a href="#Ari-35">AriBC</a>].  Plato distinguished between <i>forms</i>, the ideal description of
things, and <i>instances</i> of these forms.  He regarded forms as being more real
than instances.  Aristotle believed in &laquo;&nbsp;a single correct taxonomy of all natural
things&nbsp;&raquo;, and classified things using the following rule:
</p>
<pre class="example">
essence = genus + differential
</pre>
<p>
which mirrors class creation in class-based languages.
</p>

<p>
Classification has been criticized, notably by Wittgenstein [<a href="#Wit-53">Wit53</a>], as being
subjective.  Some concepts are difficult to define by intension ‚Äì through a list
of common properties that all instances must share.  Rather, Wittgenstein
proposes the notion of <i>family resemblance</i>.  Meaning is not determined by a
definition, but by similarity to representative prototypes.
</p>

<p>
This philosophical heritage has a few implications for programming:
</p>
<ul class="org-ul">
<li>there are no optimal class hierarchies</li>
<li>in a class hierarchy, the middle classes are often the best representatives.
Higher classes are too abstract; lower classes too specific.</li>
<li>prototypes may map better to the usual human process: iterate from examples.</li>
</ul>

<p>
Designers of class-based or prototype-based languages are seldom aware of the
philosophical issues of both models, but focus more on technical matters.  Kevo
[<a href="#Tai-93">Tai93a</a>] is a prototype-based language with a notion of family
resemblance. [<a href="#Tai-93b">Tai93b</a>] offer similar insights on the notion of object.
</p>

<p>
[<a href="#DMB-98">DMB98b</a>] tries to classify prototype-based languages (ironically).  Prototype-base
d languages are advantageous for describing exceptional instances, multiple
points of view of the same entity, and incomplete objects.
</p>

<p>
They identify the following mechanisms common to prototype-based languages:
</p>
<ul class="org-ul">
<li>message passing</li>
<li>3 ways of creating objects (ex nihilo, cloning, and extension)</li>
<li>delegation</li>
<li>dynamic dispatch</li>
</ul>

<p>
Prototype-based languages also introduce new issues:
</p>
<ul class="org-ul">
<li>Fragmented entities.  Since objects are described differentially, no single
object in the system reify the complete entity.  To clone it completely, we
would need to clone all its parts, but they are not reified (e.g., traits
objects are only conventions, not language primitives).</li>
<li>Sharing between clones of the same object.</li>
<li>Sharing between clones of different objects.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12"><span class="section-number-4">2.3.3</span> <span class="todo TRANSLATE">TRANSLATE</span> Self</h4>
<div class="outline-text-4" id="text-2-3-3">
<p>
The power of simplicity [<a href="#US-91">US91</a>].
</p>

<p>
Pure object-oriented language.  No variables, but slots containing objects that
return themselves.
</p>

<p>
No classes.  No control structure.
</p>

<p>
The absence of distinction may not be a good thing in practice:
</p>
<blockquote>
<p>
The absence of class-instance distinction may make it too hard to understand
which objects exist solely to provide shared information for other objects.
Perhaps SELF programmers will create entirely new organizational structures.  In
any case, SELF&rsquo;s flexibility poses a challenge to the programming environment;
it will have to include navigational and descriptive aids.
</p>

<p>
[later, in the conclusion]
</p>

<p>
Reducing the number of basic concepts in a language can make the language easier
to explain, understand, and use.  However, there is a tension between making the
language simpler and making the organization of a system manifest.  As the
variety of constructs decreases, so does the variety of linguistic clues to a
system&rsquo;s structure.
</p>
</blockquote>

<p>
They cite [<a href="#UCC+91">UCC+91</a>] for pointers on structuring programs in SELF.
</p>

<p>
Classes are abstract description of objects, but prototypes are always
concrete.  Each object is an example, and can be easily cloned.  Class
hierarchies are hard, and impose a structure; prototypes less so.
</p>

<p>
Classes forces you to create a template, even when you deal with several objects
with unique behavior.
</p>

<p>
Activation records for methods inherit from the receiver object, so the receiver
is on the chain for binding lookup.
</p>

<p>
They note that they could build &laquo;&nbsp;class-like&nbsp;&raquo; objects that hold code to create
new clones, and also hold the shared behavior, though they &laquo;&nbsp;do not believe this
is the best way to construct a system&nbsp;&raquo;.
</p>

<p>
In [<a href="#UCC+91">UCC+91</a>], the following organization is described:
</p>
<ul class="org-ul">
<li>Traits object for methods (shared by all instances of an object).</li>
<li>A prototype object with a default implementation.</li>
<li>Instances are created from cloning the prototype.</li>
</ul>

<p>
Abstract objects dispense of the prototype, and singleton objects contain
methods and state without providing a copy method.
</p>

<p>
They note that OO supports &laquo;&nbsp;differential programming&nbsp;&raquo;, which is to define new
data types as differences from existing data types.  In Smalltalk, differential
programming is achieved through subclassing.  In SELF, they call it &laquo;&nbsp;refining
traits objects&nbsp;&raquo;, but the mechanism is delegation through the parent link.
</p>

<p>
An oddity: they state that parent links are constant, though the introduce a
<code>dataParent</code> setter in figure 3.  Later they say that parent slot are like other
data slots, assignable.
</p>

<p>
Prototypes allow for multiple behavior modes, through dynamic inheritance
switching.  Behavior modes enhance the clarity of the code, though they do not
comment on the potential performance costs.
</p>
</div>

<div id="outline-container-orgheadline11" class="outline-5">
<h5 id="orgheadline11">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline11">
<p>
Prototypes, and message passing.  Prototypes are more general and simpler than
inheritance.
</p>

<p>
However prototypes do not originate with SELF [<a href="#Bor-86">Bor86</a>,<a href="#Lie-86">Lie86</a>].
</p>

<p>
[<a href="#Lie-86">Lie86</a>] makes a good case for prototypes as being a simpler model to learn, as
well as being more intuitive.  Humans derive general concepts from examples, not
the other way around.  Class-based languages require you to commit to the
concepts first.
</p>

<p>
Prototype-based and class-based languages provide different mechanisms for
realizing differential programming,
</p>

<p>
Is differential programming sufficient to solve the problem of modular
instrumentation?  In the case of Narcissus, it was not, since the interpreter
was not OO.  But the open scope pattern might be equivalent, dynamically, to
inheritance.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23"><span class="section-number-3">2.4</span> R√©ifier le langage pour s√©parer les pr√©occupations</h3>
<div class="outline-text-3" id="text-2-4">

<figure>
<p><img src="img/m√ºnchhausen.jpg" alt="m√ºnchhausen.jpg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;9&nbsp;:</span> Le baron de M√ºnchhausen √©vite la noyade en se hissant par les cheveux. Gustave Dor√©, 1862.</figcaption>
</figure>
</div>

<div id="outline-container-orgheadline14" class="outline-4">
<h4 id="orgheadline14"><span class="section-number-4">2.4.1</span> <span class="todo TRANSLATE">TRANSLATE</span> Reflection</h4>
<div class="outline-text-4" id="text-2-4-1">
<p>
[<a href="#Tan-09">√T09b</a>] gives a nice survey of reflection and its uses.  Useful distinctions are
made between <i>introspection</i>, <i>introcession</i>, <i>structural reflection</i>, and
<i>behavioral reflection</i>; also between a program (a textual description) and a
<i>computational system</i> (a running process described by a program).
</p>

<p>
A interesting observation on binding is quoted from [<a href="#MJD-96">MJD96</a>]:
</p>
<blockquote>
<p>
The general trend in the evolution of programming languages has been to postpone
formal binding times towards the running of programs, but to use more and more
sophisticated analysis and implementation techniques to bring actual times back
to the earlier stages.
</p>
</blockquote>
<p>
Later binding = more runtime flexibility, but also less guarantees and less
performance.  The DLS submission is a perfect example.
</p>

<p>
[<a href="#DS-01">DS01</a>] give a general method to reify selected parts of a meta-circular
interpreter.
</p>

<p>
[<a href="#Ste-94a">Ste94</a>] studies object-oriented languages which support open implementation.
The open implementation of a language (the interpreter) is itself written in one
language called the <i>implementation language</i>, and its meta-level interface
allows the system to interpret a range of <i>engendered languages</i>.
</p>

<p>
[<a href="#SW-96">SW96</a>] describe three approaches to code non-functional requirements while
preserving the separation of concerns: systems-based, language-based, and
MOP-based.  They find that MOP-based solutions are more flexible, especially as
they can be applied to other domains without modifying the code.  However, they
consider non-functional requirements like persistence and atomicity.
</p>

<p>
Reflection for dynamic adaptation [<a href="#DSC+99">DSC+99</a>].  Dynamic adaptation echoes the
motivation of open implementation: an application should adapt dynamically to
the need of the users, thereby enhancing performance.  This is mostly a concern
in systems software, operating systems and middlewares.  They use a memory
allocator example and compare using design patterns, DLLs and reflection.
Essentially, reflection is more flexible, but also less efficient.
</p>

<p>
[<a href="#RC-02">RC02</a>] illustrates how unanticipated dynamic adaptation can be achieved using
MOPs in Java.
</p>

<p>
Unifying AOP and OOP [<a href="#RS-09a">RS09</a>].
</p>

<p>
[<a href="#ADF-11">ADF11</a>] proposes a proxy protocol for values.  A <i>virtual value</i> is wrapped by a
proxy which has a handful of traps that are useful to override: when the value
is called as a function, when the value is used as a record, when the value is
used as an index in an array, when the value is used in a binary operation &#x2026;
</p>

<p>
They exhibit several scenarios where virtual values are useful: lazy evaluation,
revocable membranes, and tainting.  They modified Narcissus (again!) to add
their virtual values extension, but the implementation seems incomplete
regarding all operations available in JavaScript.
</p>

<p>
They motivate virtual values as a nice way to extend languages without having to
touch the interpreter.  Though they do not talk at all of the limitations of
this approach: can you write any extension that you would write by modifying the
interpreter with virtual values?  The only downsides they acknowledge are
performance hits and potential breakage of JS invariants (‚Äòx*x&rsquo; returning a
negative number, or ‚Äòx <code>=</code> x&rsquo; returning false).
</p>

<p>
It seems evident that virtual values are only hooks for values.  So you cannot
override any other part of the module which is not explicitly given by a trap.
Getting a trace of the interpreter execution is out.  Also, you need to specify
your analysis from the point of view of handler on values, not by altering the
interpreter semantics.
</p>

<p>
[<a href="#KT-13">KT13</a>] implements access control on JS objects through ES6 proxies.  Improves a
previous implementation which used code transformation; better performance, less
maintenance.
</p>
</div>
</div>

<div id="outline-container-orgheadline15" class="outline-4">
<h4 id="orgheadline15"><span class="section-number-4">2.4.2</span> <span class="done STABLE">STABLE</span> L&rsquo;impl√©mentation ouverte</h4>
<div class="outline-text-4" id="text-2-4-2">
<p>
La r√©flexion dans les langages √† objets, et en particulier dans CLOS, permet √†
des programmes de contr√¥ler, d&rsquo;inspecter, de modifier, et d&rsquo;√©tendre la
s√©mantique du langage.
</p>

<blockquote>
<p>
One meaning of the word reflect is to consider some subject matter.  Another is
to turn back something (e.g. light or sound).  Punning on these two meanings, we
get the notion of turning back one&rsquo;s consideration or considering one&rsquo;s own
activities as a subject matter.  Our ability as humans to reflect in this sense
has been credited, since Aristotle, with our success in adapting to new
situations and mastering our environment.  Naturally, it was widely conjectured
in the artificial intelligence community that by providing reflective
capabilities to computational systems, we would obtain systems with greater
plasticity and consequently, enhanced functionality. ‚Äî [<a href="#Rao-91">Rao91</a>]</p>
</blockquote>

<p>
Mais la r√©flexion n&rsquo;est pas restreinte aux impl√©mentations de langages √† objets,
ni aux langages de programmation.  Les membres de Xerox PARC se sont donc
int√©ress√©s √† appliquer la r√©flexion sur √† d&rsquo;autres syst√®mes, ce qu&rsquo;ils appellent
plus g√©n√©ralement &laquo;&nbsp;impl√©mentation ouverte&nbsp;&raquo; [<a href="#Rao-91">Rao91</a>,<a href="#Kic-96">Kic96</a>,<a href="#MLM+97">MLM+97</a>,<a href="#KLL+97">KLL+97</a>].
</p>

<p>
[<a href="#Rao-91">Rao91</a>] commence par remarquer que l&rsquo;interpr√®te d&rsquo;un langage de programmation
engendre un processus √† partir d&rsquo;un programme, et que, parall√®lement, tout
syst√®me d√©finit une <i>interface</i> qui peut √™tre vue comme un langage; tout syst√®me
est donc un interpr√®te.  Alors, la r√©flexion dans les langages de programmation
n&rsquo;est qu&rsquo;un cas particulier, et on peut l&rsquo;appliquer √† tout syst√®me qui expose
une interface.  Et comme un interpr√®te r√©flexif permet au programme d&rsquo;inspecter
et de modifier le processus engendr√© par l&rsquo;interpr√®te, il en va de m√™me pour un
syst√®me plus g√©n√©ral.
</p>

<p>
Mais √† quoi ressemble un syst√®me r√©flexif, en g√©n√©ral?  Rao d√©finit un syst√®me
<i>√† impl√©mentation ouverte</i> comme un syst√®me ayant deux interfaces: l&rsquo;interface
de base, qui est l&rsquo;interface classique associ√©e au syst√®me, et l&rsquo;interface de
meta-niveau, qui r√©v√®le en partie l&rsquo;impl√©mentation de l&rsquo;interface de base.
</p>

<div style="margin-top:-8rem" class="side-figure">

<figure>
<p><img src="img/sota1.svg" alt="sota1.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;10&nbsp;:</span> On va pr√©f√©rer ici le terme &laquo;&nbsp;interface d&rsquo;impl√©mentation&nbsp;&raquo; pour l&rsquo;interface de meta-niveau.</figcaption>
</figure>

</div>

<p>
Pour illustrer ces deux interfaces, il prend l&rsquo;exemple d&rsquo;un syst√®me de gestion
de fen√™tre pour CLOS, appel√© Silica.  Dans un syst√®me de gestion de fen√™tre,
l&rsquo;interface de base permet de construire des arbres de fen√™tres, d&rsquo;interroger et
de modifier ces arbres (pour acc√©der aux fen√™tres, en ajouter, les retirer&#x2026;),
et de lire et √©crire dans les fen√™tres.
</p>

<p>
Comment les fen√™tres, et la structure d&rsquo;arbre sont impl√©ment√©s peut impacter
l&rsquo;utilisateur du syst√®me de fen√™tre.  En particulier, Rao prend l&rsquo;exemple d&rsquo;un
tableur qui cr√©√© une fen√™tre pour chaque cellule de la feuille de calcul.  Ce
choix peut para√Ætre curieux, mais est justifi√© par la r√©utilisation des
fonctionnalit√©s du syst√®me de fen√™tre (capture de la souris, peindre les
cellules en fonction de leur visibilit√©, &#x2026;) pour simplifier l&rsquo;impl√©mentation
du tableur.  Dans un syst√®me de fen√™tre na√Øf, il faut allouer de la m√©moire pour
chaque fen√™tre, alors que dans le cas du tableur on pourrait partager bon nombre
de propri√©t√©s entre les fen√™tres utilis√©es comme cellules.  De m√™me, lorsque
qu&rsquo;un clic de souris est d√©tect√© par le syst√®me de fen√™tre, il faut parcourir
les arbres de fen√™tres pour d√©terminer la fen√™tre qui est actuellement au dessus
des autres, car les fen√™tres peuvent se superposer.  Mais dans un tableur, les
cellules ne peuvent pas se superposer, donc on peut d√©terminer le clic de souris
directement gr√¢ce √† ses coordonn√©es.  Ces optimisations ne sont possibles que si
le syst√®me de fen√™tre laisse au programme client la possibilit√© de modifier son
impl√©mentation.  En l&rsquo;occurrence, Silica est un syst√®me √† impl√©mentation
ouverte, et Rao montre qu&rsquo;il peut supporter ces optimisations en utilisant
l&rsquo;interface d&rsquo;impl√©mentation.
</p>

<p>
Pour r√©aliser cette interface, Silica est construit en deux couches: une couche
qui impl√©mente les fen√™tres, pour fournir l&rsquo;interface de base; et une couche qui
impl√©mente les contrats, pour stipuler la politique d&rsquo;utilisation des fen√™tres
par le client de l&rsquo;interface (comment redessiner une fen√™tre, comment rapporter
les √©v√©nements souris, comment g√©rer les sous-fen√™tres, &#x2026;).
</p>

<div style="margin-top:-10rem" class="side-figure">

<figure>
<p><img src="img/sota2.svg" alt="sota2.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;11&nbsp;:</span> Une fa√ßon de fournir l&rsquo;interface d&rsquo;impl√©mentation est de structurer le syst√®me en deux parties, une de bas-niveau qui g√®re les d√©tails d&rsquo;impl√©mentation et est manipulable via l&rsquo;interface d&rsquo;impl√©mentation, et une de haut-niveau qui utilise la partie inf√©rieure pour pr√©senter l&rsquo;interface de base.</figcaption>
</figure>

</div>

<p>
Le client de l&rsquo;interface de base n&rsquo;a pas besoin de modifier les contrats par
d√©faut.  En revanche, c&rsquo;est par cette couche qu&rsquo;il faut passer pour r√©aliser les
optimisations du tableur.
</p>

<p>
Mais il ne s&rsquo;agit pas ici de simplement s√©parer le <i>m√©canisme</i> de la
<i>politique</i>; un syst√®me √† impl√©mentation ouverte ne propose pas n√©cessairement
toute libert√© au client.  Tout comme un interpr√®te peut n&rsquo;exposer que certaines
parties du langage par une interface r√©flexive, ici aussi un syst√®me √†
impl√©mentation ouverte peut choisir l&rsquo;√©tendue de son interface d&rsquo;impl√©mentation.
</p>

<p>
[<a href="#KLL+97">KLL+97</a>] donne des recettes pour construire ces syst√®mes, en fonction des besoins
des programmes clients:
</p>

<ol class="org-ol">
<li>Le client n&rsquo;a aucun contr√¥le: le syst√®me adapte son impl√©mentation en
observant le programme client.</li>
<li>Le client d√©clare son utilisation du syst√®me, et le syst√®me s√©lectionne une
strat√©gie pr√©-√©tablie.</li>
<li>Le client sp√©cifie la strat√©gie parmi celles pr√©-√©tablies par le syst√®me.</li>
<li>Le client fournit la strat√©gie au syst√®me.</li>
</ol>

<p>
Le degr√© 4 donne le plus de contr√¥le au client, mais on voit que d&rsquo;autres styles
d&rsquo;impl√©mentation ouverte sont possibles.
</p>

<hr >

<p>
En somme, le concept d&rsquo;impl√©mentation ouverte r√©pond au besoin de certains
programmes d&rsquo;avoir √† optimiser des choix d&rsquo;impl√©mentation du syst√®me qu&rsquo;ils
utilisent.  Le syst√®me laisse au programme la possibilit√© de modifier ces choix,
statiquement ou m√™me dynamiquement, via une interface d&rsquo;impl√©mentation.  Le
syst√®me peut √™tre adapt√© √† plus de cas qu&rsquo;un syst√®me qui ne proposerait pas
d&rsquo;interface d&rsquo;impl√©mentation; le syst√®me √† impl√©mentation ouverte promet
davantage de r√©utilisation de code.
</p>

<p>
On ne sp√©cifie pas <i>comment</i> cette interface d&rsquo;impl√©mentation est rendue
disponible par le syst√®me.  Dans les interpr√®tes, la r√©flexion est souvent
utilis√©e, mais d&rsquo;autres solutions sont envisageables suivant le syst√®me:
inversion de contr√¥le, patrons de conception Strat√©gie, n&rsquo;importe quel moyen
d&rsquo;ex√©cuter le code du client pour modifier le processus consid√©r√© comme √©tant de
la responsabilit√© du module.
</p>
</div>
</div>

<div id="outline-container-orgheadline22" class="outline-4">
<h4 id="orgheadline22"><span class="section-number-4">2.4.3</span> <span class="done STABLE">STABLE</span> La programmation par aspects</h4>
<div class="outline-text-4" id="text-2-4-3">
<p>
Autre production du laboratoire PARC de Xerox, la programmation par aspects est
une technique qui pourrait √™tre utilis√©e pour fournir l&rsquo;interface
d&rsquo;impl√©mentation d&rsquo;un syst√®me [<a href="#KLM+97">KLM+97</a>,<a href="#MKL-97">MKL97</a>].
</p>

<p>
La motivation derri√®re la programmation par aspects est tr√®s proche de la
motivation pour l&rsquo;impl√©mentation ouverte: les deux approches proposent de
nouvelles techniques pour organiser le code, pour qu&rsquo;il soit √† la fois simple √†
√©crire, facile √† maintenir, et ne sacrifie pas l&rsquo;efficacit√©.  Dans
l&rsquo;impl√©mentation ouverte l&rsquo;id√©e est que le syst√®me expose une interface
secondaire qui donne un acc√®s direct √† son fonctionnement interne, ce qui permet
certaines optimisations.  Dans la programmation par aspects, l&rsquo;id√©e est de
reconna√Ætre que la d√©composition d&rsquo;un programme selon l&rsquo;axe classique des
fonctions et des classes n&rsquo;est pas suffisante pour maintenir ces trois qualit√©s;
les aspects y rem√©dient en introduisant une nouvelle dimension de composition.
</p>
</div>

<div id="outline-container-orgheadline16" class="outline-5">
<h5 id="orgheadline16">La distinction entre les composants et les aspects</h5>
<div class="outline-text-5" id="text-orgheadline16">
<blockquote>
<p>
A design process and a programming language work well together when the
programming language provides abstraction and composition mechanisms that
cleanly support the kinds of units the design process breaks the system into.
‚Äî¬†[<a href="#KLM+97">KLM+97</a>]</p>
</blockquote>

<p>
Pour expliquer ce qu&rsquo;est un aspect, [<a href="#MKL-97">MKL97</a>] part d&rsquo;un exemple.  Le syst√®me qui
les int√©resse prend une image en noir et blanc et lui applique une s√©rie de
filtres; c&rsquo;est une partie d&rsquo;un syst√®me de reconnaissance de caract√®res.  Ils
souhaitent que le syst√®me soit facile √† d√©velopper et √† maintenir, mais aussi
efficace, car les images trait√©es sont grandes, et les filtres rapidement
co√ªteux √† calculer.
</p>

<div class="side-figure">

<figure>
<p><img src="img/aop1.svg" alt="aop1.svg">
</p>
</figure>

</div>

<p>
Pour faciliter le d√©veloppement, il suffit de cr√©er des filtres composables.
D&rsquo;abord des filtres basiques, comme <code>Or</code>, <code>And</code>, <code>Not</code>, analogues des op√©rateurs
communs sur les bits, mais appliqu√©s aux images, pixel par pixel:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">Or</span>(<span style="font-weight: bold; font-style: italic;">a</span>, <span style="font-weight: bold; font-style: italic;">b</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">result</span> = Image.<span style="font-weight: bold;">new</span>(a.width, a.height)

  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">x</span>=0; x &lt; a.width; ++x) {
    <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">y</span>=0; y &lt; a.height; ++y) {
      result.pixel(x, y,
                   a.pixel(x, y) || b.pixel(x, y))
    }
  }

  <span style="font-weight: bold;">return</span> result
}
</pre>
</div>

<p>
Puis, √† partir de ces filtres √©l√©mentaires, on peut en d√©finir des plus
complexes:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">Remove</span> = (a, b) =&gt; And(a, Not(b))
<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">TopEdge</span> = (a) =&gt; Remove(a, Down(a))
<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">HorizontalEdge</span> = (a) =&gt; Or(TopEdge(a),
                               BottomEdge(a))
...
</pre>
</div>

<p>
On voit que les filtres complexes se d√©finissent tr√®s facilement √† partir des
filtres √©l√©mentaires.  Le code est clair, simple et direct, donc facile √† √©crire
et √† maintenir.  Et pour ce faire, on n&rsquo;a besoin que de composer des proc√©dures.
</p>

<p>
En revanche, c√¥t√© efficacit√©, c&rsquo;est loin d&rsquo;√™tre optimal.  Tous les filtres
√©l√©mentaires, <code>Or</code>, <code>And</code>, <code>Not</code> cr√©ent une nouvelle image interm√©diaire, et
bouclent sur les pixels de l&rsquo;image.  Un filtre composite comme <code>Remove</code> appelle
deux filtres √©l√©mentaires, et donc va cr√©er deux images interm√©diaires, et
it√©rer deux fois sur tous les pixels de l&rsquo;image: une fois dans <code>And</code>, et une
fois dans <code>Not</code>.  Le gaspillage est encore plus important pour les filtres plus
complexes, comme <code>HorizontalEdge</code>.
</p>

<p>
Une version optimis√©e de <code>Remove</code> ne contiendrait qu&rsquo;une seule boucle et ne
cr√©erait qu&rsquo;une seule image, le r√©sultat.  Mais si on √©crit cette version
optimis√©e directement, on perd alors la composition des filtres √©l√©mentaires.
Cherchant l&rsquo;efficacit√©, les auteurs ont r√©√©crit tous les filtres complexes
directement.  Le syst√®me efficace comporte trois optimisations majeures: la
fusion de boucle, l&rsquo;utilisation d&rsquo;un bassin d&rsquo;objet pour √©viter l&rsquo;allocation
d&rsquo;images interm√©diaires, et la m√©moisation des r√©sultats.  Le syst√®me efficace
comporte 35213 lignes de code, alors que la version simple, mais non efficace,
en comporte 768; 5 fois moins de code √† √©crire, et √† maintenir.  C&rsquo;est d&rsquo;autant
plus dommage que les versions optimis√©es suivent toujours le m√™me motif:
fusionner les boucles, pour combiner les op√©rations √† l&rsquo;int√©rieur des boucles
plut√¥t qu&rsquo;√† l&rsquo;ext√©rieur.
</p>

<p>
Alors, peut-on r√©concilier l&rsquo;efficacit√© avec la simplicit√© de la composition des
filtres?  Peut-on arranger les proc√©dures diff√©remment, pour satisfaire les deux
buts √† la fois?  Les auteurs pensent que non.  La composition hi√©rarchique des
filtres est incompatible avec la composition n√©cessaire pour optimiser les
boucles.  Composer les filtres hi√©rarchiquement c&rsquo;est composer les
<i>fonctionnalit√©s</i> offertes par les filtres, de fa√ßon simple et homog√®ne.  Mais
pour optimiser ces filtres complexes, il faut fusionner les boucles qui
appartiennent √† des proc√©dures diff√©rentes.  La composition hi√©rarchique est
r√©alis√©e par la composition des proc√©dures du langage de programmation, mais la
seconde composition, qui d√©passe l&rsquo;unit√© de la proc√©dure, n&rsquo;est pas support√©e
par le langage, et doit √™tre r√©alis√©e manuellement.
</p>

<div style="margin-top:-15rem" class="side-figure">

<figure>
<p><img src="img/aop2.svg" alt="aop2.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;13&nbsp;:</span> Dans <code>Remove</code>, on ne peut pas fusionner les boucles de <code>And</code> et de <code>Not</code> sans outrepasser les fronti√®res impos√©es par les fonctions (<span class="color c0">‚ñ¨</span>).  Il faut un nouvel axe (<span class="color c1">‚ñ¨</span>) de composition.</figcaption>
</figure>

</div>

<p>
C&rsquo;est la distinction que les auteurs font entre <i>composants</i> et <i>aspects</i>.  Si
une fonctionnalit√© du syst√®me peut √™tre impl√©ment√©e par une proc√©dure (ou une
m√©thode, un objet, une API), alors c&rsquo;est un composant; sinon, c&rsquo;est un aspect.
Dans leur exp√©rience, un aspect ne concerne pas la fonctionnalit√© principale du
syst√®me, mais plut√¥t des propri√©t√©s orthogonales ou compl√©mentaires au syst√®me,
comme la performance, ou la gestion d&rsquo;erreurs.  Le but de la programmation par
aspects est de pouvoir exprimer clairement ces deux cat√©gories de
fonctionnalit√©s:
</p>

<blockquote>
<p>
The goal of AOP is to support the programmer in cleanly separating components
and aspects from each other, by providing mechanisms that make it possible to
abstract and compose them to produce the overall system.  This is in contrast to
[classic] programming, which supports programmers in separating only components
from each other by providing mechanisms that make it possible to abstract and
compose them to produce the overall system.
</p>
</blockquote>

<aside style="margin-top:-11rem">
<p>
<i>AOP := Aspect-Oriented Programming</i>
</p>
</aside>
</div>
</div>

<div id="outline-container-orgheadline17" class="outline-5">
<h5 id="orgheadline17">Exprimer les aspects par un langage d√©di√©</h5>
<div class="outline-text-5" id="text-orgheadline17">
<p>
Une impl√©mentation par aspects refl√®te cette distinction.  Pour une application
√©crite dans un langage classique, il y a trois √©l√©ments importants: le
programme, le langage dans lequel le programme est √©crit, et le compilateur pour
ce langage.  Pour une application √©crite en programmation par aspects, on
distingue: le programme des composants, le (ou les) programme des aspects, le
langage des composants, le langage des aspects, et un compilateur qui prend en
compte les deux langages en m√™me temps, qu&rsquo;on appelle le <i>tisseur d&rsquo;aspects</i>.
</p>

<p>
Dans l&rsquo;exemple des filtres d&rsquo;images, le langage de composants est CommonLisp
avec des primitives de plus haut niveau.  Le filtre <code>Or</code> ne s&rsquo;exprime plus avec
une boucle, mais avec une construction plus d√©clarative:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(define-filter or! (a a)
  (pixelwise (a b) (aa bb) (or aa bb)))
</pre>
</div>

<p>
Plut√¥t que de d√©finir une fonction, on d√©finit un <i>filtre</i>, qui it√®re sur chaque
pixel avec l&rsquo;it√©rateur <code>pixelwise</code>.
</p>

<p>
Les filtres ainsi d√©finis sont pass√©s au tisseur d&rsquo;aspects, qui va interpr√©ter
le code pour r√©colter les filtres et it√©rateurs utilis√©s: un filtre complexe,
comme <code>Remove</code>, va faire appel aux filtres primitifs <code>And</code> et <code>Not</code>; le tisseur
lui associe donc ces filtres.  Ce faisant, le tisseur construit la seconde
composition, la composition que le langage proc√©dural ne pouvait pas exprimer.
</p>

<p>
Dans un second temps, le tisseur passe cette information aux programmes
d&rsquo;aspects, qui vont pouvoir r√©aliser les trois optimisations; la fusion de
boucle, la m√©moisation, et le bassin d&rsquo;objets.  Chaque optimisation est un
programme d&rsquo;aspect diff√©rent.  La fusion de boucle par exemple teste si les
arguments d&rsquo;un filtre ont une it√©ration compatible avec l&rsquo;it√©ration faite par le
filtre; si c&rsquo;est le cas, on peut g√©n√©rer une seule boucle qui applique les
op√©rations des arguments et du filtre:
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="font-weight: bold;">cond</span> ((and (eq (loop-shape node) 'pixelwise)
            (eq (loop-shape node) 'pixelwise))
       (fuse loop input 'pixelwise
             ...)))
</pre>
</div>

<p>
Enfin, dans ce syst√®me, le tisseur g√©n√®re du code C pour chaque filtre.
</p>

<p>
Au final, l&rsquo;impl√©mentation par aspects a une performance comparable √†
l&rsquo;impl√©mentation optimis√©e manuellement, en seulement 4500 lignes de code (dont
3500 pour le tisseur), soit seulement 13% du code de la version optimis√©e.  La
version par aspects permet de clairement s√©parer les composants des aspects, ce
qui atteint le but de simplicit√© d&rsquo;√©criture et de maintenance, mais sans
sacrifier l&rsquo;efficacit√©.
</p>

<p>
Dans cet exemple, il est int√©ressant de noter la place importante du tisseur.
La version simple, mais inefficace, du programme ne comportait que 770 lignes.
En 1000 lignes, la version par aspects d√©crit les filtres, et les trois
programmes d&rsquo;aspects qui correspondent aux optimisations.  M√™me ordre de
grandeur.  Mais pour que la version par aspects fonctionne, elle n√©cessite le
tisseur, et celui-ci fait 3 fois la taille du programme client.  M√™me si des
parties du tisseur peuvent √™tre r√©utilis√©es pour d&rsquo;autres programmes, le langage
reste sp√©cifique √† la cr√©ation de filtres pour traiter des images en deux
dimensions.  On peut se poser la question: si l&rsquo;on souhaite appliquer la
programmation par aspects, faut-il r√©impl√©menter un tisseur pour chaque
application?  Y a-t-il d&rsquo;autres fa√ßons de faire?
</p>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-5">
<h5 id="orgheadline18">D&rsquo;autres m√©canismes pour la programmation par aspects</h5>
<div class="outline-text-5" id="text-orgheadline18">
<p>
La caract√©ristique principale de la programmation par aspects est la distinction
entre composants et aspects.  Cette distinction, si elle appara√Æt au moment du
design du programme doit √™tre maintenue dans son impl√©mentation.  Tout
m√©canisme, toute fa√ßon de r√©aliser cette distinction dans le programme est donc
compatible avec la programmation par aspects.  Un langage sp√©cifique pour
l&rsquo;application, qui permet de distinguer composants et aspects, est une fa√ßon de
faire.  La r√©flexion en est une autre.
</p>

<p>
Un syst√®me r√©flexif permet d&rsquo;observer et de modifier le processus d&rsquo;ex√©cution du
programme, au del√† de la s√©paration entre proc√©dures.  Un syst√®me r√©flexif peut
observer la pile d&rsquo;appels, ou tous les messages re√ßus par une classe, ou par
tous les objets du programme.  La r√©flexion permet de composer un programme
selon un axe compl√©mentaire √† celui des proc√©dures; c&rsquo;est donc un m√©canisme de
programmation par aspects.  Les auteurs, certainement familiers avec le concept,
le note:
</p>

<blockquote>
<p>
A reflective system provides the base language and (one or more) meta-languages
that provide control over the base language&rsquo;s semantics and implementation.  In
AOP terms, meta-languages are lower-level aspect languages whose join points are
the &laquo;&nbsp;hooks&nbsp;&raquo; that the reflective system provides.  AOP is a goal, for which
reflection is one powerful tool. ‚Äî¬†[<a href="#KLM+97">KLM+97</a>]</p>
</blockquote>

<p>
Et il y a d&rsquo;autres m√©canismes connus.  Le <code>try/catch</code>, ou le m√©canisme
d&rsquo;exceptions, transcende la fronti√®re des proc√©dures.  Les exceptions ne sont
qu&rsquo;un cas particulier des continuations (<code>call/cc</code> en Scheme), qui permettent de
manipuler le flot d&rsquo;ex√©cution du programme de fa√ßon arbitraire.  Les variables √†
port√©e dynamique permettent de changer le comportement d&rsquo;une proc√©dure qu&rsquo;on
n&rsquo;appelle pas directement; c&rsquo;est une forme de recomposition, mais moins
puissante que les pr√©c√©dentes.
</p>

<p>
Les auteurs de la programmation par aspects justifient la pr√©sence de ces
m√©canismes par le besoin des programmeurs d&rsquo;exprimer les aspects dans des
langages qui proposent de n&rsquo;assembler que des composants.  Mais bien qu&rsquo;ils
permettent d&rsquo;exprimer des aspects, ces m√©canismes sont consid√©r√©s de bas-niveau,
au m√™me titre que la r√©flexion.  Un langage d√©di√© d&rsquo;aspects, comme celui utilis√©
pour optimiser les filtres d&rsquo;image, est d√©claratif, et correspond plus
directement √† l&rsquo;intention du programmeur.  Fournir les outils qui permettent au
programmeur d&rsquo;exprimer cette intention est un des but de la programmation par
aspects:
</p>

<blockquote>
<p>
When we say &laquo;&nbsp;separation of concerns&nbsp;&raquo; we mean the idea that it should be possible
to work with the design or implementation of a system in the natural units of
concern ‚Äì concept, goal, team structure etc. ‚Äì rather than in units imposed on
us by the tools we are using.  We would like the modularity of a system to
reflect the way &laquo;&nbsp;we want to think about it&nbsp;&raquo; rather than the way the language or
other tools force us to think about it.  In software, Parnas is generally
credited with this idea [<a href="#Par-72">Par72</a>,<a href="#Par-74">Par74</a>]. ‚Äî¬†[<a href="#KHH+01">KHH+01</a>]</p>
</blockquote>

<aside style="margin-top:-10rem">
<p>
On retrouve ce souci dans l&rsquo;impl√©mentation ouverte; les auteurs pr√©f√®rent une
interface d&rsquo;impl√©mentation o√π le programmeur d√©clare l&rsquo;optimisation souhait√©e
plut√¥t qu&rsquo;une qui fournit les m√©canismes pour la r√©aliser directement.
</p>
</aside>

<p>
N√©anmoins, cr√©er un langage d√©di√© pour chaque application est un co√ªt qui peut
√™tre trop √©lev√© pour adopter la programmation par aspects.  Et tous les langages
ne supportent pas les m√©canismes bas-niveau qui pourraient servir √† exprimer des
aspects.  Ce sont les raisons qui vraisemblablement motivent le d√©veloppement
d&rsquo;AspectJ [<a href="#KHH+01">KHH+01</a>].
</p>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-5">
<h5 id="orgheadline19">AspectJ: jonctions, coupes, et m√©thodes d&rsquo;aspect</h5>
<div class="outline-text-5" id="text-orgheadline19">
<blockquote>
<p>
AspectJ is intended to be a practical AOP language that provides, in a Java
compatible package, a solid and well-worked-out set of AOP features.
</p>
</blockquote>

<p>
AspectJ est un langage d&rsquo;aspect pour Java.  Dans un syst√®me par aspects, il y a
un langage d&rsquo;aspects, ici AspectJ, et un langage de composants, ici ce sera
Java.  AspectJ est un langage d&rsquo;aspect <i>g√©n√©ral</i>, qui fournit des m√©canismes de
recomposition applicables √† tout programme Java.  Et pour ce faire, AspectJ
propose deux types de recomposition.
</p>

<p>
En premier, les d√©clarations inter-types permettent de d√©finir, au sein d&rsquo;un
m√™me aspect, des attributs et des m√©thodes pour une ou plusieurs classes [<a href="#Asp-03">Asp03</a>].
Ces attributs augmentent les classes au moment de la compilation.  La classe
est, en Java, et comme dans d&rsquo;autres langages √† classe pour la programmation
objet, l&rsquo;unit√© de composition des composants.  Elle d√©crit les attributs et les
m√©thodes partag√©es par toutes ses instances; c&rsquo;est la structure statique du
programme.  Comme c&rsquo;est une unit√© de composition, une classe n&rsquo;a pas vocation √†
pouvoir affecter les attributs et m√©thodes d&rsquo;une autre classe.  Mais un aspect
est une unit√© de composition qui <i>traverse</i> la composition des composants, et
c&rsquo;est donc naturel de permettre, dans un aspect, d&rsquo;ajouter attributs et m√©thodes
√† plusieurs classes.  C&rsquo;est une recomposition de la structure statique.
</p>

<div class="org-src-container">
<label class="org-src-name">Une d√©claration inter-type qui ajoute un attribut et une m√©thode sur la classe <code>Point</code>.</label>
<pre class="src src-java"><span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">int</span> Point.<span style="font-weight: bold; font-style: italic;">x</span> = 0;
<span style="font-weight: bold;">public</span> <span style="font-weight: bold; text-decoration: underline;">int</span> Point.<span style="font-weight: bold;">getX</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">this</span>.x; }
</pre>
</div>

<p>
Le second type de recomposition d&rsquo;AspectJ permet de modifier la structure
<i>dynamique</i> du programme; de modifier le comportement du programme √†
l&rsquo;ex√©cution.  C&rsquo;est rendu possible par trois constructions:
</p>

<ul class="org-ul">
<li>les jonctions (<i>joinpoints</i>) sont des points d&rsquo;ex√©cution du programme bien
d√©finis: l&rsquo;appel d&rsquo;une m√©thode, l&rsquo;affectation d&rsquo;un attribut, la cr√©ation d&rsquo;une
instance de classe, etc.</li>
<li>les coupes (<i>pointcuts</i>) permettent de cibler un ensemble de jonctions, et
d&rsquo;en extraire de l&rsquo;information comme le nom de la m√©thode appel√©e, et ses
arguments.</li>
<li>les m√©thodes d&rsquo;aspect (<i>advice</i>) contiennent le code √† ex√©cuter lorsque le
programme atteint les jonctions d√©crites par la coupe de la m√©thode.  Une
m√©thode d&rsquo;aspect d√©crit √©galement <i>comment</i> le code doit s&rsquo;ins√©rer dans le
processus d&rsquo;ex√©cution: avant, apr√®s, ou autour de la jonction.</li>
</ul>

<p>
Le programmeur ne manipule pas les jonctions directement, mais utilise les
coupes pour les cibler dans des m√©thodes d&rsquo;aspect.  On pourra ainsi √©crire:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="font-weight: bold; text-decoration: underline;">after</span>(): <span style="font-weight: bold;">calls</span>(<span style="font-weight: bold; text-decoration: underline;">void</span> Point.<span style="font-weight: bold; font-style: italic;">setX</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>)) {
  System.out.println(<span style="font-style: italic;">"setX was called"</span>)
}
</pre>
</div>

<p>
pour d√©clencher l&rsquo;affichage sur la sortie standard apr√®s (<code>after</code>) tout appel
(<code>calls</code>) de la m√©thode <code>Point.setX(int)</code> dans le programme.
</p>

<p>
Les coupes sont des pr√©dicats, et peuvent √™tre combin√©es avec les op√©rateurs
bool√©ens <code>&amp;&amp;</code>, <code>||</code>, et <code>!</code>:
</p>

<div class="org-src-container">

<pre class="src src-java">receptions(<span style="font-weight: bold; text-decoration: underline;">void</span> Point.<span style="font-weight: bold; font-style: italic;">setX</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>))
|| receptions(<span style="font-weight: bold; text-decoration: underline;">void</span> Point.<span style="font-weight: bold; font-style: italic;">setY</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>))

calls(<span style="font-weight: bold; text-decoration: underline;">void</span> FigureElement.<span style="font-weight: bold; font-style: italic;">incrXY</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>))
&amp;&amp; !<span style="font-weight: bold;">instanceof</span>(FigureElement)
</pre>
</div>

<p>
Ce qui permet de capturer des ensembles de jonctions pertinents pour cibler une
pr√©occupation particuli√®re.  AspectJ permet d&rsquo;ailleurs de nommer les coupes pour
plus de clart√©:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="font-weight: bold; text-decoration: underline;">pointcut</span> <span style="font-weight: bold;">moves</span>():
  receptions(<span style="font-weight: bold; text-decoration: underline;">void</span> FigureElement.<span style="font-weight: bold; font-style: italic;">incrXY</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>, <span style="font-weight: bold; text-decoration: underline;">int</span>))
  || receptions(<span style="font-weight: bold; text-decoration: underline;">void</span> Point.<span style="font-weight: bold; font-style: italic;">setX</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>))
  || receptions(<span style="font-weight: bold; text-decoration: underline;">void</span> Point.<span style="font-weight: bold; font-style: italic;">setY</span>(<span style="font-weight: bold; text-decoration: underline;">int</span>));

<span style="font-weight: bold; text-decoration: underline;">after</span>(): <span style="font-weight: bold;">moves</span>() {
  ...
}
</pre>
</div>

<p>
Une coupe nomm√©e peut √™tre utilis√©e par une m√©thode d&rsquo;aspect, mais aussi par
n&rsquo;importe quelle autre coupe, ce qui encourage la composition, et r√©duit la
duplication de code.
</p>

<p>
Les jonctions expos√©es par AspectJ √©voquent fortement les r√©ifications d&rsquo;un
protocole m√©ta-objet: appel et ex√©cution de m√©thode, cr√©ation d&rsquo;une instance.
Mais il y a d&rsquo;autres coupes int√©ressantes qui sont applicables √† n&rsquo;importe quel
langage √† proc√©dures: <code>withincode(method)</code> permet de cibler n&rsquo;importe quelle
jonction qui √©mane de la m√©thode donn√©e.  C&rsquo;est particuli√®rement utile associ√© √†
d&rsquo;autres coupes:
</p>

<div class="org-src-container">

<pre class="src src-java">call(<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; font-style: italic;">m</span>()) &amp;&amp; withincode(<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; font-style: italic;">m</span>())
</pre>
</div>

<p>
L√† on capture uniquement les appels r√©cursifs directs de <code>m</code>.  Inversement, si
l&rsquo;on souhaite capturer les appels <i>non</i> r√©cursifs √† <code>m</code>, on peut utiliser
<code>cflow</code>:
</p>

<div class="org-src-container">

<pre class="src src-java">call(<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; font-style: italic;">m</span>()) &amp;&amp; !cflow(call(<span style="font-weight: bold; text-decoration: underline;">void</span> <span style="font-weight: bold; font-style: italic;">m</span>()))
</pre>
</div>

<div style="margin-top:-5rem" class="side-figure">

<figure>
<p><img src="img/aop3.svg" alt="aop3.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;14&nbsp;:</span> Les appels non r√©cursifs de <code>m</code> sont captur√©s (<span class="color c3">‚ñ¨</span>) par la coupe, et les appels r√©cursifs √©chouent le test de <code>cflow</code> (<span class="color c2">‚ñ¨</span>).</figcaption>
</figure>

</div>

<p>
<code>cflow(coupe)</code> capture toutes les jonctions qui sont dans le flot de contr√¥le de
la coupe pass√©e en argument; c&rsquo;est √† dire, ici, toutes les jonctions qui
existent apr√®s qu&rsquo;au moins un appel de <code>m</code> soit pr√©sent sur la pile d&rsquo;appels.
Dans l&rsquo;exemple, la coupe compos√©e capture les appels de <code>m</code> lorsqu&rsquo;aucun appel √†
<code>m</code> n&rsquo;existe sur la pile, ce qui exclut les appels r√©cursifs (directs et
indirects).
</p>

<p>
√Ä travers les diff√©rents types de jonctions observ√©es, le langage d&rsquo;aspect
d&rsquo;AspectJ permet de capturer de nombreux points d&rsquo;ex√©cution du programme, et
d&rsquo;ex√©cuter du code au del√† des fronti√®res d√©limit√©es par les classes et les
m√©thodes de Java.  On voit bien comment le langage permet de s√©parer les
composants des aspects, et ce pour n&rsquo;importe quelle application.  Puisqu&rsquo;ici,
contrairement au langage sp√©cifique d&rsquo;aspects du premier papier, le m√©canisme
est g√©n√©ral; il s&rsquo;applique √† n&rsquo;importe quel programme Java.
</p>

<p>
Les auteurs donnent l&rsquo;exemple d&rsquo;un aspect qui enregistre toutes les erreurs
lev√©es par toutes les m√©thodes publiques d&rsquo;un package:
</p>

<div class="org-src-container">

<pre class="src src-java"><span style="font-weight: bold; text-decoration: underline;">aspect</span> <span style="font-weight: bold; font-style: italic;">SimpleErrorLogging</span> {
  <span style="font-weight: bold; text-decoration: underline;">Log</span> <span style="font-weight: bold; font-style: italic;">log</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Log</span>();

  <span style="font-weight: bold; text-decoration: underline;">pointcut</span> <span style="font-weight: bold; font-style: italic;">publicEntries</span>():
    receptions(<span style="font-weight: bold;">public</span> * <span style="font-weight: bold; text-decoration: underline;">com</span>.<span style="font-weight: bold; text-decoration: underline;">xerox</span>.<span style="font-weight: bold; text-decoration: underline;">printers</span>.*.*(..));

  after() throwing(<span style="font-weight: bold; text-decoration: underline;">Error</span> <span style="font-weight: bold; font-style: italic;">e</span>): publicEntries() {
    log.write(e)
  }
}
</pre>
</div>

<p>
Cet aspect est √©quivalent √† rajouter enrober chaque appel dans un <code>try/catch</code> et
appeler <code>log.write</code> sur l&rsquo;erreur lev√©e.  Mais ici c&rsquo;est fait en 8 lignes, pour
toutes les classes du package, m√™me les classes futures.
</p>

<p>
Un d√©savantage du langage sp√©cifique c&rsquo;est qu&rsquo;il faut r√©√©crire le programme des
composants dans le nouveau langage √† composants.  Ici, le langage d&rsquo;aspects
manipule directement le langage √† composant d√©j√† existant: Java.  Un programmeur
peut donc directement appliquer la programmation par aspects √† un programme Java
existant, simplement en ajoutant des programmes d&rsquo;aspect, et en invoquant le
tisseur √† la compilation.  Aucune modification du programme des composants n&rsquo;est
n√©cessaire, mais pourtant ce programme va √™tre modifi√© par des aspects.  Les
d√©clarations inter-types peuvent √©tendre des classes sans modifier le code de
celles-ci.  Et les m√©thodes d&rsquo;aspect vont modifier le comportement √† l&rsquo;ex√©cution
de plusieurs classes, ici encore sans en alt√©rer le code.
</p>

<p>
La programmation par aspect nous donne donc deux fa√ßons de modifier un
programme: dans les filtres d&rsquo;images, la modification est <i>explicite</i>, car il
faut r√©√©crire les filtres pour expliciter quel type de boucle est utilis√©e; mais
dans AspectJ, le programme est modifi√© <i>implicitement</i> par les aspects.
</p>

<p>
En revanche, dans les deux cas, les programmes des composants <i>ne d√©pendent pas
des programmes d&rsquo;aspects</i> pour fonctionner.  Dans l&rsquo;exemple de l&rsquo;aspect de
journalisation des erreurs, on pourrait compiler le programme sans cet aspect
(sans tisser l&rsquo;aspect), et on obtiendrait un programme qui a les m√™mes
fonctionnalit√©s, mais sans la journalisation.  Aucune modification du code du
programme n&rsquo;est n√©cessaire pour activer ou d√©sactiver la journalisation; c&rsquo;est
uniquement le choix des aspects √† activer au moment du tissage qui d√©termine les
fonctionnalit√©s du programme final.  De m√™me, dans les filtres d&rsquo;image, ne pas
inclure les programmes d&rsquo;aspects n&rsquo;impacte que l&rsquo;efficacit√© du programme, mais
pas son r√©sultat.  On dira alors que, dans ces deux cas, les aspects sont
<i>oubliables</i> (<i>obliviousness property</i>).
</p>

<div style="margin-top:-18rem" class="side-figure">

<figure>
<p><img src="img/aop4.svg" alt="aop4.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;15&nbsp;:</span> Le programme peut √™tre compil√© avec ou sans les aspects, et engendrer deux ex√©cutables diff√©rents.</figcaption>
</figure>

</div>
</div>
</div>

<div id="outline-container-orgheadline20" class="outline-5">
<h5 id="orgheadline20">Le m√©canisme essentiel pour la programmation par aspects</h5>
<div class="outline-text-5" id="text-orgheadline20">
<p>
D&rsquo;√™tre oubliable est une propri√©t√© qui peut √™tre consid√©r√©e comme
caract√©ristique de la programmation par aspects [<a href="#FF-04">FF04</a>].  Filman et Friedman
cherchent √† identifier les syst√®mes qui suivent la programmation par aspects.
Il semble clair que lorsqu&rsquo;on utilise AspectJ, on fait de la programmation par
aspect.  Mais si on construit un syst√®me similaire √† celui des filtres d&rsquo;images,
avec un langage d√©di√© pour les filtres, est-ce que c&rsquo;est un syst√®me d&rsquo;aspects?
√Ä l&rsquo;inverse, il ne s&rsquo;agit pas de rajouter une construction √† un langage qui
permet de cr√©er des &laquo;&nbsp;aspects&nbsp;&raquo;, qui regroupent des m√©thodes, pour en faire un
langage de programmation par aspects.
</p>

<p>
Dans la publication d&rsquo;origine [<a href="#KLM+97">KLM+97</a>], le seul crit√®re de d√©finition d&rsquo;un syst√®me
par aspects est qu&rsquo;il permet d&rsquo;exprimer s√©par√©ment les composants des aspects,
des unit√©s issues de la phase de conception du syst√®me.  Mais Filman et Friedman
ne s&rsquo;int√©ressent pas tant √† la <i>m√©thodologie</i> de la programmation par aspects,
qu&rsquo;aux <i>m√©canismes</i> qui la supportent:
</p>

<blockquote>
<p>
Here we address the structural essence of AOP, not its application‚Äîsomewhat
similar to the difference between defining object-oriented programming systems
in terms of polymorphic methods and inheritance versus waxing euphoric about
objects as the appropriate way to model the world.
</p>

<p>
[&#x2026;]
</p>

<p>
Understanding something involves both understanding how it works (mechanism) and
what it&rsquo;s good for (methodology).  In computer science, we&rsquo;re rarely shy about
grandiose methodological claims (see, for example, the literature of AI or the
Internet).  But mechanism is important ‚Äì appreciating mechanisms leads to
improved mechanisms, recognition of commonalities and isomorphisms, and plain
old clarity about what&rsquo;s actually happening.
</p>

<p>
‚Äî¬†[<a href="#FF-04">FF04</a>]</p>
</blockquote>

<p>
D&rsquo;apr√®s eux, pour faire de la programmation par aspect il suffit de pouvoir
exprimer des d√©clarations de la forme:
</p>

<blockquote>
<p>
Dans les programmes P, quand la condition C est vraie, r√©aliser l&rsquo;action A.
</p>
</blockquote>

<p>
Autrement dit, il suffit de disposer d&rsquo;un <code>COMEFROM</code> [<a href="#Cla-73">Cla73</a>].  Le <code>COMEFROM</code> est
le dual du <code>GOTO</code>: un <code>GOTO 10</code> transf√®re le contr√¥le √† la ligne 10, alors qu&rsquo;un
<code>COMEFROM 10</code> <i>capture</i> le contr√¥le apr√®s l&rsquo;ex√©cution de la ligne 10.
</p>

<div style="margin-top:-3rem" class="side-figure">

<figure>
<p><img src="img/aop5.svg" alt="aop5.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;16&nbsp;:</span> <code>COMEFROM</code> est le dual de <code>GOTO</code>.</figcaption>
</figure>

</div>

<pre class="example">
10 J=1
11 COME FROM 20
12 WRITE (6,40) J STOP
13 COME FROM 10
20 J=J+2
40 FORMAT (14)
</pre>

<p>
Dans cet exemple, les lignes ex√©cut√©es sont, dans l&rsquo;ordre: 10, 13, 20, 11, 12
(<code>STOP</code> termine le programme).  On voit tout de suite qu&rsquo;un <code>COMEFROM</code> rend le
code encore plus difficile √† suivre qu&rsquo;un <code>GOTO</code>.  C&rsquo;est bien l&rsquo;intention de son
auteur, qui voit le d√©bat autour du <code>GOTO</code> avec humour:
</p>

<blockquote>
<p>
Nearly six years after publication of Dijkstra&rsquo;s now-famous letter, the subject
of GOTO-less programming still stirs considerable controversy.
</p>

<p>
The author has developed a new language construct on which, he believes, both
the pro- and the anti-GOTO factions can agree.
</p>
</blockquote>

<p>
Le <code>COMEFROM</code> est donc une plaisanterie √©labor√©e, qui n&rsquo;a a priori rien √† voir
avec la programmation par aspects.  Mais on s&rsquo;int√©resse ici aux m√©canismes, et
le m√©canisme du <code>COMEFROM</code> ‚Äî la possibilit√© de capturer le contr√¥le ‚Äî est
l&rsquo;essence des jonctions et des coupes propos√©es par AspectJ.
</p>

<p>
Bien s√ªr, le <code>COMEFROM</code> d√©crit par Clark ne permet de venir que d&rsquo;une autre
ligne du programme, alors qu&rsquo;AspectJ permet de capturer le contr√¥le lors
d&rsquo;appels de m√©thodes, la lecture ou l&rsquo;affectation d&rsquo;une variable.  Mais en
r√©alit√©, le <code>COMEFROM</code> de Clark est adapt√© √† la granularit√© offerte par le
langage: la ligne.  Dans AspectJ, l&rsquo;unit√© de composition est la m√©thode, et la
classe.  Un <code>COMEFROM</code> pour Java pourrait ressembler √† ce qu&rsquo;AspectJ offre √†
travers le langage des coupes de jonctions.
</p>

<p>
En ne prenant en compte que le m√©canisme, on peut d√©terminer si d&rsquo;autres
syst√®mes ou langages, qui ne sont pas pr√©sent√©s comme des syst√®mes d&rsquo;aspects,
permettent tout de m√™me de faire de la programmation par aspects.  En
particulier, les syst√®mes √† √©v√©nements peuvent √™tre vus comme √©quivalents √† un
<code>COMEFROM</code>; si les composants ne communiquent qu&rsquo;√† travers des √©v√©nements, on
peut √©crire des aspects qui capturent ces √©v√©nements, sans impacter le reste du
syst√®me (les aspects sont oubliables): il s&rsquo;agit simplement de souscrire √† ces
√©v√©nements.  Un syst√®me √† √©v√©nements fournit donc un m√©canisme qui peut √™tre
utilis√© pour faire de la programmation par aspects.
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-5">
<h5 id="orgheadline21">Les limites de la programmation par aspects</h5>
<div class="outline-text-5" id="text-orgheadline21">
<p>
Le but de la programmation par aspects est louable: distinguer les composants
des aspects dans le programme, c&rsquo;est mettre de l&rsquo;ordre, c&rsquo;est s√©parer les choses
diff√©rentes, et regrouper les fonctionnalit√©s similaires.  Le b√©n√©fice, c&rsquo;est
qu&rsquo;un code source ordonn√© est, a priori, plus simple, et donc plus facile √†
maintenir.  Mais il y a aussi des inconv√©nients √† faire cette distinction
[<a href="#Ste-06">Ste06</a>].
</p>

<p>
Le fait que les aspects capturent l&rsquo;ex√©cution de fa√ßon implicite nuit √† la
compr√©hension modulaire du programme.  On ne peut plus raisonner sur le
comportement d&rsquo;un module seulement en regardant son code, il faut prendre en
compte tous les aspects qui peuvent intervenir pendant l&rsquo;ex√©cution du code du
module.  La compr√©hension du programme devient n√©cessairement globale: il faut
conna√Ætre tous les aspects qui peuvent s&rsquo;y appliquer, et en prenant en compte
les aspects qui pourraient √™tre activ√©s dynamiquement.
</p>

<p>
Une fa√ßon de mitiger ce probl√®me est de faire appara√Ætre, dans l&rsquo;environnement
de d√©veloppement du programmeur, les endroits du code o√π des aspects pourraient
s&rsquo;ex√©cuter; l&rsquo;article qui introduit AspectJ montre une telle fonctionnalit√© dans
Emacs.  Les aspects deviennent explicites, mais l&rsquo;int√©grit√© du module demeure
compromise.  Le syst√®me n√©cessite toujours une analyse globale pour √™tre
compris, et les aspects traversent encore la barri√®re du module, ce qui emp√™che
de d√©velopper le module ind√©pendamment des aspects.
</p>

<p>
Les aspects capturent les points d&rsquo;ex√©cution du module, ce qui revient √† dire
que tout module expose une interface <i>implicite</i> qui est utilis√©e par les
aspects.  Que cette interface soit implicite rend les aspects fragiles: tout
changement du code peut rendre des aspects inop√©rables.  Mais c&rsquo;est aussi le
fait qu&rsquo;elle soit implicite qui permet aux aspects d&rsquo;√™tre oubliables, et donc de
pouvoir s&rsquo;appliquer √† plusieurs points d&rsquo;ex√©cution sans avoir √† modifier le code
des composants.  L&rsquo;interface implicite est donc un choix de conception du
syst√®me, √† adopter si le besoin de modifier plusieurs modules en un seul lieu
(dans un aspect) surpasse le besoin de comprendre et d√©velopper les modules
ind√©pendamment.
</p>

<hr >

<p>
La contribution principale de la programmation par aspects est de distinguer
deux types de programmes qui cohabitent dans un m√™me syst√®me: les composants, en
charge de la fonctionnalit√© du syst√®me, et les aspects, qui d√©crivent des
pr√©occupations orthogonales √† la fonctionnalit√© principale.  La programmation
par aspects est donc avant tout une m√©thodologie.
</p>

<p>
Le langage des jonctions et des coupes, popularis√© par AspectJ, est le m√©canisme
principalement associ√© √† la programmation par aspects.  Mais il y d&rsquo;autres
fa√ßons de r√©aliser la s√©paration des composants et des aspects: on peut utiliser
la programmation √©v√©nementielle, les <code>try/catch</code>, les variables √† port√©e
dynamique, ou cr√©er un langage d√©di√© pour les composants et un pour les aspects.
Dans le monde de la programmation fonctionnelle, les monades sont aussi un moyen
de s√©parer les pr√©occupations orthogonales [<a href="#Meu-97">Meu97</a>,<a href="#HO-07">HO07</a>].
</p>

<p>
Il ne faut donc pas m√©langer la m√©thodologie‚Äîle but philosophique de la
programmation par aspects‚Äîet les (multiples) m√©canismes qui permettent
d&rsquo;atteindre ce but.  En particulier, on peut faire de la programmation par
aspects sans AspectJ, sans jonctions, sans coupes, et sans m√©thodes d&rsquo;aspects.
</p>

<p>
Enfin, la programmation par aspects n&rsquo;est pas une balle en argent.  Les
jonctions et les coupes sont oubliables par les composants, mais sacrifient le
raisonnement modulaire.  Les autres m√©canismes qui permettent de s√©parer les
composants des aspects ont √©galement cette caract√©ristique: recomposer le flot
d&rsquo;ex√©cution dynamiquement rend le programme moins pr√©visible, et moins
compr√©hensible.  Tous ces m√©canismes pr√©sentent donc des avantages et des
inconv√©nients, et le choix du bon compromis est dans les mains du concepteur du
syst√®me.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28"><span class="section-number-3">2.5</span> Tisser les facettes d&rsquo;un artefact d&rsquo;innombrable dimensions</h3>
<div class="outline-text-3" id="text-2-5">

<figure>
<p><img src="img/rug.jpg" alt="rug.jpg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;17&nbsp;:</span> Tapis turc &laquo;&nbsp;Holbein&nbsp;&raquo;, fin du XVe si√®cle.</figcaption>
</figure>
</div>

<div id="outline-container-orgheadline25" class="outline-4">
<h4 id="orgheadline25"><span class="section-number-4">2.5.1</span> <span class="todo TRANSLATE">TRANSLATE</span> Literate programming</h4>
<div class="outline-text-4" id="text-2-5-1">
<p>
Programs are constructed as they are explained.  Knuth, LiterateCoffee, Org
mode.
</p>

<p>
[<a href="#Knu-84">Knu84</a>] for the original notion:
</p>

<blockquote>
<p>
Instead of imagining that our main task is to instruct a <i>computer</i> what to do,
let us concentrate rather on explaining to <i>human beings</i> what we want to do.
</p>
</blockquote>

<p>
As usual, Knuth writing is delightfully witty:
</p>

<blockquote>
<p>
I must confess that there may also be a bit of malice in my choice of a title.
During the 1970s I was coerced like everybody else into adopting the ideas of
structured programming, because I couldn&rsquo;t bear to be found guilty of writing
<i>unstructured</i> programs.  Now I have a chance to get even.  By coining the
phrase &laquo;&nbsp;literate programming,&nbsp;&raquo; I am imposing a moral commitment on everyone who
hears the term; surely nobody wants to admit writing an <i>illiterate</i> program.
</p>
</blockquote>

<p>
The WEB system allows one to write a TeX + source code document, and then
produce documentation (using the WEAVE program) or complete program (using
TANGLE).  The focus is on documenting first what the program does, then
producing a machine version as a second concern.  The source code can be
presented out-of-order in the document, for expository purposes, using links and
macros.
</p>

<p>
The WEB way of writing programs is &laquo;&nbsp;psychologically correct&nbsp;&raquo;, as it reflects the
way in which the program was conceived and elaborated.
</p>

<blockquote>
<p>
When I first began to work with the ideas that eventually became the WEB system,
I thought that I would be designing a language for &laquo;&nbsp;top-down&nbsp;&raquo; programming, where
a top-level description is given first and successively refined.  On the other
hand I knew that I often created major parts of programs in a &laquo;&nbsp;bottom-up&nbsp;&raquo;
fashion, starting with the definitions of basic procedures and data structures
and gradually building more and more powerful routines.  I had the feeling that
top-down and bottom-up were opposing methodologies: one more suitable for
program exposition and the other more suitable for program creation.
</p>

<p>
[&#x2026;] I have come to realize that there is no need to choose once and for all
between top-down and bottom-up, because a program is best thought of as a web
instead of a tree.  [&#x2026;] A complex piece of software consists of simple parts
and simple relations between those parts; the programmer&rsquo;s task is to state
those parts and those relationships, in whatever order is best for human
comprehension ‚Äì not in some rigidly determined order like top-down or
bottom-up.
</p>

<p>
[&#x2026;]
</p>

<p>
Thus the  WEB language allows a person to express programs in a &laquo;&nbsp;stream of
consciousness&nbsp;&raquo; order.
</p>
</blockquote>

<p>
An unexpected benefit of WEB is a better separation of concerns.  Although Knuth
does not use the term, each part of a program can be described in its own
section, thus each section can focus on one concern.  He gives the example of
separating error recovery from a simple data structure update routine.
</p>

<blockquote>
<p>
While writing the program for [error recovery], a programmer subconsciously
tries to get by with the fewest possible lines of code, since the program for
[updating the structure] is quite short.  If an extensive error recovery is
actually programmed, the subroutine will appear to have error-messages printing
as its main purpose.  But the programmer knows that the error is really an
exceptional case that arises only rarely; therefore a lengthy error recovery
doesn&rsquo;t look right, and most programmers will minimize it [&#x2026;] in order to make
the subroutine&rsquo;s appearance match its intended behavior.  [Programming] with
WEB, the purpose of <code>update</code> can be be shown quite clearly, and the possibility
of error recovery can be reduce to a mere mention when <code>update</code> is defined.
When another section [related to error recovery] is subsequently written, the
whole point of that section is to do the best error recovery, and it becomes
quite natural to write a better program.
</p>
</blockquote>

<p>
Knuth notes that the target programming language can impact the writing of WEB
programs.  Having to declare variables at the start of a program leads to
appending to the same &laquo;&nbsp;Local variables&nbsp;&raquo; program section.
</p>

<p>
Taking the time to document the code as you write it is not free, but is
beneficial in the long run.
</p>

<blockquote>
<p>
I had known for a long time that the programs I construct for publication in a
book, or the programs that I construct in front of a class, have tended to be
comparatively free of errors, because I am forced to clarify my thoughts as I do
the programming.  By contrast, when writing for myself alone, I have often taken
shortcuts that proved later to be dreadful mistakes.  It&rsquo;s harder for me to fool
myself in such ways when I&rsquo;m writing a WEB program, because I&rsquo;m in &laquo;&nbsp;expository
mode&nbsp;&raquo; (analogous to classroom lecturing) whenever a WEB is being spun.  Ergo,
less debugging time.
</p>
</blockquote>

<blockquote>
<p>
WEB may be only for the subset of computer scientists who like to write and to
explain what they are doing.
</p>
</blockquote>

<p>
Noweb is a language-agnostic syntax and implementation of WEB, which is used in
Org-mode.
</p>
</div>

<div id="outline-container-orgheadline24" class="outline-5">
<h5 id="orgheadline24">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline24">
<p>
The idea of documenting as you program is important, as is the focus on writing
&laquo;&nbsp;what the human meant to do&nbsp;&raquo;.
</p>

<p>
The mechanisms of including and referencing code snippets allows one to
structure the program as they see fit.  Especially, it allows to separate
concerns through quantification.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline26" class="outline-4">
<h4 id="orgheadline26"><span class="section-number-4">2.5.2</span> <span class="done STABLE">STABLE</span> Hyper/J</h4>
<div class="outline-text-4" id="text-2-5-2">
<p>
La programmation par aspects a pour but la s√©paration des composants et des
aspects.  C&rsquo;est √† dire, la s√©paration de <i>certaines</i> pr√©occupations: les
pr√©occupations transversales, orthogonales √† la fonctionnalit√© du code.  En
programmation par aspects, on a deux axes de composition du programme: l&rsquo;axe
des composants, pour la fonctionnalit√© principale, et l&rsquo;axe des aspects, pour
les fonctionnalit√©s transversales.  L&rsquo;axe des aspects est toujours inf√©rieur √†
l&rsquo;axe des composants: ce dernier est l&rsquo;axe dominant, qui impose la structure du
programme, ce qui peut limiter les choix de composition du programme.  D&rsquo;autres
recompositions sont possibles, comme celle propos√©e par Hyper/J [<a href="#TOH+99">TOH+99</a>,<a href="#TO-00">TO00</a>].
</p>

<p>
Hyper/J est une impl√©mentation de la s√©paration pluridimensionnelle des
pr√©occupations (<i>s√©plution</i>) pour Java, tout comme AspectJ est une
impl√©mentation de la programmation par aspects pour Java.  La s√©plution est un
paradigme qui permet la recomposition des pr√©occupations selon plusieurs axes,
et de fa√ßon sym√©trique, contrairement √† la programmation par aspects.
</p>

<p>
Dans [<a href="#TOH+99">TOH+99</a>], les auteurs motivent la s√©plution avec l&rsquo;exemple d&rsquo;un syst√®me qui
permet de construire des programmes dans un langage simple, une instance du
probl√®me de l&rsquo;expression.  Le syst√®me permet de cr√©er des expressions
arithm√©tiques, qui sont des additions ou des soustractions de sous-expressions,
soit des nombres.
</p>

<p>
Pour impl√©menter ce syst√®me, ils proposent de repr√©senter chaque n≈ìud de l&rsquo;arbre
syntaxique par une classe: une classe <code>Expression</code>, une classe <code>Number</code>, une
classe <code>Plus</code>, etc.  Chaque classe impl√©mente trois m√©thodes, qui correspondent
√† trois traitements diff√©rents de l&rsquo;arbre syntaxique: <code>eval</code> √©value la valeur
arithm√©tique de l&rsquo;expression, <code>display</code> affiche l&rsquo;expression, et <code>check</code> v√©rifie
qui l&rsquo;expression est bien form√©e.
</p>

<div class="side-figure">

<figure>
<p><img src="img/hyperj1.svg" alt="hyperj1.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;18&nbsp;:</span> Les trois traitements communs √† chaque n≈ìud de l&rsquo;arbre de syntaxe sont trois pr√©occupations diff√©rentes, √©parpill√©es dans chaque classe.  L&rsquo;unit√© d&rsquo;abstraction, la classe, ne correspond pas √† l&rsquo;unit√© des traitements.</figcaption>
</figure>

</div>

<p>
Imm√©diatement, ils constatent que chaque traitement peut √™tre consid√©r√© comme
une pr√©occupation, et que selon cette d√©composition en classes, ces
pr√©occupations sont toutes √©parpill√©es dans les m√©thodes correspondantes des
diff√©rentes classes.  Il n&rsquo;y a pas de vue centralis√©e d&rsquo;une pr√©occupation.
</p>

<p>
Cet √©parpillement est un probl√®me lorsqu&rsquo;ils cherchent √† √©tendre la
fonctionnalit√© du syst√®me.  Modifier une fonctionnalit√© n√©cessite de toucher √†
une m√©thode dans diff√©rentes classes.  Ajouter la synchronisation des expressions
dans une base de donn√©e requiert d&rsquo;ajouter des appels dans les constructeurs et
accesseurs de chaque classe.  Les modifications ont un impact √©lev√© sur
l&rsquo;impl√©mentation, que les auteurs souhaitent minimiser:
</p>

<blockquote>
<p>
The goal of low impact of changes requires <i>additive</i>, rather than <i>invasive</i>,
change.  Yet conceptually simple changes, like those in the expression system,
often have widespread and invasive effects, both within the modified artifact
and on related pieces of other artifacts.  This is primarily because units of
change often do not match the units of abstraction and encapsulation within the
artifcats.  Thus, additive changes in one artifact, like requirements, may not
translate to additive changes in other artifacts, like design and code.
</p>
</blockquote>

<p>
La s√©plution doit donc permettre de modifier le syst√®me sans avoir √† modifier sa
structure en profondeur.  Une nouvelle fonctionnalit√© devrait se traduire par un
ajout de code, et pas par de la modification de code existant.  Et pour r√©aliser
ce but, l&rsquo;exemple du probl√®me de l&rsquo;expression montre que les unit√©s
d&rsquo;abstraction classiques sont insuffisantes; elles imposent toutes une dimension
de composition.  Et m√™me si elles permettent plusieurs dimensions de
composition, comme la programmation par aspects, il y a toujours une dimension
qui prime sur l&rsquo;autre.  C&rsquo;est un constat qu&rsquo;ils nomment la &laquo;&nbsp;tyrannie de la
d√©composition dominante&nbsp;&raquo;.
</p>

<p>
Pour rem√©dier √† cette tyranie, ils proposent l&rsquo;<i>hypercoupe</i>: une fa√ßon de
regrouper tous les artefacts du syst√®me qui touchent √† une m√™me pr√©occupation.
Une hypercoupe contient le code source, la description informelle de la
fonctionnalit√©, sa sp√©cification, son design, sa documentation, etc.
</p>

<p>
Continuant l&rsquo;exemple, on peut regrouper les fonctionnalit√©s d&rsquo;√©valuation,
d&rsquo;affichage, de v√©rification et de synchronisation par des hypercoupes
diff√©rentes.  Le papier illustre √† travers des diagrammes UML ce qu&rsquo;Hyper/J
permet de faire en Java.
</p>

<div style="margin-top:-10rem" class="side-figure">

<figure>
<p><img src="img/hyperj2.svg" alt="hyperj2.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;19&nbsp;:</span> Recomposition en utilisant des hypercoupes pour chaque traitement. Les trois traitements sont isol√©s par chaque hypercoupe, mais les classes sont communes √† toutes.</figcaption>
</figure>

</div>

<p>
Une hypercoupe n&rsquo;isole pas n√©cessairement une partie du syst√®me.  Les unit√©s
d&rsquo;abstraction que sont les classes et m√©thodes peuvent appara√Ætre dans plusieurs
hypercoupes.  C&rsquo;est le cas ici: la classe <code>Expression</code> appara√Æt dans toutes les
hypercoupes.  Les hypercoupes sont des organisations, des vues diff√©rentes du
m√™me syst√®me, et certaines parties du syst√®mes sont pertinentes pour plusieurs
vues.
</p>

<p>
Une fois les hypercoupes d√©finies, il faut √©galement d√©crire comment elles se
composent pour former le syst√®me final: comment composer la documentation pour
produire un document unique, et comment composer le code pour produire un
ex√©cutable.  Cette composition d√©pend √©videmment des artefacts consid√©r√©s.
</p>

<p>
En Hyper/J, la composition du code source se fait sur le nom de classe ou de
m√©thodes: deux classes ayant le m√™me nom dans deux hypercoupes diff√©rentes
combineront leur contenu, et r√©cursivement pour leurs m√©thodes.  Pour les
m√©thodes, on peut aussi sp√©cifier qu&rsquo;il faut surcharger la m√©thode de m√™me nom
de l&rsquo;hypercoupe pr√©c√©dente, sans pour autant utiliser l&rsquo;h√©ritage de classe.
</p>

<hr >

<p>
La s√©plution a pour but de minimiser les modifications √† apporter au code source
lorsqu&rsquo;une nouvelle fonctionnalit√© est impl√©ment√©e, et d&rsquo;abolir l&rsquo;asym√©trie de
la d√©composition dominante.  L&rsquo;id√©e importante de la s√©plution est de
reconna√Ætre qu&rsquo;une pr√©occupation a plusieurs dimensions dans le programme, et
n&rsquo;appara√Æt pas seulement dans le code source.  Les hypercoupes sont des
projections de cet objet pluridimensionnel qui regroupent tous les artefacts
relatifs √† une pr√©occupation: le code source, mais aussi les documents de
conception.  La s√©plution est donc une m√©thodologie de d√©veloppement, du design
√† l&rsquo;impl√©mentation, dont les unit√©s d&rsquo;abstraction sont les fonctionnalit√©s du
syst√®me.
</p>

<aside style="margin-top:-6rem">
<p>
Une m√©thodologie qui est proche des domaines de la programmation par
fonctionnalit√© (<i>Feature-Oriented Programming</i>) et de l&rsquo;ing√©nierie des mod√®les
(<i>Model-Driven Engineering</i>).  Domaines qui sont ne sont pas les objets de ce
document.
</p>
</aside>

<p>
Hyper/J est une impl√©mentation de la s√©plution pour Java.  Un programmeur √©crit
des hypercoupes, et pr√©cise leur composition avant de les passer au compilateur,
qui g√©n√®re du bytecode Java.  Le m√©canisme de composition est une instance de
<i>superimposition</i>.
</p>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-4">
<h4 id="orgheadline27"><span class="section-number-4">2.5.3</span> <span class="todo BARE">BARE</span> Information transparency</h4>
<div class="outline-text-4" id="text-2-5-3">
<p>
[<a href="#Gri-01">Gri01</a>]</p>

<p>
Tools for capturing the similarity of code across modules.  Tangled code should
be similar, according to the principle of consistency.  Hence, capturing similar
code should help gather and organize concerns.  E.g., changing the behavior of
the parsing of a <code>while</code> statement by grepping for ‚Äòwhile&rsquo; in the source.
</p>

<p>
Principle of consistency:
</p>

<blockquote>
<p>
Things that look similar should <i>be</i> similar; things that <i>are</i> different should
look different.
</p>
</blockquote>
<p>
[<a href="#Mac-87">Mac87</a>]</p>

<p>
First principle of information transparency:
</p>

<blockquote>
<p>
Code elements likely to be changed together as part of a complete, consistent
change should look similar, and code elements unlikely to be changed together
should look different.
</p>
</blockquote>

<p>
If a code base obeys this principle, it can be easily refactored using standard
tools like grep.
</p>

<p>
A second principle promotes using variable names to indicate implementation
choices.  Hungarian notation is given as an example.
</p>

<blockquote>
<p>
The unmodularized code elements relating to a changeable design decision should
contain recognizable tags uniquely identifying the design decision.
</p>
</blockquote>

<p>
Locality can be managed by tools.  They exhibit tools a bit more powerful than
grep, with knowledge of the target language AST, or matching on typos.
</p>

<blockquote>
<p>
Both tools [Aspect Browser and Seesoft] embody the concept that, by leveraging
the human visual system, identifiable <i>symbols</i> are a viable alternative to
<i>locality</i> as a way of managing changes to software.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29"><span class="section-number-3">2.6</span> <span class="todo BARE">BARE</span> Limiter les effets de bord: La programmation fonctionnelle</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Parallel evolution to OO.
</p>

<p>
Pure functions, immutability, side-step the complications of side-effects
entirely.
</p>

<p>
Functional is simple, because referential transparency.
</p>

<p>
Real programs need side effects, they are delimited by monads, effect systems.
</p>

<p>
Functional languages historically have the more advanced type systems.  Strong
static guarantes, but less runtime flexibility.
</p>
</div>
</div>

<div id="outline-container-orgheadline35" class="outline-3">
<h3 id="orgheadline35"><span class="section-number-3">2.7</span> La modularit√© du programme n&rsquo;est pas la modularit√© du code source</h3>
<div class="outline-text-3" id="text-2-7">
</div><div id="outline-container-orgheadline31" class="outline-4">
<h4 id="orgheadline31"><span class="section-number-4">2.7.1</span> <span class="done STABLE">STABLE</span> La modularit√© selon Parnas</h4>
<div class="outline-text-4" id="text-2-7-1">
<p>
David Parnas est fr√©quemment cit√© comme r√©f√©rence pour la notion de modularit√©
d&rsquo;un syst√®me, en particulier l&rsquo;article &laquo;&nbsp;On the Critera to be Used In Decomposing
Systems into Modules&nbsp;&raquo; [<a href="#Par-72">Par72</a>].  Mais Parnas s&rsquo;int√©resse davantage √† la phase de
<i>conception</i> d&rsquo;un syst√®me qu&rsquo;√† la phase d&rsquo;impl√©mentation.
</p>

<p>
Dans l&rsquo;article, il d√©crit deux d√©compositions en modules d&rsquo;un m√™me syst√®me
d&rsquo;indexation ; un exemple didactique qui peut √™tre impl√©ment√© &laquo;&nbsp;par un bon
programmeur en une ou deux semaines&nbsp;&raquo;.  La premi√®re d√©composition comporte 5
modules, la seconde 6.  Les deux d√©compositions sont suppos√©es produire des
programmes √©quivalents: qui fournissent les m√™me fonctionnalit√©s.  Mais si les
deux programmes sont √©quivalents, quel int√©r√™t √† choisir une d√©composition
plut√¥t qu&rsquo;une autre?  La r√©ponse vient en s&rsquo;int√©ressant aux choix
d&rsquo;impl√©mentation qui ont √©t√© laiss√©s en suspens.
</p>

<p>
Suivant le format d&rsquo;entr√©e des donn√©es, ou l&rsquo;emplacement m√©moire de sauvegarde
des donn√©es, il faudra modifier certaines parties du programme en cons√©quence.
Et c&rsquo;est l√† que les deux designs ne sont plus √©quivalents: le second changement
touche tous les modules de la premi√®re d√©composition, alors que les changements
sont restreints √† un seul module dans la seconde d√©composition.  Le second
design est donc mieux adapt√© aux changements potentiels anticip√©s par le
concepteur.
</p>

<div style="margin-top:-11rem" class="side-figure">

<figure>
<p><img src="img/parnas-0.svg" alt="parnas-0.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;20&nbsp;:</span> Dans le second design, les changements sont restreints √† un seul module.</figcaption>
</figure>

</div>

<div style="margin-top:5rem" class="side-figure">

<figure>
<p><img src="img/flowchart.svg" alt="flowchart.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;21&nbsp;:</span> Un logigramme.  Une fa√ßon courante de concevoir des programmes de 1950 √† 1970.</figcaption>
</figure>

</div>

<p>
Le second design est aussi plus facile √† d√©velopper et plus facile √† comprendre.
Les modules du premier design correspondent aux √©tapes de traitement du syst√®me:
Parnas nous dit qu&rsquo;il suffit de dessiner le logigramme pour obtenir les 5
modules.  Le r√©sultat c&rsquo;est que tous ces modules ont de nombreuses d√©pendances
entre eux, ce qui pousse les programmeurs √† avoir une compr√©hension globale du
syst√®me pour pouvoir le d√©velopper.  En revanche, il a √©labor√© le second design
en suivant le principe <i>d&rsquo;encapsulation</i>: les modules ne correspondent plus √†
des √©tapes de traitement, mais plut√¥t √† des d√©cisions de design, des
responsabilit√©s:
</p>

<blockquote>
<p>
Every module in the second decomposition is characterized by its knowledge of a
design decision which it hides from all others.  Its interface or definition was
chosen to reveal as little as possible about its inner workings.
</p>
</blockquote>

<aside style="margin-top:-1rem">
<p>
Dans le m√™me article, Parnas conseille aussi de mettre dans un m√™me module une
structure de donn√©es et ses proc√©dures d&rsquo;acc√®s et de modification.  Une notion
de type abstrait de donn√©e qu&rsquo;il ne nomme pas comme telle.
</p>
</aside>

<p>
Si l&rsquo;on suit ce crit√®re pour d√©composer un syst√®me en modules, alors on peut
qualifier le syst√®me de <i>modulaire</i>.  Parnas liste les trois avantages attendus
d&rsquo;un syst√®me modulaire:
</p>

<blockquote>
<p>
(1) managerial‚Äîdevelopment time should be shortened because separate groups
would work on each module with little need for communication: (2) product
flexibility‚Äîit should be possible to make drastic changes to one module without
a need to change others; (3) comprehensibility‚Äîit should be possible to study
the system one module at a time.
</p>
</blockquote>

<p>
Le premier design a beau comporter des modules, il n&rsquo;a pas ces avantages.  Il
n&rsquo;est donc pas modulaire.  Sur un second exemple de syst√®me, un compilateur et
interpr√©teur pour le m√™me langage, il conclut l√† encore qu&rsquo;une d√©composition
suivant le crit√®re d&rsquo;encapsulation est sup√©rieure √† une d√©composition qui suit
les √©tapes de traitement.  Un interpr√©teur et un compilateur r√©solvent en partie
les m√™mes probl√®mes, et la d√©composition pr√©conis√©e par Parnas permet de
<i>r√©utiliser</i> les modules d&rsquo;un syst√®me √† l&rsquo;autre.
</p>

<div class="side-figure">

<figure>
<p><img src="img/parnas-overhead.svg" alt="parnas-overhead.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;22&nbsp;:</span> L&rsquo;encapsulation cause de l&rsquo;indirection, ce qui peut r√©duire l&rsquo;efficacit√© du programme en augmentant les appels de proc√©dures sur la pile.</figcaption>
</figure>

</div>

<p>
N√©anmoins, il y a un obstacle √† utiliser une d√©composition dont les modules
adh√®rent strictement √† l&rsquo;encapsulation: l&rsquo;efficacit√© du syst√®me.  Dans une telle
d√©composition, les appels de proc√©dures sont plus nombreux et comportent
davantage d&rsquo;instructions.  L√† o√π le design qui suit le logigramme peut acc√©der
directement √† la m√©moire pour modifier les donn√©es utilis√©es par un autre
module, dans la d√©composition suivant Parnas chaque module est responsable de
ses propres donn√©es; il faut forc√©ment passer par les proc√©dures d&rsquo;acc√®s et de
modification du module.  Ces proc√©dures peuvent en plus effectuer des
v√©rifications sur leurs param√®tres, qui ne sont peut-√™tre pas n√©cessaires dans
tous les cas, ce qui rajoute encore des instructions que la machine devra
effectuer.
</p>

<p>
Parnas reconna√Æt ce probl√®me d&rsquo;efficacit√©, et sugg√®re de concevoir un outil qui
transforme le code de la d√©composition modulaire en code qui suit davantage le
fil d&rsquo;ex√©cution.  Le concepteur peut travailler sur la repr√©sentation modulaire,
et l&rsquo;outil se charge de g√©n√©rer du code efficace.  Dans le code g√©n√©r√© par cet
outil, les appels de proc√©dures inutiles sont supprim√©s, et l&rsquo;efficacit√© n&rsquo;est
pas sacrifi√©e.  En revanche, la d√©composition modulaire ne serait plus
apparente.  Il propose donc de conserver le programme sous ses plusieurs formes
et de d√©velopper des outils pour passer d&rsquo;une forme √† l&rsquo;autre.
</p>

<aside style="margin-top:-8rem">
<p>
Ce ne sont que des suggestions, et l&rsquo;article ne dit pas comment r√©aliser ces
transformations.  On trouve des mises en ≈ìuvre de ces id√©es dans le Literate
Programming de Knuth, et dans l&rsquo;AOP de Xerox.
</p>
</aside>

<p>
Parnas met donc en avant le crit√®re d&rsquo;encapsulation pour concevoir un syst√®me
modulaire.  Mais surtout, il insiste sur l&rsquo;importance de la phase de conception
du syst√®me, ind√©pendamment de son impl√©mentation en code.  Parnas ne croit
d&rsquo;ailleurs pas que le choix du langage de programmation puisse rendre un syst√®me
modulaire.  Un point qu&rsquo;il d√©veloppe dans &laquo;&nbsp;Why Software Jewels are Rare&nbsp;&raquo; [<a href="#Par-96">Par96</a>].
</p>

<p>
Un &laquo;&nbsp;logiciel joyau&nbsp;&raquo; est un programme &laquo;&nbsp;bien structur√© √©crit dans un style
homog√®ne, sans bidouilles, d√©velopp√© tel que chaque composant est simple et
organis√©, et con√ßu pour que le produit soit facile √† changer&nbsp;&raquo;.  Parnas donne
plusieurs raisons qui explique, selon lui, la raret√© de ces joyaux: le logiciel
existe pour r√©pondre √† un besoin, et la structure interne du programme n&rsquo;est pas
un besoin du client; un logiciel est plus utile √† l&rsquo;utilisateur s&rsquo;il r√©pond √†
plusieurs besoins, ce qui implique d&rsquo;enrichir ses fonctionnalit√©s, au d√©triment
de la simplicit√© du programme.  Les contraintes mat√©rielles ne laissent que peu
de place √† l&rsquo;√©l√©gance structurelle du code.  Parnas rapporte notamment son √©chec
√† vouloir mettre √† jour un syst√®me d&rsquo;ordinateur de vol pour l&rsquo;arm√©e am√©ricaine;
la machine cibl√©e poss√©dait un mat√©riel tr√®s limit√© qui demandait une
optimisation manuelle de l&rsquo;utilisation des registres, mais Parnas et son √©quipe
d√©siraient s&rsquo;abstraire de ces d√©tails mat√©riels:
</p>

<blockquote>
<p>
Near-optimal register allocation was essential to fitting the program into a
very small memory.  One of our design goals had been to achieve hardware
independence for most of our code.  To achieve hardware independence on the
specified processor, we needed an effective register allocation algorithm.  The
previous software for this task had been sucessful because none of the code was
portable and register allocation was done by hand.  We never found the necessary
register allocation algorithm.
</p>
</blockquote>

<p>
Et contrairement √† ce que l&rsquo;on pourrait penser, la loi de Moore ne r√©sout pas le
probl√®me.  Si les machines poss√®dent deux fois plus de registres et sont deux
fois plus rapides, alors on leur demandera de faire deux fois plus de calculs
(ou de les faire deux fois plus rapidement).  Parnas le note:
</p>

<aside style="margin-top:-5rem">
<p>
Ph√©nom√®ne relat√© avec humour par Wirth [<a href="#Wir-95">Wir95</a>]: &laquo;&nbsp;Software expands to fill the
available memory&nbsp;&raquo;; &laquo;&nbsp;Software is getting slower more rapidly than hardware
becomes faster&nbsp;&raquo;.
</p>
</aside>

<blockquote>
<p>
Although today&rsquo;s machines are far better than the one we were using, goals have
expanded and competitive pressures often limit the resources available.  Few of
today&rsquo;s designers are free to ignore performance requirements and hardware
limitations.
</p>
</blockquote>

<p>
Mais surtout, il faut se m√©fier des marchands de panac√©e:
</p>

<blockquote>
<p>
Sometimes new languages are used in the design of jewels, and authors may
attribute a product&rsquo;s success to the use of a particular language or type of
language.  Here, I have grave doubts.  I have lost count of the number of
languages that have been introduced to me as the solution to the software
problems that everyone experiences.  First, I was told to use Fortran instead of
an assembler language.  Later, others advocated Algol-60 and its derivatives as
the cure to the ugly software resulting from Fortran.  Of course, NPL, later
known as PL/I, was going to provide an even better solution.  The list goes on.
Wirth promotes Oberon while hundreds of people are telling me that an
object-oriented language must be used to get clean software.  I no longer
believe such claims.  The issue is design, not programming language.
</p>

<p>
[&#x2026;]
</p>

<p>
We should not ignore the fact that most modern languages have inherent
disadvantages.  A language that supports certain approach to software design
often compels us to use a particular implementation of a design principle, one
that may be inappropriate for the task at hand.  For example, many languages
that support modules, abstract data types, and object classes require the use of
subroutines where macro expansion might be a better choice.  Moreover, languages
that prevent programming errors, a goal advanced by some inveterate language
designers, are as feasible as knives that can cut meat but not hands.  We need
sharp tools to do good work.
</p>
</blockquote>

<p>
Un langage de programmation est un outil parmi d&rsquo;autres, et aucun outil ne peut
r√©soudre tous les probl√®mes.  C&rsquo;est au concepteur de choisir l&rsquo;outil adapt√© qui
est le plus √† m√™me de r√©soudre le probl√®me qu&rsquo;il a en vue.  Choisir un langage
n&rsquo;affranchit pas le concepteur d&rsquo;avoir √† se poser des questions difficiles sur
la structure du syst√®me.  En 2003, Parnas d√©plore cette tendance [<a href="#DBB+03">DBB+03</a>]:
</p>

<aside style="margin-top:18rem">
<p>
Cette derni√®re phrase est cible directement les trois autres pan√©listes qui lui
font face, qui sont les instigateurs respectifs de l&rsquo;AOP, du FOP, et d&rsquo;Hyper/J.
</p>
</aside>

<blockquote>
<p>
To a man with a hammer, everything looks like a nail.  To a Computer Scientist,
everything looks like a language design problem.  Languages and compilers are,
in their opinion, the only way to drive an idea into practice.
</p>

<p>
My early work clearly treated modularisation as a design issue, not a language
issue.  A module was a work assignment, not a subroutine or other language
element.  Although some tools could make the job easier, no special tools were
needed to use the principal, just discipline and skill.  When language designers
caught on to the idea, they assumed that modules had to be subroutines, or
collections of subroutines, and introduced unreasonable restrictions on the
design.  They also spread the false impression that the important thing was to
learn the language; in truth, the important thing is to learn how to design and
document.  We are still trying to undo the damage caused by the early treatment
of modularity as a language issue and, sadly, we still try to do it by inventing
languages and tools.
</p>
</blockquote>

<p>
Parnas r√©it√®re: le langage de programmation seul ne rend pas le programme
modulaire.  C&rsquo;est aussi facile de cr√©er un programme non-modulaire dans un
langage de haut niveau qu&rsquo;en assembleur.  On ne pourra donc pas rendre les
programmes modulaires simplement en fournissant de meilleurs languages ou
outils.
</p>

<p>
Alors, quelle est la bonne direction √† suivre?  D&rsquo;apr√®s Parnas, il faut insister
sur la phase de conception du syst√®me; c&rsquo;est l√† o√π les limites entre modules
apparaissent, et l√† o√π les d√©cisions de design doivent √™tre prises:
</p>

<blockquote>
<p>
My engineering teacher laid down some basic rules:
</p>

<ol class="org-ol">
<li>Design before implementing.</li>
<li>Document your design.</li>
<li>Review and analyze the documented design.</li>
<li>Review implementation for consistency with the design.</li>
</ol>

<p>
There rules apply to software as least as much as they do to circuits or
machines.
</p>
</blockquote>
</div>

<div id="outline-container-orgheadline30" class="outline-5">
<h5 id="orgheadline30">Conclusions</h5>
<div class="outline-text-5" id="text-orgheadline30">
<p>
Parnas est souvent cit√© pour ses travaux sur la modularit√©, √† juste titre, mais
son message principal n&rsquo;est pas toujours bien entendu.  On trouve dans l&rsquo;article
s√©minal de 1972 les avantages d&rsquo;un syst√®me modulaire, et un crit√®re pour les
concevoir: le crit√®re d&rsquo;encapsulation.  Quelles parties du syst√®me ont besoin de
pouvoir √™tre chang√©es?  D&rsquo;une machine √† l&rsquo;autre, ou en r√©ponse √† des besoins
futurs?  Ces parties d√©terminent les modules du syst√®me selon le crit√®re
d&rsquo;encapsulation.  De ce crit√®re d√©coulent des notions de s√©paration des
pr√©occupations et de type de donn√©es abstrait (qu&rsquo;il ne nomme pas).
L&rsquo;encapsulation est un crit√®re sup√©rieur √† la fa√ßon usuelle de d√©couper les
programmes selon le processus de traitement des donn√©es, en suivant un
logigramme.
</p>

<p>
Parnas nous permet donc de <i>qualifier</i> la modularit√© d&rsquo;un syst√®me.  Un syst√®me
simplement d√©coup√© en modules arbitraires n&rsquo;est pas modulaire.  Mais si pour
changer la base de donn√©es utilis√©e par le syst√®me il suffit de modifier le code
d&rsquo;un seul module, alors ce syst√®me est modulaire <i>par rapport</i> √† la base de
donn√© utilis√©e.  La base de donn√©e initiale est un choix de conception, mais un
choix qui peut √™tre chang√© ult√©rieurement sans demander la refonte totale du
syst√®me.  Le syst√®me est modulaire <i>par rapport</i> √† un ensemble de choix qui
peuvent √™tre alt√©r√©s ult√©rieurement.
</p>

<p>
On peut donc voir la modularit√© comme une des fonctionnalit√©s du syst√®me; une
fonctionnalit√© √† destination des programmeurs charg√©s de la maintenance du
syst√®me, plut√¥t qu&rsquo;une fonctionnalit√© destin√©e aux utilisateurs.  Et comme toute
fonctionnalit√©, la modularit√© impose un co√ªt de complexit√© au syst√®me.  Si le
programme est flexible, s&rsquo;il permet de changer la base de donn√©e utilis√©e, alors
il faut que le reste du syst√®me soit capable de fonctionner non plus avec une
seule base de donn√©e, mais avec plusieurs bases diff√©rentes.  G√©rer cette
compatibilit√© impose de traiter plus de cas, ce qui in√©vitablement se traduit en
code.  De plus, pour impl√©menter un syst√®me modulaire, on fera souvent appel √†
des interfaces, des indirections, des appels de proc√©dures qui encapsulent les
d√©cisions de conception.  Et ces interfaces ont souvent un impact n√©gatif sur
l&rsquo;efficacit√© du programme.  Ces compromis modularit√©/complexit√© et
modularit√©/efficacit√© me semblent in√©vitables.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline33" class="outline-4">
<h4 id="orgheadline33"><span class="section-number-4">2.7.2</span> <span class="done STABLE">STABLE</span> La th√©orie de Naur derri√®re le programme</h4>
<div class="outline-text-4" id="text-2-7-2">
<p>
Un point de vue qui compl√©mente celui de Parnas est celui de Peter Naur.  Dans
&laquo;&nbsp;Programming as Theory Building&nbsp;&raquo; [<a href="#Nau-85">Nau85</a>] il attache, comme Parnas, beaucoup
d&rsquo;importance √† la r√©flexion du programmeur dans l&rsquo;√©laboration d&rsquo;un syst√®me.
Et il s&rsquo;int√©resse √©galement √† la modification de programmes, aux difficult√©s qui
apparaissent quand on essaye d&rsquo;ajouter des fonctionnalit√©s non pr√©vues
initialement.
</p>

<p>
Pour Naur, la t√¢che principal du programmeur n&rsquo;est pas de produire du code
source.  Un programmeur avant tout construit une <i>th√©orie</i> du probl√®me que le
programme doit r√©soudre.  Lors de la conception et de l&rsquo;impl√©mentation, le
programmeur construit sa connaissance du probl√®me, du domaine d&rsquo;application, et
des outils.  Cette connaissance est naturellement interne, et toute production
externe (code source, documentation, diagrammes) ne fait la refl√©ter qu&rsquo;en
partie.
</p>

<div style="margin-top:-10rem" class="side-figure">

<figure>
<p><img src="img/naur-theory.svg" alt="naur-theory.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;23&nbsp;:</span> Pour Naur, le code source et la documentation ne sont que des produits secondaires de la programmation; mais l&rsquo;activit√© principale du programmeur est de construire une connaissance du probl√®me, une <i>th√©orie</i>.</figcaption>
</figure>

</div>

<p>
Ce point de vue, Naur le tire de sa propre exp√©rience √† construire de larges
syst√®mes.  Il donne l&rsquo;exemple d&rsquo;un compilateur d√©velopp√© par un groupe A pour
une machine X.  Le compilateur fonctionne tr√®s bien, et un autre groupe de
programmeurs, le groupe B, souhaite √©tendre l√©g√®rement le langage, et r√©utiliser
ce compilateur pour une machine Y.  Le groupe B planifie les
changements √† apporter au compilateur apr√®s avoir √©tudi√© sa structure, et
vient discuter des changements avec le groupe A qui offre son soutient:
</p>

<blockquote>
<p>
In several major cases it turned out that the solutions suggested by group B
were found by group A to make no use of the facilities that were not only
inherent in the structure of the existing compiler but were discussed at length
in its documentation, and to be based instead on additions to that structure in
the form of patches that effectively destroyed its power and simplicity.  The
members of group A were able to spot these cases instantly and could propose
simple and effective solutions, framed entirely within the existing structure.
</p>
</blockquote>

<p>
Le groupe B avait le code source et la documentation, et du temps pour les
√©tudier.  Malgr√© cela, les modifications du compilateur qu&rsquo;il envisage sont
jug√©es inad√©quates par le groupe A, qui est capable de proposer rapidement des
modifications plus simples et directes.  Naur en conclut que la documentation et
le code source n&rsquo;ont pas √©t√© suffisants pour communiquer toutes les d√©cisions de
conception au groupe B, pour communiquer la <i>th√©orie</i> du compilateur.
</p>

<p>
&laquo;&nbsp;Th√©orie&nbsp;&raquo; ici n&rsquo;a pas un sens abstrait; si un programmeur du groupe A poss√®de la
th√©orie du compilateur, c&rsquo;est que non seulement il sait comment le compilateur
fonctionne dans le d√©tail, mais il est aussi capable de l&rsquo;expliquer √† quelqu&rsquo;un
du groupe B, de r√©pondre √† des questions sur le compilateur, de d√©battre sur les
choix d&rsquo;impl√©mentation.  Avoir la th√©orie du programme, c&rsquo;est avoir internalis√©
une connaissance <i>pratique</i>, et √™tre capable d&rsquo;appliquer cette connaissance √†
d&rsquo;autres probl√®me connexes:
</p>

<blockquote>
<p>
The notion of theory employed here is explicitly <i>not</i> confined to what may be
called the most general or abstract part of the insight.  For example, to have
Newton&rsquo;s theory of mechanics as understood here it is not enough to understand
the central laws, such as that force equals mass times acceleration.  In
addition, as described in more detail by Kuhn, the person having the theory must
have an understanding of the manner in which the central laws apply to certain
aspects of reality, so as to be able to recognize and apply the theory to other
similar aspects.
</p>
</blockquote>

<p>
Pourquoi s&rsquo;int√©resser √† cette notion de th√©orie?  Parce qu&rsquo;elle permet de mieux
comprendre comment modifier un programme.  Naur commence par constater que
modifier des programmes est une pratique courante, motiv√©e par l&rsquo;√©conomie.  Si
on a d√©j√† un programme qui fait √† peu pr√®s ce qu&rsquo;on veut obtenir, c&rsquo;est
raisonnable de penser que modifier ce programme sera plus rapide que d&rsquo;en
recr√©er un compl√®tement nouveau.  Naur remarque que ce raisonnement ne consid√®re
que la facilit√© de modifier le <i>texte</i> du programme.  En effet, le code source
d&rsquo;un programme sous forme texte est facilement modifiable; bien plus qu&rsquo;une
construction physique comme un immeuble, un pont, ou une voiture.  Si l&rsquo;on
consid√®re plut√¥t le point de vue de Naur ‚Äî que le programmeur manipule avant
tout une th√©orie ‚Äî on ne peut pas modifier le programme sans prendre en compte
la th√©orie sous-jacente:
</p>

<blockquote>
<p>
What is needed in a modification, first of all, is a confrontation of the
existing solution with the demands called for by the desired modification.  In
this confrontation the degree and kind of similarity between the capabalities of
the existing solution and the new demands has to be determined.  The point is
that the kind of similarity that has to be recognized is accessible to the human
beings who possess the theory of the program, although entirely outside the
reach of what can be determined by rules, since even the criteria on which to
judge it cannot be formulated.
</p>
</blockquote>

<p>
Si l&rsquo;on se contente de modifier le code source sans consid√©rer la th√©orie, on se
retrouve dans le cas du groupe B; √† √©tendre le compilateur de fa√ßon
tarabiscot√©e, sans tirer partie de sa structure:
</p>

<blockquote>
<p>
For a program to retain its quality it is mandatory that each modification is
firmly grounded in the theory of it.  Indeed, the very notion of qualities such
as simplicity and good structure can only be understood in terms of the theory
of the program, since the characterize the actual program text in relation to
such program texts that might have been written to achieve the same execution
behaviour, but which exist only as possibilities in the programmer&rsquo;s
understanding.
</p>
</blockquote>

<p>
Donc, si l&rsquo;on souhaite modifier le programme, il faut vraiment tenter de
modifier la th√©orie.  Pour cela, il faut d&rsquo;abord avoir acc√®s √† cette th√©orie.
Si on n&rsquo;a pas acc√®s aux d√©veloppeurs du programme, les possesseurs de sa
th√©orie, il faut tenter de la recr√©er √† partir de code source et de la
documentation.  Naur appelle cela la &laquo;&nbsp;r√©surrection de programme&nbsp;&raquo;.  √Ä ses yeux,
c&rsquo;est un acte sans espoir:
</p>

<aside style="margin-top: -4.5rem">
<p>
En filant la m√©taphore, l&rsquo;ensemble des techniques qui permettent de modifier un
programme abandonn√© sans se soucier de sa th√©orie pourrait s&rsquo;appeler
&laquo;&nbsp;n√©cromancie de programme&nbsp;&raquo;.
</p>
</aside>

<blockquote>
<p>
A very important consequence of the Theory Building View is that program
revival, that is re-establishing the theory of a program merely from the
documentation, is strictly impossible.
</p>

<p>
[&#x2026;] building a theory to fit and support an existing program text is a
difficult, frustrating, and time consuming activity.  The new programmer is
likely to feel torn between loyalty to the existing program text, with whatever
obscurities and weaknesses it may contain, and the new theory that he or she has
to build up, and which, for better or worse, most likely will differ from the
original theory behind the program text.
</p>
</blockquote>

<p>
Il conc√®de que revivre un programme de cette fa√ßon peut √™tre utile dans des
circonstances particuli√®res, mais en √©tant bien conscient de l&rsquo;effort √† fournir
pour obtenir un r√©sultat probablement de qualit√© inf√©rieure.
</p>

<p>
L&rsquo;alternative qu&rsquo;il conseille, est de toujours recr√©er le programme:
</p>

<blockquote>
<p>
In preference to program revival, the existing program text should be discarded
and the new-formed programmer team should be given the opportunity to solve the
given problem afresh.  Such a procedure is more likely to produce a viable
program than program revival, and at a no higher, and possibly lower, cost.
</p>
</blockquote>

<p>
Modifier le code source du programme n&rsquo;est facile qu&rsquo;en apparence; car modifier
la fonctionnalit√© du programme demande de reconstruire sa th√©orie, afin de
s&rsquo;assurer que les changements envisag√©s auront bien les effets voulus.
Puisqu&rsquo;il faut reconstruire la th√©orie du probl√®me initial, puis l&rsquo;adapter au
probl√®me qui int√©resse le programmeur, l&rsquo;effort sera moindre en construisant une
th√©orie directement adapt√©e au nouveau probl√®me.
</p>

<p>
Naur attaque une autre id√©e populaire du g√©nie logiciel: qu&rsquo;une m√©thode de
programmation, un ensemble de r√®gles √† observer, peut √™tre sup√©rieure √† une
autre.  Une m√©thode pr√©conise les √©tapes du processus de d√©veloppement, ou les
documents √† produire et dans quel ordre.  Mais pour Naur, le seul point qui
importe c&rsquo;est le d√©veloppement de la th√©orie du programme, et aucune m√©thode ne
peut garantir une construction correcte:
</p>

<blockquote>
<p>
A method implies a claim that program development can and should proceed as a
sequence of actions of certain kinds, each action leading to a particular kind
of documented result.  In the Theory Buiding View what matters most is the
building of the theory, while production of documents is secondary.  In buiding
the theory there can be no particular sequence of actions, for the reason that a
theory held by a person has no inherent division into parts and no inherent
ordering.  Rather, the person possessing a theory will be able to produce
presentations of various sorts on the basis of it, in response to questions or
demands.
</p>
</blockquote>

<p>
Pour les m√™mes raisons, le choix du langage de programmation, ou d&rsquo;un formalisme
particulier ne peut remplacer la construction de la th√©orie:
</p>

<blockquote>
<p>
As to the use of particular kinds of notation or formalization, again this can
only be a secondary issue since the primary item, the theory, is not, and cannot
be, expressed, and so no question of the form of its expression arises.
</p>
</blockquote>

<p>
Quoi dire alors aux programmeurs novices?  Comment leur faire comprendre ces
notions, comment les amener √† construire d&rsquo;√©l√©gantes th√©ories pour cr√©er des
programmes flexibles et efficaces?  Naur recommande de les former principalement
de fa√ßon organique: en travaillant avec des programmeurs chevronn√©s, ils
absorberont les connaissances n√©cessaires par osmose.
</p>

<blockquote>
<p>
What remains is the effect of methods in the eduction of programmers.  Indeed,
on this view the quality of the theory built by the programmer will depend to a
large extent on the programmer&rsquo;s familiarity with model solutions of typical
problems, with techniques of description and verification, and with principles
of structuring systems consisting of many parts in complicated interactions.
</p>

<p>
While skills such as the mastery of notations, data representations, and data
processes, remain important, the primary emphasis would have to turn in the
direction of furthering the understanding and talent for theory formation.  To
what extent this can be taught at all must remain an open question.  The most
hopeful approach would be to have the student work on concrete problems under
guidance, in an active and constructive environment.
</p>
</blockquote>
</div>

<div id="outline-container-orgheadline32" class="outline-5">
<h5 id="orgheadline32">Conclusions</h5>
<div class="outline-text-5" id="text-orgheadline32">
<p>
Naur √©tablit une distinction importante entre le source code d&rsquo;un programme, et
la connaissance que le programmeur a de son fonctionnement.  C&rsquo;est une
distinction intuitive pour quiconque a une exp√©rience m√™me modeste de
programmation.  Cette distinction nous permet notamment de comprendre pourquoi
modifier un programme n&rsquo;est pas simplement modifier du texte, modifier son code
source.  Il faut prendre en compte les choix faits au moment du design du
programme, et consid√©rer comment les changements que l&rsquo;on souhaite apporter
affectent ces choix.  Comprendre la th√©orie.
</p>

<p>
Naur estime que la th√©orie n&rsquo;est pas communicable; qu&rsquo;elle reste toujours
interne au programmeur qui la construit.  Mais √† l&rsquo;√©vidence le programmeur est
toujours capable de la communiquer <i>en partie</i>.  La th√©orie, c&rsquo;est savoir
comment le programme fonctionne, pourquoi telle partie est n√©cessaire, comment
√©tendre le programme&#x2026; Naur dit lui-m√™me plusieurs fois qu&rsquo;un programmeur qui
poss√®de la th√©orie est capable de r√©pondre √† ces questions sur le programme,
c&rsquo;est bien qu&rsquo;il y a une personne qui doit interpr√©ter ces r√©ponses et
reconstruire la th√©orie.  Quand bien m√™me la th√©orie ne peut √™tre communiqu√©e
<i>exactement</i> comme telle d&rsquo;un programmeur √† l&rsquo;autre, il suffit d&rsquo;en communiquer
une partie suffisante pour satisfaire les besoins de l&rsquo;autre.
</p>

<p>
Le message g√©n√©ral est proche de Parnas: l&rsquo;important dans la programmation ce ne
sont pas les formalismes, les langages ou les outils; c&rsquo;est de r√©fl√©chir, de
comprendre le probl√®me, et construire une solution qui satisfait les contraintes
donn√©es.   Et c&rsquo;est cette aptitude √† r√©soudre le probl√®me qui devraient √™tre
enseign√©e principalement aux novices.  En cela, la programmation n&rsquo;est pas
diff√©rente d&rsquo;autres activit√©s:
</p>

<blockquote>
<p>
This problem of education of new programmers in an existing theory of a program
is quite similar to that of the educational problem of other activities where
the knowledge of how to do certain things dominates over the knowledge that
certain things are the case, such as writing and playing a music instrument.
The most important educational activity is the student&rsquo;s doing the relevant
things under suitable supervision and guidance.  In the case of programming the
activity should include discussions of the relation between the program and the
relevant aspects and activities of the real world, and of the limits set on the
real world matters dealt with by the program.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgheadline34" class="outline-4">
<h4 id="orgheadline34"><span class="section-number-4">2.7.3</span> Notion of modularity</h4>
<div class="outline-text-4" id="text-2-7-3">
<p>
Notion of modularity [<a href="#OGK+11">OGK+11</a>].  Modularity is rooted in classical logic thinking.
Classical logic is inflexible, incompatible with the realities of software.
Especially, information hiding is not the silver bullet.  Approaches to software
development that seem to break information hiding, and even oppose modular
reasoning, have their virtues.  Those can be thought of using nonclassical
logics.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline47" class="outline-3">
<h3 id="orgheadline47"><span class="section-number-3">2.8</span> Les m√©canismes de recomposition du programme</h3>
<div class="outline-text-3" id="text-2-8">
</div><div id="outline-container-orgheadline36" class="outline-4">
<h4 id="orgheadline36"><span class="section-number-4">2.8.1</span> <span class="todo BARE">BARE</span> Le probl√®me de l&rsquo;expression</h4>
<div class="outline-text-4" id="text-2-8-1">
<p>
Wadler, Odersky, Krishnamurthi, Oliveira (expression families) &#x2026;
</p>
</div>
</div>

<div id="outline-container-orgheadline37" class="outline-4">
<h4 id="orgheadline37"><span class="section-number-4">2.8.2</span> <span class="todo BARE">BARE</span> Dynamic binding</h4>
<div class="outline-text-4" id="text-2-8-2">
<p>
Introduced by McCarthy&rsquo;s LISP [<a href="#McC-60">McC60</a>] as a bug.  Can be emulated by passing a
dynamic environment in lexical binding [<a href="#Que-03">Que03</a>].
</p>

<p>
Implicit parameters [<a href="#LLM+00">LLM+00</a>] provide dynamic scoping for Haskell (though they lose
their first-class privileges).
</p>

<p>
[<a href="#Mor-98">Mor98</a>] gives a syntactic theory of dynamic binding, and prove that dynamic
binding adds expressiveness to a purely functional language.  They give examples
in Perl, TeX, Common Lisp and Bash.
</p>

<p>
[<a href="#Tan-09a">√T09a</a>] generalizes dynamic and static binding by making explicit the two
dimensions of propagation of bindings (call stack and delayed lambdas), and
offering a filter function to toggle the activation of a propagated binding.
</p>

<p>
Some use-cases are mentioned, but none are demonstrated in the paper.  The
proposal is not motivated enough by concrete applications that would be
difficult to solve using existing mechanisms.  Also, the work is really focused
on the binding semantics of Scheme, which reduce its applicability.
</p>
</div>
</div>

<div id="outline-container-orgheadline38" class="outline-4">
<h4 id="orgheadline38"><span class="section-number-4">2.8.3</span> <span class="todo BARE">BARE</span> Building from modules</h4>
<div class="outline-text-4" id="text-2-8-3">
<p>
Findler &amp; Flatt, Newspeak
</p>
</div>
</div>

<div id="outline-container-orgheadline39" class="outline-4">
<h4 id="orgheadline39"><span class="section-number-4">2.8.4</span> <span class="todo BARE">BARE</span> Building with monads</h4>
<div class="outline-text-4" id="text-2-8-4">
<p>
Wadler, Steele, Spinoza, Swierstra, R√∫nar, &#x2026;
</p>

<p>
Free algebras, free monads.  Basically reify data in a way that is accepted by
the type system of the underlying language to allow unanticipated extension.
</p>

<p>
[<a href="#OC-12">dSOC12</a>] gives Java code with generics for solving the expression problem using
<i>object algebras</i>.  Object algebras are akin to a free algebra.  Instead of
locking down the actual objects used as expressions too early, they leave them
open using abstract factories.  Providing a factory when evaluating the
expression gives you either integer evaluation, or pretty-printing.
</p>

<p>
Their solution is applicable to Java with generics, without significant
syntactic overhead (less than related work).  And, they leverage the type system
to capture erroneous composition.
</p>

<p>
Aspects and monads are sometimes both viewed as mechanisms to achieve modularity
in software [<a href="#DBB+03">DBB+03</a>,<a href="#HO-07">HO07</a>,<a href="#Meu-97">Meu97</a>].
</p>

<p>
De Meuter shows we can use a monad to memoize <code>fib</code>, so efficiency concern is
cleanly separated.  But a function is enough to memoize <code>fib</code>, so the example is
not very convincing.  Well, he does not write <code>fib</code> as a function, but as a
method in a custom OO language embedded in Scheme.  Then, he is just
intercepting the method name in the <code>bind</code> of the &laquo;&nbsp;interpreter&nbsp;&raquo;.  Which is kinda
like reflection.
</p>

<p>
Hofer and Ostermann are more on point, noting that common monads correspond to
concerns that can be written as aspects: error handling (Error monad), dynamic
scoping (Reader monad), continuations (Continuation monad).  Their conclusion is
AOP != monad: monads manipulate computation on a finer granularity that AOP
can&rsquo;t do.  On the other hand, AOP is more declarative, and can come in different
degrees of obliviousness, but monads are always explicit.
</p>

<p>
I think the better angle is to just say &laquo;&nbsp;Monads are a mecanism touted as
separating concerns and promoting modularity&nbsp;&raquo;, and that&rsquo;s enough to consider
them.  Maybe mention that some have related them to aspects, but there is no
sign of equivalence between the mecanisms.
</p>
</div>
</div>

<div id="outline-container-orgheadline40" class="outline-4">
<h4 id="orgheadline40"><span class="section-number-4">2.8.5</span> <span class="todo BARE">BARE</span> Bytecode instrumentation</h4>
<div class="outline-text-4" id="text-2-8-5">
<p>
Ansaloni.  Targets bytecode, which is low-level code.
</p>

<p>
Jinliner [<a href="#TSN+02">TSN+02</a>] can insert code into the bytecode of a Java program.  Allows to
alter the behavior of a program with no access to its source code.  Inserts code
after/before point of interest.
</p>

<p>
[<a href="#BRG+14">BRG+14</a>] instruments the bytecode interpreter of WebKit to enable information flow
tracking.  Bytecode instrumentation is difficult, because you lose high-level
details of the source code like &laquo;&nbsp;when does an if block ends&nbsp;&raquo;.  They have to
build a control-flow graph to know when to discard program counters used by the
information flow analysis.  Also, instrumenting the bytecode is specific to the
bytecode compiler of WebKit (there is no standard, unlike Java).
</p>
</div>
</div>

<div id="outline-container-orgheadline46" class="outline-4">
<h4 id="orgheadline46"><span class="section-number-4">2.8.6</span> Superimposition</h4>
<div class="outline-text-4" id="text-2-8-6">
</div><div id="outline-container-orgheadline41" class="outline-5">
<h5 id="orgheadline41"><span class="todo BARE">BARE</span> Caesar</h5>
<div class="outline-text-5" id="text-orgheadline41">
<p>
Caesar has everything and the kitchen sink.
[<a href="#AGM+06">AGM+06</a>]</p>

<p>
CaesarJ regroups virtual classes, mixins, pointcut-advice and binding classes.
All these mechanisms are brought together to allow composition along many axis.
</p>

<p>
But overall, I failed to see the problems that it solved.  Both papers [<a href="#AGM+06">AGM+06</a>,<a href="#MO-02">MO02</a>] are dense and opaque; the examples are too complicated to make sense of
the benefit brought by the new mechanisms.
</p>
</div>
</div>

<div id="outline-container-orgheadline43" class="outline-5">
<h5 id="orgheadline43"><span class="todo TRANSLATE">TRANSLATE</span> Software product lines</h5>
<div class="outline-text-5" id="text-orgheadline43">
<p>
[<a href="#ABK+13">ABK+13</a>] provides a well-rounded survey of the field.
</p>

<p>
An engineering methodology to create and maintain variants of a software
product, with optional features (analogy with car assembly lines, which allow
for adding optional features while reusing the same assembly process).
</p>

<p>
Inspired by the similar evolution in the mass production of consumer goods.
From handcrafting to mass production, to mass customization: product lines that
cover a spectrum of variations.  Examples abound: cars, multi-flavored
detergent, phones, Subway sandwiches &#x2026;  Software product lines are the
realization of mass customization for software products (yeah!).
</p>

<p>
A product line engineering platform combines all the artifacts, documentation
and methodologies of a family of products.  The goal of PLE is to manage the
<i>commonality</i> and <i>variability</i> of a product family.  PLE is not specific to
software.
</p>

<p>
Properties of a SPL:
</p>
<ul class="org-ul">
<li>binding time (composition can happen at compile-time, load-time or run-time)</li>
<li>language solution vs. tool based</li>
<li>annotation (think C preprocessor) vs. composition (features in their own unit)</li>
<li>preplanning effort (can you add features without designing for it?)</li>
<li>feature traceability (mapping between feature model to solution space)</li>
<li>separation of concerns</li>
<li>information hiding</li>
<li>uniformity</li>
</ul>

<p>
Software product lines mechanisms include:
</p>
<ul class="org-ul">
<li>global parameters</li>
<li>design patterns (observer, strategy, decorator)</li>
<li>frameworks</li>
<li>components</li>
</ul>

<p>
Using version control branches to manage variability is also discussed.  Each
branch correspond to a product, and code sharing is provided by the version
control tool.  However, version control manages <i>products</i> rather than
<i>features</i>.  Features are not apparent independently of the base code, except
when looking at diffs.
</p>

<p>
Feature-oriented programming allows the decomposition of a program into features
first.  Jak is a Java extension that supports FOP [<a href="#BSR-04">BSR04</a>].  A feature corresponds
to a layer, and each layer can contain multiple classes that implement the
feature.  Further layers can <i>refine</i> the classes of previous layer, and refer
to their implementation via the <code>original</code> keyword.
</p>

<p>
FeatureHouse [<a href="#AKL-13">AKL13</a>] is akin to <a href="#orgheadline42">Semantic patches</a>, in that it uses a reduced
syntax tree in order to transform code.  One writes a base program, then another
program can be superimposed on it by matching their reduced syntax trees.  The
base program code can be called using the <code>original</code> keyword.  Three-way merges
are also possible, and resolved like in version control systems.  The model of
reduced syntax trees of FeatureHouse is language independent, as are the
composition mechanisms.  Language plugins can be written to tell
FeatureHouse how to generate, compose, and pretty-print reduced syntax trees.
</p>

<pre class="example">
public class A {
  private int foo() { return 0; }
}

public class A {
  private int foo() { original(); return 1; }
}
</pre>

<p>
FeatureHouse also supports quantification.  Mixins and traits mechanisms are
essentially instances of superimposition.
</p>

<p>
FOP is well-suited to implementing <i>heterogeneous concerns</i> (one variation per
join point), while AOP is better for <i>homogeneous concerns</i> (one variation,
multiple join points). [<a href="#MO-04">MO04</a>] illustrates the compromises of each approaches (and
presents <a href="#orgheadline41">Caesar</a> as the superior solution).
</p>

<p>
If you cannot maintain a separation of concerns in the code itself, you can
emulate it through views.  <i>Virtual separation of concerns</i> is using tools to
provide coherent views of features that are scattered in the code [<a href="#AK-09">AK09</a>].
</p>

<p>
Virtual separation of concerns has few downsides and many benefits: simplicity
and flexibility being the chief advantages.
</p>

<p>
Handling feature interactions is an open problem.  Detecting them also.
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline44"></a>Mechanisms for instrumentation<br ><div class="outline-text-6" id="text-orgheadline44">
<p>
FOP implementations presented here are static organization of code into
features.  Much like design patterns or frameworks, they require the programmer
to design for extensibility beforehand.  AspectJ allows extending an existing
code base (unlike the original AOP vision, which emphasized the design decision
of separating components from aspects).
</p>

<p>
The notion of superimposition is nice.  Recognizing that inheritance, mixins and
traits are all instances of superimposition is a powerful insight.
</p>

<p>
Virtual separation of concerns makes some good points.  If the primary
decomposition is tyranny, then we have no hope of organizing the physical code
into features.  However, we can leverage editing tools to re-arrange and view
the code in any way we like.  One physical representation, many views.  Each
view can provide different information about the system.
</p>

<p>
The motivation behind all such mechanisms is a desire to organize snippets of
code, to structure modules, and avoid repetitions.  The ultimate conclusion of
that trend is a language-agnostic manipulation syntax based on hypertext.  Each
snippet has a name, and tags (for marking membership of a feature, but mostly
for non-hierarchical organization).  Any snippets can be referenced by another
(for documentation), and can be included for execution.  Snippets can be
referenced to by name, or by tags.  Tags and wildcards allow quantification.
</p>

<p>
Tags also allow to view the program through different lenses.  Snippets can have
parameters, hence are a form a macros.
</p>

<p>
Links are two way, and kept in sync by the programming system (editor): this
prevents obliviousness.
</p>
</div></li></ul>
</div>

<div id="outline-container-orgheadline42" class="outline-5">
<h5 id="orgheadline42"><span class="todo TRANSLATE">TRANSLATE</span> Semantic patches</h5>
<div class="outline-text-5" id="text-orgheadline42">
<p>
[<a href="#PLM-07">PLM07</a>].  A solution to <i>collateral evolution</i>.  When a library function changes
name, or gains an argument, client code must makes the necessary changes.  The
changes in client code are collateral.
</p>

<p>
In a semantic patch, one describes the pattern of collateral changes needed to
adapt client code.
</p>

<pre class="example">
@ rule2 @
identifier proc_info_func;
identifier hostptr;
@@
proc_info_func (
+ struct Scsi_Host *hostptr,
- int hostno
) {
  ...
- struct Scsi_Host *hostptr;
  ...
- hostptr = scri_host_hn_get(hostno);
  ...
- if (!hostptr) { ... return ...; }
  ...
- scsi_host_put(hostptr);
  ...
}
</pre>

<p>
Identifiers are declared in the header with a syntactic class.  They are matched
in the target code according to the context where they appear in the body of the
semantic path.
</p>

<p>
The dots <code>...</code> are an operator to match any sequence of code between two lines.
There is a mention of the dots matching the <i>control-flow</i> of the code, though
nothing indicates that <code>spatch</code> interprets the target code in any way.
</p>

<p>
[<a href="#JH-07">JH07</a>] demystifies the tool by giving a denotational semantics.  Indeed, the dots
only match the syntax.
</p>

<p>
The related work section of [<a href="#JH-07">JH07</a>] has a few surveys on software evolution, and
in particular the Journal of Software Maintenance and Evolution.
</p>

<p>
All around a nice idea, though you still have to write the semantic patches from
scratch for every change.
</p>

<p>
The (unintended) idea of source transformation based on dynamic control flow is
interesting.  See <a href="notes.html#MissingReference">Shapes of computation</a>.
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline45"></a>Mechanisms for extension<br ><div class="outline-text-6" id="text-orgheadline45">
<p>
It&rsquo;s another approach, transforming code to alleviate the maintenance cost.
</p>

<p>
However, it&rsquo;s a crutch.  We would prefer not having to have to make those
changes in the first place, even if the kernel libraries are updated.
</p>

<p>
The concept of <i>collateral evolution</i> is certainly related.  When interpreters
evolve, collateral changes are needed on the analyses.  Previous work [<a href="#PLM-06">PLM06</a>] was
more focused on introducing the collateral evolution problem, with plenty of
examples from the Linux kernel.
</p>
</div></li></ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline58" class="outline-3">
<h3 id="orgheadline58"><span class="section-number-3">2.9</span> <span class="todo UNSTABLE">UNSTABLE</span> Travaux connexes concernant l&rsquo;instrumentation</h3>
<div class="outline-text-3" id="text-2-9">
</div><div id="outline-container-orgheadline48" class="outline-4">
<h4 id="orgheadline48"><span class="section-number-4">2.9.1</span> <span class="todo BARE">BARE</span> Domain-specific languages</h4>
<div class="outline-text-4" id="text-2-9-1">
<p>
Greater control for language designer.  Gives a constrained playground for
programmers.
</p>

<p>
Downsides include tooling, development time, unfamiliarity and competition with
general-purposes languages.
</p>

<p>
Monads can be seen as DSLs (but this is an insight better saved for later).
</p>
</div>
</div>

<div id="outline-container-orgheadline49" class="outline-4">
<h4 id="orgheadline49"><span class="section-number-4">2.9.2</span> <span class="todo BARE">BARE</span> Scripting languages</h4>
<div class="outline-text-4" id="text-2-9-2">
<p>
Tcl 1988, Python 1991, Lua 1993, VBA 1993, JS 1995.  Scripting languages are an
early ‚Äò90s phenomenon.  Dealing with low-level languages was deemed too heavy,
but writing your whole system in a high-level language was too costly.  The
compromise was to write the kernel in C, and the rest in a scripting language.
</p>

<p>
With sufficiently efficient high-level languages, the kernel+configuration
approach might be unneeded.
</p>

<p>
JavaScript being a scripting language for the browser, as well as an object used
in the Core, it might be adequate to have a dedicated background section to it.
</p>
</div>
</div>

<div id="outline-container-orgheadline51" class="outline-4">
<h4 id="orgheadline51"><span class="section-number-4">2.9.3</span> <span class="todo TRANSLATE">TRANSLATE</span> Emacs</h4>
<div class="outline-text-4" id="text-2-9-3">
<p>
See Emacs Manual, [<a href="#Sta-81">Sta81</a>], [<a href="#Hal-88">Hal88</a>].  Emacs is an example of an extensible system.
The mechanisms: global namespace, dynamic scoping, and a simple aspect system.
</p>

<p>
In [<a href="#Sta-81">Sta81</a>], it is said that the TECO language was instrumental for the
extensibility of the EMACS system.  An interpreter should be available all the
time, and compiled languages often lack this functionality.
</p>

<blockquote>
<p>
A system written in PL/I or PASCAL can be modified and recompiled, but such an
extension becomes a separate version of the entire program. The user must
choose, before invoking the program, which version he wants. Combining two
independent extensions requires comparing and merging the source files.  These
obstacles usually suffice to discourage all extension.
</p>
</blockquote>

<p>
Especially they list &laquo;&nbsp;Language features for extensibility&nbsp;&raquo;:
</p>
<ol class="org-ol">
<li>Global variables.  They can be queried, referred to, and redefined.</li>
<li><a href="#orgheadline37">2.8.2</a>.  Useful for redefining binding on the fly.</li>
<li>File-local variables.  Good for customization, but really they give a
file-local value for a global variable.</li>
<li>Hooks.  They give points in the control flow to insert extension code.
Especially when redefining assembly or C functions, which cannot be
reinterpreted.</li>
<li>Error handling.  Throwing the debugger helps discover and recover from
unexpected situations.</li>
<li>Non-local transfers.  Gives an example to exit an infinite loop.</li>
</ol>


<p>
In the related work, Multics EMACS [<a href="#Gre-80">Gre80</a>] is mentioned as being more flexible,
as it is written in MacLisp directly.  Smalltalk [<a href="#Ing-78">Ing78</a>] is also said to be
&laquo;&nbsp;oriented toward writing extensible programs&nbsp;&raquo;.
</p>

<p>
(The Augment editor demoed by Engelbart [<a href="#EE-68">EE68</a>] is also mentioned, though nothing
is said of its extensibility.)
</p>

<p>
[<a href="#NS-01">NS01</a>] proposes a dynamic scope analysis, to translate Emacs Lisp code using
dynamic binding to lexical binding.
</p>
</div>

<div id="outline-container-orgheadline50" class="outline-5">
<h5 id="orgheadline50">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline50">
<p>
Global variables, dynamic binding, hooks.
</p>

<p>
Though hooks are more a convention than a first-class mechanism.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline53" class="outline-4">
<h4 id="orgheadline53"><span class="section-number-4">2.9.4</span> <span class="todo TRANSLATE">TRANSLATE</span> Eclipse and other IDEs</h4>
<div class="outline-text-4" id="text-2-9-4">
<p>
As noted by [<a href="#Ler-11">Ler11</a>], the Eclipse platform is extensible, and built using
plugins.  Each plugin states its dependencies (the hooks needed to function),
and its extension points (for other plugins).
</p>

<p>
Eclipse plugins are compiled, though they can be loaded dynamically (if they are
written properly).  Symptomatically of Java, writing plugins needs lot of
boilerplate code and XML (which Eclipse can generate for you, I understand).
</p>
</div>

<div id="outline-container-orgheadline52" class="outline-5">
<h5 id="orgheadline52">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline52">
<p>
The mechanisms for extension seems to revolve around the observer pattern: a
host plugin raises events which can be intercepted by extensions [<a href="#Bol-03">Bol03</a>].
</p>

<p>
So, a lot of convention.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline55" class="outline-4">
<h4 id="orgheadline55"><span class="section-number-4">2.9.5</span> <span class="todo BARE">BARE</span> Web browsers</h4>
<div class="outline-text-4" id="text-2-9-5">
<p>
Many extensions are written for web browsers.  The mechanisms are heavy,
comparable to the effort of writing an Eclipse plug-in.
</p>

<p>
In fact, ZaphodFacets was an extension to change the JavaScript interpreter used
by the browser.
</p>
</div>

<div id="outline-container-orgheadline54" class="outline-5">
<h5 id="orgheadline54">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline54">
<p>
Convention.  Write manifest, and define the agreed-upon functions (install,
startup).
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline57" class="outline-4">
<h4 id="orgheadline57"><span class="section-number-4">2.9.6</span> <span class="todo TRANSLATE">TRANSLATE</span> Lua</h4>
<div class="outline-text-4" id="text-2-9-6">
<p>
An extensible extension language [<a href="#IFF-96">IdFF96</a>].
</p>

<p>
Extensible systems comprise of a kernel and a configuration.  The kernel is the
core of the system, the parts that cannot change, and is usually compiled for
speed and efficiency.  The configuration part is written in an interpreted,
flexible language, which can interact with the kernel.
</p>

<p>
Another take, in the conclusion, is that the kernel is a virtual machine for
programs written in the configuration language.
</p>

<p>
Note that if performance can suffer, writing the whole system as a configuration
gives even greater flexibility.
</p>

<p>
Configuration languages can be simple: .ini files, X11 resource files, but they
can have more features (scripting languages).  Also called <i>extension
languages</i>.
</p>

<p>
Five requirements for extension languages:
</p>
<ol class="org-ol">
<li>good data structures (key-value maps for configuration)</li>
<li>simple syntax for amateur programmers</li>
<li>lightweight</li>
<li>not static type checking or exception handling, as only small programs are
written in them</li>
<li>should be extensible</li>
</ol>

<p>
Requirement 4 is actually an absence of requirement.  Unfortunately, people
<i>will</i> write large systems in it, especially if the language is easy to pick up.
Arguably, the cost of such features may conflict with requirement 3.  Otherwise,
this list looks more like a checklist for Lua.
</p>

<p>
On a related note, [<a href="#Bla-82">Bla82</a>] devotes a whole thesis against exceptions.
</p>

<p>
Extension programs have no <code>main</code>.
</p>

<p>
Associative arrays are a powerful data structure which make plenty of algorithms
trivial (free hashtables), and more efficient to implement than lists.
</p>

<p>
Amusingly, the associative array syntax was inspired by BibTeX.
</p>

<p>
Associative arrays + first-class functions = classes.
</p>

<p>
No error handling, but errors can be raised.  To catch them, we can define
<i>fallback</i> functions.
</p>

<p>
Setting a fallback on the &laquo;&nbsp;index&nbsp;&raquo; event allows to define a custom delegation
mechanism between tables.
</p>

<p>
Compared to Lisp, Lua is portable and has easier syntax.  Tcl is slow and has
strange syntax.  Python is not embeddable, and is already too complex (modules
and exception handling).
</p>

<p>
At the time of writing, Lua is 20 times slower than C (this factor is said to be
&laquo;&nbsp;typical for interpreted languages&nbsp;&raquo;, and cites &laquo;&nbsp;Java, The Language&nbsp;&raquo; for this
assertion).
</p>

<p>
The latest numbers on the <a href="http://benchmarksgame.alioth.debian.org/">benchmarks game</a> show Lua being 5 to 79 times slower,
while consuming more memory.
</p>

<p>
In the conclusion, they allude at extending web browsers with Lua.  A follow-up
seems to be [<a href="#HBI-98">HBI98</a>], which proposes Lua as a target for CGI on web servers.
</p>

<p>
[<a href="#IFF-07">IdFF07</a>] goes over the history of Lua, up to version 5.1 released in 2006.
</p>

<p>
One tenet of Lua is &laquo;&nbsp;Mechanisms, not policy&nbsp;&raquo;: provide language mechanisms and
let programmers code the way they want to with them.  An example is message
dispatch: rather than using a class construct, Lua programmers can use fallbacks.
</p>

<p>
Though they regret not stating a policy when it comes to modules, since everyone
is doing its thing, without agreeing on a common protocol.
</p>
</div>

<div id="outline-container-orgheadline56" class="outline-5">
<h5 id="orgheadline56">Mechanisms for extension</h5>
<div class="outline-text-5" id="text-orgheadline56">
<p>
The kernel+configuration, as seen in EMACS.  Mechanisms over policy shares our
philosophy and provides programmers with tools to solve their problems in their
own way.
</p>

<p>
To extend Lua, bindings from C can be added, and custom data structure as well.
Changing the interpreter does not seem possible, even from C.
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline60" class="outline-2">
<h2 id="orgheadline60"><span class="section-number-2">3</span> <span class="todo UNSTABLE">UNSTABLE</span> √âtude de cas: extension ad-hoc de Narcissus</h2>
<div class="outline-text-2" id="text-3">
<p>
Narcissus est un interpr√©teur JavaScript √©crit et maintenu par Mozilla
[<a href="#Narcissus">Nar</a>].  Narcissus est √©crit en JavaScript, et est meta-circulaire: il
utilise l&rsquo;environnement h√¥te pour son impl√©mentation (p.ex., l&rsquo;objet <code>String</code>
expos√© au code client n&rsquo;est pas r√©impl√©ment√© par Narcissus, mais est une simple
fa√ßade de l&rsquo;objet <code>String</code> h√¥te).  Narcissus est une impl√©mentation relativement
l√©g√®re (environ 6000 lignes de code) du standard ECMAScript [<a href="#ECM-99">ECM99</a>], qui permet
de rapidement prototyper des fonctionnalit√©s exp√©rimentales pour le langage.
</p>

<p>
En 2012, Austin et Flanagan se sont servi de Narcissus pour impl√©menter leur
analyse d&rsquo;√©valuation multi-facettes [<a href="#AF-12">AF12</a>], une analyse dynamique de flot
d&rsquo;information qui permet √† une valeur d&rsquo;√™tre √©tiquet√©e par une autorit√© qui a
des droits d&rsquo;√©criture et de lecture pour cette valeur.  Lorsqu&rsquo;une valeur
√©tiquet√©e est utilis√©e dans une expression, son √©tiquette est propag√©e au
r√©sultat de l&rsquo;expression, ce qui pr√©serve les permissions de l&rsquo;autorit√© sur le
r√©sultat.  Dans l&rsquo;analyse multi-facettes, chaque valeur √©tiquet√©e a deux
facettes: une facette contient la valeur &laquo;&nbsp;priv√©e&nbsp;&raquo; √† destination de l&rsquo;autorit√©,
une autre facettes contient la valeur &laquo;&nbsp;publique&nbsp;&raquo; destin√©e √† des observateurs
tiers non autoris√©s.  Dans une expression, les facettes sont toutes deux
√©valu√©es en m√™me temps afin de produire les deux facettes du r√©sultat.  Afin de
suivre les √©tiquettes m√™me lors de branchements (des flots <i>indirects</i>),
l&rsquo;√©valuation multi-facettes maintient une liste des embranchements suivis lors
de l&rsquo;ex√©cution; cette liste est appel√©e <i>program counter</i> (PC).
</p>

<div style="margin-top:-12rem" class="side-figure">

<figure>
<p><img src="img/a-facet.svg" alt="a-facet.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;24&nbsp;:</span> Une valeur √† deux facettes.</figcaption>
</figure>

</div>

<p>
Par exemple, dans le code suivant, si le param√®tre <code>x</code> est <code>true</code>, alors la
fonction <code>f</code> retourne <code>true</code>.  En revanche, si on fait de <code>x</code> une valeur √†
facettes avec une valeur priv√©e <code>true</code> et une valeur publique <code>false</code> (qu&rsquo;on
√©crit <code>true:false</code>), alors le premier <code>if</code> sera ex√©cut√© deux fois: une fois pour
chaque facette de la condition.  Apr√®s le second <code>if</code>, la fonction retourne la
valeur <code>true:false</code>.  Un observateur non autoris√© n&rsquo;a acc√®s qu&rsquo;√† la valeur
publique du r√©sultat, et n&rsquo;est donc pas capable d&rsquo;inf√©rer la valeur priv√©e de
<code>x</code>, m√™me √† travers un flot indirect d&rsquo;information.
</p>

<div style="margin-top:-13rem" class="side-figure">

<figure>
<p><img src="img/fenton-example.svg" alt="fenton-example.svg">
</p>
</figure>

</div>

<p>
Pour donner une id√©e de l&rsquo;√©chelle du projet, Narcissus fait 6000 lignes de code,
et les deux plus gros fichiers sont le parseur (1600 lignes) et le fichier
principal de interpr√©teur, &laquo;&nbsp;jsexec&nbsp;&raquo; (1300 lignes).  Ce fichier principal
contient la logique pour interpr√©ter des arbres de syntaxe abstraits, et pour
mettre en place l&rsquo;environnement d&rsquo;ex√©cution des programmes clients.  Les
changements effectu√©s pour l&rsquo;impl√©mentation de l&rsquo;√©valuation multi-facettes sont
restreints √† ce fichier principal; 640 lignes sont affect√©es, soit la moiti√©.
</p>

<aside style="margin-top:-6rem">
<p>
On compte les lignes de code physiques, commentaires inclus mais sans compter
les lignes vides.
</p>
</aside>

<p>
Pour r√©aliser l&rsquo;instrumentation de Narcissus pour l&rsquo;√©valuation multi-facettes,
les auteurs ont modifi√© directement le code source de l&rsquo;interpr√©teur Narcissus.
On peut obtenir l&rsquo;ensemble des changements effectu√©s en extrayant un <i>diff</i> des
deux versions.  La figure <a href="#orgparagraph1">20</a> donne une vue d&rsquo;ensemble des
changements.
</p>

<aside style="margin-top:-5rem">
<p>
Le <i>diff</i> est extrait des HEAD de <a href="https://github.com/taustin/narcissus">github/taustin/narcissus</a> et
<a href="https://github.com/taustin/ZaphodFacets">github/taustin/ZaphodFacets</a>.
</p>
</aside>

<p>
<a href="img/narcissus-diff.svg">narcissus diff</a>
</p>

<p>
On constate imm√©diatement que les changements effectu√©s par l&rsquo;instrumentation
touchent de nombreuses parties du code de l&rsquo;interpr√©teur, sans √™tre restreints √†
une ou deux r√©gions particuli√®res.  Les changements sont <b>√©parpill√©s</b> dans le
code.  De plus, les changements de m√™me nature‚Äîappartenant √† la m√™me
cat√©gorie‚Äîne sont pas regroup√©s.  R√©sultat, il devient difficile de comprendre
les effets de l&rsquo;instrumentation √† l&rsquo;≈ìil nu, ou de s&rsquo;assurer de sa justesse par
rapport √† une sp√©cification formelle.  Il devient difficile √©galement, sans
connaissances avanc√©es de Narcissus et de l&rsquo;√©valuation multi-facettes, de savoir
si une ligne de code de l&rsquo;interpr√©teur instrument√© concerne l&rsquo;interpr√©tation
d√©crite par le standard ECMAScript, ou si elle concerne l&rsquo;√©valuation
multi-facettes.  Le code de l&rsquo;interpr√©teur instrument√© ne comporte aucune
information qui permet de les distinguer.
</p>

<p>
Autre point important: l&rsquo;instrumentation <b>duplique tout le code</b> de
l&rsquo;interpr√©teur.  C&rsquo;est une solution simple pour cr√©er un interpr√©teur qui
supporte l&rsquo;√©valuation multi-facettes.  En revanche, la duplication de code a un
impact important sur la maintenance √† long terme: plus de double du code doit
√™tre maintenu.  Les changements requis dans le code source pour corriger un bug
dans Narcissus, ou pour ajouter une fonctionnalit√© doivent d√©sormais √™tre
r√©p√©t√©s dans l&rsquo;instrumentation.  Le co√ªt de maintenance devient prohibitif
lorsque <i>plusieurs</i> instrumentations sont envisag√©es.
</p>

<p>
En observant le diff de plus pr√®s, on peut distinguer quatre cat√©gories de
changements: les imports/exports, l&rsquo;ajout du param√®tre <i>program counter</i>,
s√©parer l&rsquo;√©valuation des valeurs √† facettes, et les ajouts √† l&rsquo;objet <code>global</code>.
</p>

<p>
De nouvelles d√©finitions ont besoin d&rsquo;√™tre import√©es dans le module de
l&rsquo;interpr√©teur, et une nouvelle fonction est export√©e.  Ce sont de simples
ajouts qui sont localis√©s en d√©but et en fin de fichier respectivement.  Voici
comment ils se pr√©sentent dans le code:
</p>

<div class="org-src-container">

<pre class="src src-diff">+ var FacetedValue = Zaphod.facets.FacetedValue;
+ var ProgramCounter = Zaphod.facets.ProgramCounter;
...

-      test: test
+      test: test,
+      getPC: getGC
</pre>
</div>

<aside style="margin-top:-11rem">
<p>
Le symbole <code>-</code> marque une ligne supprim√©e de l&rsquo;interpr√©teur; le symbole <code>+</code>
marque une ligne ajout√©e par l&rsquo;instrumentation.  L&rsquo;absence de marque indique une
ligne commune aux deux versions.
</p>
</aside>

<p>
Les changements effectu√©s pour accommoder le <i>program counter</i> utilis√© par
l&rsquo;analyse.  D&rsquo;abord, le constructeur de l&rsquo;objet <code>ExecutionContext</code> est √©tendu
pour accepter un argument suppl√©mentaire: la valeur courante du <i>program
counter</i>, <code>pc</code>.  Voici un extrait du diff qui illustre ce
changement:
</p>

<div class="org-src-container">

<pre class="src src-diff">- function ExecutionContext(type, version) {
+ function ExecutionContext(type, pc, version {
+   this.pc = pc;
</pre>
</div>

<p>
Dans Narcissus, une instance de l&rsquo;objet <code>ExecutionContext</code> est cr√©√©e lorsque le
contr√¥le est transf√©r√© √† du code client ex√©cutable: lors de l&rsquo;entr√©e dans une
fonction, lors d&rsquo;un appel √† <code>eval</code>, ou lors de l&rsquo;ex√©cution d&rsquo;un programme
entier.  L&rsquo;objet <code>ExecutionContext</code> contient les variables importantes pour
l&rsquo;ex√©cution du code; en particulier l&rsquo;environnement lexical utilis√© pour
r√©soudre les noms de variables du code ex√©cut√© par ce contexte.  L&rsquo;objet
<code>ExecutionContext</code> est une r√©ification du concept √©ponyme de la sp√©cification
ECMAScript.
</p>

<aside style="margin-top:-4rem">
<p>
Voir la section 10.3 de la sp√©cification.
</p>
</aside>

<p>
Puisque la signature du constructeur d&rsquo;<code>ExecutionContext</code> est √©tendue, tous ses
appels doivent √™tre modifi√©s en cons√©quence pour fournir une valeur correcte
pour le param√®tre <i>program counter</i>.  Il y a plus de 80 instances de ce simple
changement dans l&rsquo;instrumentation.  En voici deux exemples:
</p>

<div class="org-src-container">

<pre class="src src-diff">- x2 = new ExecutionContext(MODULE_CODE);
+ x2 = new ExecutionContext(MODULE_CODE, x.pc);

- getValue(execute(n.children[0], x));
+ getValue(execute(n.children[0], x), pc);
</pre>
</div>

<p>
Les changements effectu√©s dans l&rsquo;ex√©cution de l&rsquo;arbre de syntaxe abstrait (AST)
pour propager les √©tiquettes sur les valeurs √† facettes.  Par exemple,
additionner deux valeurs √† facettes devrait produire une nouvelle valeur √†
facettes.  Dans l&rsquo;impl√©mentation, plut√¥t que de simplement additionner les deux
op√©randes, l&rsquo;interpr√©teur doit maintenant d&rsquo;abord inspecter l&rsquo;op√©rande gauche,
et si c&rsquo;est une valeur √† facettes, il faudra ajouter la valeur de l&rsquo;op√©rande
droite √† chaque facette.  Bien s√ªr, l&rsquo;op√©rande droite peut √©galement √™tre une
valeur √† facettes, et il faut alors s√©parer l&rsquo;√©valuation √† nouveau.
L&rsquo;interpr√©teur Narcissus ne contient aucun code pour g√©rer l&rsquo;addition de deux
valeurs √† facettes, donc l&rsquo;instrumentation doit ajouter la logique n√©cessaire.
Pour ce faire, chaque √©valuation d&rsquo;une op√©ration est enrob√©e dans un appel √† la
fonction <code>evaluateEach</code> qui teste si une valeur est √† facettes, et appelle
r√©cursivement la fonction d&rsquo;√©valuation sur chaque facette si c&rsquo;est le cas.  25
appels √† <code>evaluateEach</code> ont √©t√© ainsi ajout√©s dans l&rsquo;instrumentation.  Le code
suivant donne la forme g√©n√©rale de ces changements:
</p>

<div class="org-src-container">

<pre class="src src-diff">- var v = getValue(node.a)
+ evaluteEach(getValue(node.a), function(v,x) {
    ... do something with v ...
+ }
</pre>
</div>

<p>
√Ä la premi√®re ligne on r√©cup√®re une valeur d&rsquo;un n≈ìud de l&rsquo;AST (p.ex., l&rsquo;op√©rande
gauche d&rsquo;une assignation, ou la condition d&rsquo;un <code>if</code>) puis on fait quelque chose
avec cette valeur.  Sur la seconde ligne, on r√©cup√®re la m√™me valeur, mais cette
fois on <i>s√©pare</i> l&rsquo;√©valuation en appelant <code>evaluateEach</code> avec cette valeur comme
premier argument, et comme second une fonction qui op√®re sur une valeur simple.
</p>

<p>
Les changements effectu√©s sur l&rsquo;environnement d&rsquo;ex√©cution de code client.  Dans
un programme JavaScript, l&rsquo;environnement d&rsquo;ex√©cution fournit un objet <code>global</code>
qui contient les d√©finitions de base comme <code>Array</code>, <code>Math</code>, <code>String</code> et
<code>Object</code>.  Puisque Narcissus est m√©tacirculaire, il r√©utilise l&rsquo;objet global de
son environnement h√¥te pour construire l&rsquo;objet global de l&rsquo;environnement client.
Ceci est fait en trois √©tapes.  Premi√®rement, Narcissus cr√©e un objet
<code>globalBase</code> avec les propri√©t√©s qui surchargeront celle de l&rsquo;environnement
h√¥te.  Deuxi√®mement, il cr√©e un objet <code>global</code> client √† partir de l&rsquo;objet
<code>global</code> de son environnement h√¥te, et met toutes les propri√©t√©s de <code>globalBase</code>
dans cet objet <code>global</code> client.  Troisi√®mement, il ajoute √† cet objet <code>global</code>
client les versions r√©fl√©chies de certains objets de base (<code>Array</code>, <code>String</code>,
<code>Function</code>).
</p>

<p>
L&rsquo;instrumentation de l&rsquo;√©valuation multi-facettes enrichit l&rsquo;objet <code>global</code>
client en ajoutant 50 propri√©t√©s √† <code>globalBase</code>, comme la suivante:
</p>

<div class="org-src-container">

<pre class="src src-diff">   var globalBase = {
   ...
+  isFacetedValue: function(v) {
+    return (v instanceof FacetedValue);
+  },
</pre>
</div>

<p>
L&rsquo;instrumentation change √©galement la propri√©t√© <code>String</code> de <code>globalBase</code> pour
suivre les valeurs √©tiquet√©es pass√©es en argument du constructeur de cha√Ænes de
caract√®res.
</p>

<p>
Le fait que la plupart des changements appartiennent √† une de ces quatre
cat√©gories indique qu&rsquo;il y a un potentiel de factorisation.  Si l&rsquo;on souhaite
rendre Narcissus extensibles, afin de pouvoir d√©finir l&rsquo;√©valuation
multi-facettes sans duplication de code, il faut trouver des fa√ßons d&rsquo;exprimer
les changements de ces quatre cat√©gories.  Mais si nous souhaites exprimer
d&rsquo;autres analyses, et √©tendre d&rsquo;autres interpr√©teurs, il faut tenter des trouver
des m√©canismes g√©n√©riques qui pourront √™tre r√©employ√©s pour ces autres cas.
</p>

<p>
Pour prendre un peu de recul par rapport √† l&rsquo;instrumentation de Narcissus, on
peut s&rsquo;int√©resser √† la d√©finition formelle de l&rsquo;√©valuation multi-facettes.
Celle-ci est donn√©e sous forme d&rsquo;une s√©mantique op√©rationnelle d&rsquo;un langage
proche du lambda-calcul: &lambda;<sup>facet</sup>.  La s√©mantique de ce langage est d&rsquo;abord donn√©e
sans consid√©rer l&rsquo;√©valuation multi-facettes, et suit une d√©finition usuelle d&rsquo;un
lambda-calcul en <i>call-by-value</i>; &lambda;<sup>facet</sup> contient en plus des constantes, des
r√©f√©rences mutables, et une valeur absorbante pour faire √©cho au <code>undefined</code> de
JavaScript.
</p>

<p>
Dans un second temps, une s√©mantique alternative est pr√©sent√©e qui introduit les
changements n√©cessaires pour l&rsquo;√©valuation multi-facettes.  Il s&rsquo;agit d&rsquo;une copie
de la premi√®re s√©mantique, avec quelques changements et ajouts.  On y retrouve
les deux des quatre cat√©gories de changements d√©gag√©es du diff.  Le <i>program
counter</i> accompagne chaque r√®gle d&rsquo;√©valuation, et de nouvelles r√®gles sont
ajout√©es pour s√©parer l&rsquo;√©valuation de valeurs √† facette en deux parties.
</p>

<p>
Les r√®gles de la s√©mantique instrument√©es tiennent sur une page; un
interpr√©teur pour cette s√©mantique est donc consid√©rablement plus petit qu&rsquo;un
interpr√©teur JavaScript complet, ce qui en fait un excellent choix pour tester
des m√©canismes d&rsquo;extensibilit√©.
</p>
</div>
</div>

<div id="outline-container-orgheadline61" class="outline-2">
<h2 id="orgheadline61"><span class="section-number-2">4</span> <span class="todo UNSTABLE">UNSTABLE</span> Variations sur un interpr√©teur de lambda-calcul extensible</h2>
<div class="outline-text-2" id="text-4">
<p>
Essayons d&rsquo;abord d&rsquo;√©crire un interpr√©teur pour chaque s√©mantique de &lambda;<sup>facet</sup>, sans
anticiper l&rsquo;instrumentation; c&rsquo;est √† dire sans se pr√©occuper de pouvoir √©tendre
l&rsquo;interpr√©teur facilement.
</p>

<p>
Nous appellerons &lambda;<sup>standard</sup> le langage d√©crit par la premi√®re s√©mantique d&rsquo;Austin
et Flanagan, qui correspond √† un lambda-calcul avec r√©f√©rences, et &lambda;<sup>facet</sup> le
langage √©tendu pour l&rsquo;√©valuation multi-facettes.
</p>

<p>
Puisque Narcissus est en JavaScript, et suit le patron <i>module</i>, √©crivons un
interpr√©teur de &lambda;<sup>standard</sup> dans le m√™me style.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">interpreter</span> = (<span style="font-weight: bold;">function</span>(){
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">bottom</span> = {...}
  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">Address</span>() {...}
  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">FunctionObject</span>() {...}

  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ExecutionContext</span>(<span style="font-weight: bold; font-style: italic;">parent</span>) {
    ...
    <span style="font-weight: bold; text-decoration: underline;">this</span>.scope = {}
    <span style="font-weight: bold; text-decoration: underline;">this</span>.store = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Store</span>()
  }

  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">execute</span>(<span style="font-weight: bold; font-style: italic;">node</span>, <span style="font-weight: bold; font-style: italic;">context</span>) {
    <span style="font-weight: bold;">switch</span> (node.type) {
    <span style="font-weight: bold;">case</span> <span style="font-style: italic;">'CONST'</span>:  ...
    <span style="font-weight: bold;">case</span> <span style="font-style: italic;">'VAR'</span>:    ...
    <span style="font-weight: bold;">case</span> <span style="font-style: italic;">'FUN'</span>:    ...
    <span style="font-weight: bold;">case</span> <span style="font-style: italic;">'APP'</span>:    ...
    ...
    }
  }

  <span style="font-weight: bold;">return</span> {
    run: run,
  }
}())
</pre>
</div>

<p>
Ce simple interpr√©teur refl√®te la structure de Narcissus, mais est bien plus
succinct.  Comme dans Narcissus, le gros de la logique de l&rsquo;interpr√©teur r√©side
dans la fonction <code>execute</code>.  Les d√©finitions qui pr√©c√®dent r√©ifient des objets
de la sp√©cification: <code>Address</code>, <code>bottom</code>, <code>FunctionObject</code>.  On r√©utilise le nom
<code>ExecutionContext</code> pour indiquer l&rsquo;objet qui contient l&rsquo;environnement de
variable et qui est pass√© au fil des appels r√©cursifs √† <code>execute</code>.  En bas ce
sont les fonctions export√©es par le module.
</p>

<p>
On peut maintenant modifier cet interpr√©teur pour impl√©menter la seconde
s√©mantique de &lambda;<sup>facet</sup>.  Comme pour l&rsquo;instrumentation de Narcissus, on part de
l&rsquo;interpr√©teur du langage standard, qu&rsquo;on modifie par endroits suivant les
besoins de la nouvelle s√©mantique.  L&rsquo;id√©e ici n&rsquo;est pas de construire un
interpr√©teur extensible, mais d&rsquo;identifier les points qui vont varier en
d√©finissant cette variation.  Pour cela, on s&rsquo;int√©resse surtout aux diff√©rences
entre les deux versions.
</p>

<div class="org-src-container">
<label class="org-src-name">Diff simplifi√© qui illustre les modifications n√©cessaires pour l&rsquo;interpr√©teur &lambda;<sup>facet</sup>.</label>
<pre class="src src-diff">+ function Facet() {...}

+ function evaluateEach() {...}

  function ExecutionContext() {
+   this.pc = []
  }

  function execute(...) {
    ...
    case CALL:
-     v = f._call(a, context)
+     v = evaluateEach(f, context, (f, x) =&gt; f._call(a, x))

    case REF:
+     v = constructFacet(context.pc, v, bottom)

    case DEREF:
-     v = a.deref(context)
+     v = evaluateEach(a, context, (a, x) =&gt; a.deref(x))
  ...
  }

  return {
    ...
+   runWithPC: runWithPC,
  }
</pre>
</div>

<p>
Il y a moins de diff√©rences que pour l&rsquo;instrumentation de Narcissus, mais on
retrouve trois des m√™mes cat√©gories.  D&rsquo;abord, il y a de nouvelles d√©finitions
pour les valeurs √† facettes et leur √©valuation (<code>Facet</code> et <code>evaluateEach</code>).  La
fonction <code>evaluateEach</code> est utilis√©e, comme dans l&rsquo;instrumentation de Narcissus,
pour √©valuer les deux parties d&rsquo;une valeur √† facettes r√©cursivement.  Le program
counter est pr√©sent, et rajout√© √† l&rsquo;objet <code>ExecutionContext</code> pour pouvoir √™tre
utilis√© dans <code>execute</code>.  Enfin, une nouvelle fonction est export√©e par le
module.  La seule cat√©gorie non repr√©sent√©e est l&rsquo;extension de l&rsquo;objet client
global, car il n&rsquo;y a pas d&rsquo;√©quivalent √† l&rsquo;objet global dans &lambda;<sup>facet</sup>.
</p>

<p>
Puisqu&rsquo;on retrouve les m√™mes cat√©gories de changement sur cet exemple plus
restreint, on peut supposer que si l&rsquo;on trouve des moyens d&rsquo;instrumenter
l&rsquo;interpr√©teur de &lambda;<sup>standard</sup> pour l&rsquo;√©valuation √† facettes sans duplication de
code, ces moyens seront applicables √† Narcissus √©galement.
</p>

<p>
Il est clair que les choix d&rsquo;impl√©mentation de l&rsquo;interpr√©teur standard sont la
cause de la duplication de code dans l&rsquo;instrumentation.  Si l&rsquo;interpr√©teur
poss√©dait une interface pour √™tre √©tendu, nous n&rsquo;aurions pas besoin de dupliquer
le code pour changer ces quelques lignes.  Comment aurions nous d√ª <i>construire</i>
l&rsquo;interpr√©teur pour que l&rsquo;extension requise par &lambda;<sup>facet</sup> puisse √™tre √©crite en
minimisant le code dupliqu√© ?  Ou encore, est-il possible de <i>modifier</i>
l&rsquo;interpr√©teur standard pour le rendre extensible ?  Ce sont les deux questions
que nous explorons par la suite.
</p>
</div>
</div>

<div id="outline-container-orgheadline100" class="outline-2">
<h2 id="orgheadline100"><span class="section-number-2">5</span> <span class="todo TRANSLATE">TRANSLATE</span> Construire un interpr√©teur extensible</h2>
<div class="outline-text-2" id="text-5">
<p>
Le style de l&rsquo;interpr√©teur du chapitre pr√©c√©dent n&rsquo;est pas extensible.
L&rsquo;interpr√©teur suit le patron module en JavaScript, qui a pour intention de
verrouiller les d√©finitions du module contre toute extension future; qu&rsquo;elles
soient intentionnelles ou accidentelles (le chapitre ?? d√©crit en d√©tail le
fonctionnement de ce patron).
</p>

<p>
Mais ce n&rsquo;est pas la seule fa√ßon d&rsquo;√©crire l&rsquo;interpr√©teur en JavaScript.  On peut
tr√®s bien suivre un style inspir√© de la programmation objet.  Le patron
<i>interpr√©teur</i> [<a href="#GHJ+94">GHJ+94</a>] est d&rsquo;ailleurs un bon candidat: chaque n≈ìud de l&rsquo;arbre de
syntaxe est un objet, et contient une m√©thode <code>interpret</code>.  Le <code>switch</code> de la
fonction <code>execute</code> de Narcissus est donc s√©par√© en morceaux ind√©pendants: chaque
n≈ìud poss√®de le code qui permet d&rsquo;√©valuer sa valeurs et ses effets.
</p>

<p>
√âcrivons un interpr√©teur pour &lambda;<sup>standard</sup> dans ce style.  D&rsquo;abord, les objets qui
r√©ifient les n≈ìuds de l&rsquo;AST:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">stdInterp</span> = {
  CONST: {
    <span style="font-weight: bold;">new</span>(e) {...},
    execute(context) {...}},

  VAR: {
    <span style="font-weight: bold;">new</span>(e) {...},
    execute(context) {...}},

  FUN: {
    <span style="font-weight: bold;">new</span>(argName, body) {...},
    execute(context) {...}},

  APP: {
    <span style="font-weight: bold;">new</span>(fun, arg) {...},
    execute(context) {...}},
</pre>
</div>

<p>
Chaque objet a deux m√©thodes: une pour l&rsquo;instancier, et une pour √©valuer le n≈ìud
de l&rsquo;AST.  Les m√©thodes <code>execute</code> contiennent la m√™me logique que les <code>case</code> du
<code>switch</code> de l&rsquo;interpr√©teur dans le style de Narcissus.
</p>

<p>
Les objets de l&rsquo;ex√©cution subissent la m√™me transformation:
</p>

<div class="org-src-container">

<pre class="src src-js">Address: {
  <span style="font-weight: bold;">new</span>(a) {...},
  deref(context) {...},
},

ExecutionContext: {
  <span style="font-weight: bold;">new</span>(scope, store) {...},
},

Store: {
  <span style="font-weight: bold;">new</span>() {...},
  add(value) {...},
  retrieve(addr) {...},
},

FunctionObject: {
  <span style="font-weight: bold;">new</span>(node, scope) {...},
  _call(arg, x) {...},
},
</pre>
</div>

<p>
Et enfin, la fonction d&rsquo;entr√©e de l&rsquo;interpr√©teur, <code>run</code>, peut simplement appeler
la m√©thode <code>execute</code> sur la racine de l&rsquo;AST.
</p>

<div class="org-src-container">

<pre class="src src-js">  run(node) {
    <span style="font-weight: bold;">return</span> node.execute(<span style="font-weight: bold; text-decoration: underline;">this</span>.ExecutionContext.<span style="font-weight: bold;">new</span>())
  },
})
</pre>
</div>

<p>
L&rsquo;int√©r√™t de cette d√©composition c&rsquo;est qu&rsquo;on peut maintenant facilement cr√©er
une variante de l&rsquo;interpr√©teur gr√¢ce √† la d√©l√©gation par prototype de
JavaScript:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">fctInterp</span> = derive(stdInterp, {
  APP: derive(stdInterp.APP, {
    execute(context) {
      ...
      <span style="font-weight: bold;">return</span> evaluateEach(...) }})

  REF: derive(stdInterp.REF, {
    execute(context) {
      ...
      <span style="font-weight: bold;">return</span> constructFacet(...) }}),

  DEREF: derive(stdInterp.DEREF, {
    execute(context) {
      <span style="font-weight: bold;">return</span> evaluateEach(...) }}),

  ExecutionContext: derive(stdInterp.ExecutionContext, {
    <span style="font-weight: bold;">new</span>(scope, store, pc) {...}
  }),

  runWithPC(node, pc) {...},
})
</pre>
</div>

<p>
Ici, <code>fctInterp</code> a pour prototype <code>stdInterp</code>, donc toute propri√©t√© non pr√©sente
sur <code>fctInterp</code> sera prise de <code>stdInterp</code>.  Inversement, la propri√©t√© <code>APP</code> est
d√©finie sur <code>fctInterp</code>, donc elle &laquo;&nbsp;surcharge&nbsp;&raquo; la propri√©t√© <code>APP</code> de
<code>stdInterp</code>.  La d√©l√©gation par prototype est un m√©canisme bien adapt√© √† notre
probl√®me, car on souhaite que le code de <code>fctInterp</code> exprime la <i>diff√©rence</i> de
l&rsquo;√©valuation de &lambda;<sup>facet</sup>, et seulement cette diff√©rence.  Dans un langage √†
prototype, un objet n&rsquo;est pas instanci√© √† partir d&rsquo;une classe, mais <i>d√©riv√©</i>
d&rsquo;un prototype.  Un objet d√©riv√© n&rsquo;a besoin que de d√©finir en quoi il diff√®re de
son prototype.  C&rsquo;est donc un m√©canisme de langage id√©al pour notre sc√©nario
avec deux interpr√©teurs.
</p>


<figure id="orgparagraph2">
<p><img src="img/lamfa-proto.svg" alt="lamfa-proto.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;26&nbsp;:</span> D√©finition d&rsquo;un interpr√©teur en utilisant la d√©l√©gation par prototype.  L&rsquo;objet <code>fctInterp</code> poss√®de une unique propri√©t√© propre: <code>APP</code>.  Les autres propri√©t√©s sont d√©l√©gu√©es √† son prototype, <code>stdInterp</code>.</figcaption>
</figure>

<p>
L&rsquo;interpr√©teur de &lambda;<sup>facet</sup> peut donc √™tre d√©fini uniquement en codant les
diff√©rences entre ces deux modes d&rsquo;interpr√©tation.  Les deux objets <code>stdInterp</code>
et <code>fctInterp</code> coexistent √† l&rsquo;ex√©cution, ce qui permet de pouvoir choisir entre
l&rsquo;une ou l&rsquo;autre interpr√©tation pour un m√™me programme.
</p>
</div>

<div id="outline-container-orgheadline62" class="outline-4">
<h4 id="orgheadline62"><span class="section-number-4">5.0.1</span> Finding a core example</h4>
<div class="outline-text-4" id="text-5-0-1">
<p>
Looking at the operational semantics for faceted evaluation, we can
see the patterns mentioned previously (<code>pc</code> parameter, new cases for
<code>FacetedValues</code>).  They are based on a lambda calculus variant, with
references and a &laquo;&nbsp;Bottom&nbsp;&raquo; value.  Let&rsquo;s try to write an interpreter
for this lambda calculus without anticipating the later
instrumentation.
</p>

<p>
We&rsquo;ll drop the read/write rules since they only add noise to this
example.  We&rsquo;ll also leave out error handling.
</p>

<p>
<a href="js/lab/lamfa-es6-standard.js">js/lab/lamfa-es6-standard.js</a>
</p>
<div class="org-src-container">

<pre class="src src-js">Set.<span style="font-weight: bold; text-decoration: underline;">prototype</span>.union = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">elem</span>) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(<span style="font-weight: bold; text-decoration: underline;">this</span>);
  n.add(elem);
  <span style="font-weight: bold;">return</span> n;
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretNode</span>(&#963;, &#952;, node) {
  <span style="font-weight: bold;">return</span> rules[node.type](&#963;, &#952;, node);
}

<span style="font-weight: bold;">let</span> &#8582; = interpretNode;

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">bottom</span> = {type: <span style="font-style: italic;">'bottom'</span>};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">closure</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>, &#952;) { <span style="font-weight: bold;">return</span> {<span style="font-weight: bold; font-style: italic;">type</span>: <span style="font-style: italic;">'closure'</span>, <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>, &#952;}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">address</span>(<span style="font-weight: bold; font-style: italic;">a</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'address'</span>, a}; }

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_apply</span>(&#963;, v1, v2) {
  <span style="font-weight: bold;">return</span> application_rules[v1.type](&#963;, v1, v2);
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">application_rules</span> = {
  bottom(&#963;) {
    <span style="font-weight: bold;">return</span> [&#963;, bottom];
  },

  closure(&#963;, {x, e, &#952;}, v) {
    <span style="font-weight: bold;">let</span> &#952;1 = Object.create(&#952;);
    &#952;1[x] = v;
    <span style="font-weight: bold;">return</span> &#8582;(&#963;, &#952;1, e);
  },
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_deref</span>(&#963;, v) {
  <span style="font-weight: bold;">return</span> deref_rules[v.type](&#963;, v);
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">deref_rules</span> = {
  bottom() {
    <span style="font-weight: bold;">return</span> bottom;
  },

  address(&#963;, {a}) {
    <span style="font-weight: bold;">return</span> &#963;[a];
  },
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_assign</span>(&#963;, v1, v2) {
  <span style="font-weight: bold;">return</span> assign_rules[v1.type](&#963;, v1, v2);
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">assign_rules</span> = {
  bottom(&#963;) {
    <span style="font-weight: bold;">return</span> &#963;;
  },

  address(&#963;, {a}, v) {
    <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;);
    &#963;2[a] = v;
    <span style="font-weight: bold;">return</span> &#963;2;
  },
};

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">rules</span> = {
  c(&#963;, &#952;, {e}) {
    <span style="font-weight: bold;">return</span> [ &#963;, e ];
  },

  v(&#963;, &#952;, {e}) {
    <span style="font-weight: bold;">return</span> [ &#963;, &#952;[e] ];
  },

  fun(&#963;, &#952;, {x, e}) {
    <span style="font-weight: bold;">return</span> [ &#963;, closure(x, e, &#952;) ];
  },

  app(&#963;, &#952;, {e1, e2}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v1] = &#8582;(&#963;, &#952;, e1);
    <span style="font-weight: bold;">let</span> [&#963;2, v2] = &#8582;(&#963;1, &#952;, e2);
    <span style="font-weight: bold;">return</span> eval_apply(&#963;2, v1, v2);
  },

  ref(&#963;, &#952;, {e}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v] = &#8582;(&#963;, &#952;, e);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
    <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
    &#963;2[a] = v;
    <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
  },

  deref(&#963;, &#952;, {e}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v] = &#8582;(&#963;, &#952;, e);
    <span style="font-weight: bold;">return</span> [ &#963;1, eval_deref(&#963;1, v) ];
  },

  assign(&#963;, &#952;, {e1, e2}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v1] = &#8582;(&#963;, &#952;, e1);
    <span style="font-weight: bold;">let</span> [&#963;2, v2] = &#8582;(&#963;1, &#952;, e2);
    <span style="font-weight: bold;">return</span> [ eval_assign(&#963;2, v1, v2), v2 ];
  },
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretProgram</span>(<span style="font-weight: bold; font-style: italic;">AST</span>, <span style="font-weight: bold; font-style: italic;">env</span> = {}, <span style="font-weight: bold; font-style: italic;">store</span> = {}) {
  <span style="font-weight: bold;">return</span> interpretNode(env, store, AST);
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Test</span>
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">app</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'app'</span>, e1, e2}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">fun</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'fun'</span>, x, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'ref'</span>, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">deref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'deref'</span>, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">c</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'c'</span>, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">v</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'v'</span>, e}; }

interpretProgram(
  app(fun(<span style="font-style: italic;">'x'</span>, deref(v(<span style="font-style: italic;">'x'</span>))),
      ref(c(42)))
);
</pre>
</div>

<p>
We used destructuring from ES6 and Unicode identifiers to approximate
the appearance of the big-step semantics.  To effect the operational
rules, we use an ad-hoc pattern matching.  Each AST node is an object
with a <code>type</code> field, and the <code>interpNode</code> function dispatches to the
function in the <code>rules</code> object corresponding to the value of this type
field.  The same pattern matching mechanism is used to distinguish
between an address, a closure or a bottom value.
</p>

<p>
We can easily instrument this base interpreter by following the
operational semantics from Austin and Flanagan.
</p>

<p>
<a href="js/lab/lamfa-es6-facets.js">js/lab/lamfa-es6-facets.js</a>
</p>
<div class="org-src-container">

<pre class="src src-js">Set.<span style="font-weight: bold; text-decoration: underline;">prototype</span>.union = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">elem</span>) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(<span style="font-weight: bold; text-decoration: underline;">this</span>);
  n.add(elem);
  <span style="font-weight: bold;">return</span> n;
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretNode</span>(&#963;, &#952;, pc, node) {
  <span style="font-weight: bold;">return</span> rules[node.type](&#963;, &#952;, pc, node);
}

<span style="font-weight: bold;">let</span> &#8582; = interpretNode;

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">bottom</span> = {type: <span style="font-style: italic;">'bottom'</span>};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">mk_facet</span>(<span style="font-weight: bold; font-style: italic;">pc</span>, <span style="font-weight: bold; font-style: italic;">v1</span>, <span style="font-weight: bold; font-style: italic;">v2</span>) {
  <span style="font-weight: bold;">if</span> (pc.size === 0)
    <span style="font-weight: bold;">return</span> v1;

  <span style="font-weight: bold;">let</span> [k, ...rest] = pc;
  rest = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(rest);

  <span style="font-weight: bold;">if</span> (k &gt; 0)
    <span style="font-weight: bold;">return</span> facet(k, mk_facet(rest, v1, v2), v2);
  <span style="font-weight: bold;">else</span>
    <span style="font-weight: bold;">return</span> facet(k, v2, mk_facet(rest, v1, v2));
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">facet</span>(<span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; font-style: italic;">vh</span>, <span style="font-weight: bold; font-style: italic;">vl</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'facet'</span>, k, vh, vl}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">closure</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>, &#952;) { <span style="font-weight: bold;">return</span> {<span style="font-weight: bold; font-style: italic;">type</span>: <span style="font-style: italic;">'closure'</span>, <span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>, &#952;}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">address</span>(<span style="font-weight: bold; font-style: italic;">a</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'address'</span>, a}; }

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_apply</span>(&#963;, pc, v1, v2) {
  <span style="font-weight: bold;">return</span> application_rules[v1.type](&#963;, pc, v1, v2);
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">application_rules</span> = {
  bottom(&#963;) {
    <span style="font-weight: bold;">return</span> [&#963;, bottom];
  },

  closure(&#963;, pc, {x, e, &#952;}, v) {
    <span style="font-weight: bold;">let</span> &#952;1 = Object.create(&#952;);
    &#952;1[x] = v;
    <span style="font-weight: bold;">return</span> &#8582;(&#963;, &#952;1, pc, e);
  },

  facet(&#963;, pc, {k, vh, vl}, v2) {
    <span style="font-weight: bold;">if</span> (pc.has(k)) {
      <span style="font-weight: bold;">return</span> eval_apply(&#963;, pc, vh, v2);
    }

    <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (pc.has(-k)) {
      <span style="font-weight: bold;">return</span> eval_apply(&#963;, pc, vl, v2);
    }

    <span style="font-weight: bold;">else</span> {
      <span style="font-weight: bold;">let</span> [&#963;1, vh1] = eval_apply(&#963;, pc.union(k), vh, v2);
      <span style="font-weight: bold;">let</span> [&#963;2, vl1] = eval_apply(&#963;1, pc.union(-k), vl, v2);
      <span style="font-weight: bold;">return</span> [ &#963;2, mk_facet(k, vh1, vl1) ];
    }
  },
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_deref</span>(&#963;, v, pc) {
  <span style="font-weight: bold;">return</span> deref_rules[v.type](&#963;, v, pc);
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">deref_rules</span> = {
  bottom() {
    <span style="font-weight: bold;">return</span> bottom;
  },

  address(&#963;, {a}, pc) {
    <span style="font-weight: bold;">return</span> &#963;[a];
  },

  facet(&#963;, {k, vh, vl}, pc) {
    <span style="font-weight: bold;">if</span> (pc.has(k))
      <span style="font-weight: bold;">return</span> eval_deref(&#963;, vh, pc);
    <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (pc.has(-k))
      <span style="font-weight: bold;">return</span> eval_deref(&#963;, vl, pc);
    <span style="font-weight: bold;">else</span>
      <span style="font-weight: bold;">return</span> mk_facet(k, eval_deref(&#963;, vh, pc), eval_deref(&#963;, vl, pc));
  },
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_assign</span>(&#963;, pc, v1, v2) {
  <span style="font-weight: bold;">return</span> assign_rules[v1.type](&#963;, pc, v1, v2);
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">assign_rules</span> = {
  bottom(&#963;) {
    <span style="font-weight: bold;">return</span> &#963;;
  },

  address(&#963;, pc, {a}, v) {
    <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;);
    &#963;2[a] = mk_facet(pc, v, &#963;[a]);
    <span style="font-weight: bold;">return</span> &#963;2;
  },

  facet(&#963;, pc, {k, vh, vl}, v) {
    <span style="font-weight: bold;">let</span> &#963;1 = eval_assign(&#963;, pc.union(k), vh, v);
    <span style="font-weight: bold;">return</span> eval_assign(&#963;1, pc.union(-k), vl, v);
  },
};

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">rules</span> = {
  c(&#963;, &#952;, pc, {e}) {
    <span style="font-weight: bold;">return</span> [ &#963;, e ];
  },

  v(&#963;, &#952;, pc, {e}) {
    <span style="font-weight: bold;">return</span> [ &#963;, &#952;[e] ];
  },

  fun(&#963;, &#952;, pc, {x, e}) {
    <span style="font-weight: bold;">return</span> [ &#963;, closure(x, e, &#952;) ];
  },

  app(&#963;, &#952;, pc, {e1, e2}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v1] = &#8582;(&#963;, &#952;, pc, e1);
    <span style="font-weight: bold;">let</span> [&#963;2, v2] = &#8582;(&#963;1, &#952;, pc, e2);
    <span style="font-weight: bold;">return</span> eval_apply(&#963;2, pc, v1, v2);
  },

  ref(&#963;, &#952;, pc, {e}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v] = &#8582;(&#963;, &#952;, pc, e);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
    <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
    &#963;2[a] = mk_facet(pc, v, bottom);
    <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
  },

  deref(&#963;, &#952;, pc, {e}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v] = &#8582;(&#963;, &#952;, pc, e);
    <span style="font-weight: bold;">return</span> [ &#963;1, eval_deref(&#963;1, v, pc) ];
  },

  assign(&#963;, &#952;, pc, {e1, e2}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v1] = &#8582;(&#963;, &#952;, pc, e1);
    <span style="font-weight: bold;">let</span> [&#963;2, v2] = &#8582;(&#963;1, &#952;, pc, e2);
    <span style="font-weight: bold;">return</span> [ eval_assign(&#963;2, pc, v1, v2), v2 ];
  },
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretProgram</span>(<span style="font-weight: bold; font-style: italic;">AST</span>, <span style="font-weight: bold; font-style: italic;">env</span> = {}, <span style="font-weight: bold; font-style: italic;">store</span> = {}, <span style="font-weight: bold; font-style: italic;">pc</span> = []) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pc</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(pc);
  <span style="font-weight: bold;">return</span> interpretNode(env, store, pc, AST);
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Test</span>
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">app</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'app'</span>, e1, e2}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">fun</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'fun'</span>, x, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'ref'</span>, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">deref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'deref'</span>, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">c</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'c'</span>, e}; }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">v</span>(<span style="font-weight: bold; font-style: italic;">e</span>) { <span style="font-weight: bold;">return</span> {type: <span style="font-style: italic;">'v'</span>, e}; }

interpretProgram(
  app(fun(<span style="font-style: italic;">'x'</span>, deref(v(<span style="font-style: italic;">'x'</span>))),
      ref(c(42))),
  {}, {}, [1]
);
</pre>
</div>

<p>
The interesting story is told by looking at the differences between
these two versions.  We see patterns 1 and 2 reappear from our
analysis of the Narcissus instrumentation.  The <code>pc</code> parameter must be
passed around in nearly every function, and new cases must be added to
handle facet values.
</p>

<div class="org-src-container">

<pre class="src src-sh">diff js/lab/lamfa-es6-standard.js js/lab/lamfa-es6-facets.js; <span style="font-weight: bold;">exit</span> 0
</pre>
</div>

<div class="org-src-container">

<pre class="src src-diff"><span style="font-weight: bold;">7,8c7,8</span>
&lt; function interpretNode(&#963;, &#952;, node) {
&lt;   return rules[node.type](&#963;, &#952;, node);
<span style="font-weight: bold;">---</span>
&gt; function interpretNode(&#963;, &#952;, pc, node) {
&gt;   return rules[node.type](&#963;, &#952;, pc, node);
<span style="font-weight: bold;">14a15,28</span>
&gt; function mk_facet(pc, v1, v2) {
&gt;   if (pc.size === 0)
&gt;     return v1;
&gt;
&gt;   let [k, ...rest] = pc;
&gt;   rest = new Set(rest);
&gt;
&gt;   if (k &gt; 0)
&gt;     return facet(k, mk_facet(rest, v1, v2), v2);
&gt;   else
&gt;     return facet(k, v2, mk_facet(rest, v1, v2));
&gt; }
&gt;
&gt; function facet(k, vh, vl) { return {type: 'facet', k, vh, vl}; }
<span style="font-weight: bold;">18,19c32,33</span>
&lt; function eval_apply(&#963;, v1, v2) {
&lt;   return application_rules[v1.type](&#963;, v1, v2);
<span style="font-weight: bold;">---</span>
&gt; function eval_apply(&#963;, pc, v1, v2) {
&gt;   return application_rules[v1.type](&#963;, pc, v1, v2);
<span style="font-weight: bold;">27c41</span>
&lt;   closure(&#963;, {x, e, &#952;}, v) {
<span style="font-weight: bold;">---</span>
&gt;   closure(&#963;, pc, {x, e, &#952;}, v) {
<span style="font-weight: bold;">30c44,60</span>
&lt;     return &#8582;(&#963;, &#952;1, e);
<span style="font-weight: bold;">---</span>
&gt;     return &#8582;(&#963;, &#952;1, pc, e);
&gt;   },
&gt;
&gt;   facet(&#963;, pc, {k, vh, vl}, v2) {
&gt;     if (pc.has(k)) {
&gt;       return eval_apply(&#963;, pc, vh, v2);
&gt;     }
&gt;
&gt;     else if (pc.has(-k)) {
&gt;       return eval_apply(&#963;, pc, vl, v2);
&gt;     }
&gt;
&gt;     else {
&gt;       let [&#963;1, vh1] = eval_apply(&#963;, pc.union(k), vh, v2);
&gt;       let [&#963;2, vl1] = eval_apply(&#963;1, pc.union(-k), vl, v2);
&gt;       return [ &#963;2, mk_facet(k, vh1, vl1) ];
&gt;     }
<span style="font-weight: bold;">34,35c64,65</span>
&lt; function eval_deref(&#963;, v) {
&lt;   return deref_rules[v.type](&#963;, v);
<span style="font-weight: bold;">---</span>
&gt; function eval_deref(&#963;, v, pc) {
&gt;   return deref_rules[v.type](&#963;, v, pc);
<span style="font-weight: bold;">43c73</span>
&lt;   address(&#963;, {a}) {
<span style="font-weight: bold;">---</span>
&gt;   address(&#963;, {a}, pc) {
<span style="font-weight: bold;">45a76,84</span>
&gt;
&gt;   facet(&#963;, {k, vh, vl}, pc) {
&gt;     if (pc.has(k))
&gt;       return eval_deref(&#963;, vh, pc);
&gt;     else if (pc.has(-k))
&gt;       return eval_deref(&#963;, vl, pc);
&gt;     else
&gt;       return mk_facet(k, eval_deref(&#963;, vh, pc), eval_deref(&#963;, vl, pc));
&gt;   },
<span style="font-weight: bold;">48,49c87,88</span>
&lt; function eval_assign(&#963;, v1, v2) {
&lt;   return assign_rules[v1.type](&#963;, v1, v2);
<span style="font-weight: bold;">---</span>
&gt; function eval_assign(&#963;, pc, v1, v2) {
&gt;   return assign_rules[v1.type](&#963;, pc, v1, v2);
<span style="font-weight: bold;">57c96</span>
&lt;   address(&#963;, {a}, v) {
<span style="font-weight: bold;">---</span>
&gt;   address(&#963;, pc, {a}, v) {
<span style="font-weight: bold;">59c98</span>
&lt;     &#963;2[a] = v;
<span style="font-weight: bold;">---</span>
&gt;     &#963;2[a] = mk_facet(pc, v, &#963;[a]);
<span style="font-weight: bold;">61a101,105</span>
&gt;
&gt;   facet(&#963;, pc, {k, vh, vl}, v) {
&gt;     let &#963;1 = eval_assign(&#963;, pc.union(k), vh, v);
&gt;     return eval_assign(&#963;1, pc.union(-k), vl, v);
&gt;   },
<span style="font-weight: bold;">65c109</span>
&lt;   c(&#963;, &#952;, {e}) {
<span style="font-weight: bold;">---</span>
&gt;   c(&#963;, &#952;, pc, {e}) {
<span style="font-weight: bold;">69c113</span>
&lt;   v(&#963;, &#952;, {e}) {
<span style="font-weight: bold;">---</span>
&gt;   v(&#963;, &#952;, pc, {e}) {
<span style="font-weight: bold;">73c117</span>
&lt;   fun(&#963;, &#952;, {x, e}) {
<span style="font-weight: bold;">---</span>
&gt;   fun(&#963;, &#952;, pc, {x, e}) {
<span style="font-weight: bold;">77,80c121,124</span>
&lt;   app(&#963;, &#952;, {e1, e2}) {
&lt;     let [&#963;1, v1] = &#8582;(&#963;, &#952;, e1);
&lt;     let [&#963;2, v2] = &#8582;(&#963;1, &#952;, e2);
&lt;     return eval_apply(&#963;2, v1, v2);
<span style="font-weight: bold;">---</span>
&gt;   app(&#963;, &#952;, pc, {e1, e2}) {
&gt;     let [&#963;1, v1] = &#8582;(&#963;, &#952;, pc, e1);
&gt;     let [&#963;2, v2] = &#8582;(&#963;1, &#952;, pc, e2);
&gt;     return eval_apply(&#963;2, pc, v1, v2);
<span style="font-weight: bold;">83,84c127,128</span>
&lt;   ref(&#963;, &#952;, {e}) {
&lt;     let [&#963;1, v] = &#8582;(&#963;, &#952;, e);
<span style="font-weight: bold;">---</span>
&gt;   ref(&#963;, &#952;, pc, {e}) {
&gt;     let [&#963;1, v] = &#8582;(&#963;, &#952;, pc, e);
<span style="font-weight: bold;">87c131</span>
&lt;     &#963;2[a] = v;
<span style="font-weight: bold;">---</span>
&gt;     &#963;2[a] = mk_facet(pc, v, bottom);
<span style="font-weight: bold;">91,93c135,137</span>
&lt;   deref(&#963;, &#952;, {e}) {
&lt;     let [&#963;1, v] = &#8582;(&#963;, &#952;, e);
&lt;     return [ &#963;1, eval_deref(&#963;1, v) ];
<span style="font-weight: bold;">---</span>
&gt;   deref(&#963;, &#952;, pc, {e}) {
&gt;     let [&#963;1, v] = &#8582;(&#963;, &#952;, pc, e);
&gt;     return [ &#963;1, eval_deref(&#963;1, v, pc) ];
<span style="font-weight: bold;">96,99c140,143</span>
&lt;   assign(&#963;, &#952;, {e1, e2}) {
&lt;     let [&#963;1, v1] = &#8582;(&#963;, &#952;, e1);
&lt;     let [&#963;2, v2] = &#8582;(&#963;1, &#952;, e2);
&lt;     return [ eval_assign(&#963;2, v1, v2), v2 ];
<span style="font-weight: bold;">---</span>
&gt;   assign(&#963;, &#952;, pc, {e1, e2}) {
&gt;     let [&#963;1, v1] = &#8582;(&#963;, &#952;, pc, e1);
&gt;     let [&#963;2, v2] = &#8582;(&#963;1, &#952;, pc, e2);
&gt;     return [ eval_assign(&#963;2, pc, v1, v2), v2 ];
<span style="font-weight: bold;">103,104c147,149</span>
&lt; function interpretProgram(AST, env = {}, store = {}) {
&lt;   return interpretNode(env, store, AST);
<span style="font-weight: bold;">---</span>
&gt; function interpretProgram(AST, env = {}, store = {}, pc = []) {
&gt;   let pc = new Set(pc);
&gt;   return interpretNode(env, store, pc, AST);
<span style="font-weight: bold;">117c162,163</span>
&lt;       ref(c(42)))
<span style="font-weight: bold;">---</span>
&gt;       ref(c(42))),
&gt;   {}, {}, [1]
</pre>
</div>

<p>
Our ad-hoc pattern matching is perhaps not the most straightforward way to write
such an interpreter in JavaScript.  Another, maybe more familiar way is to use
object-oriented dispatching.
</p>

<aside>
<p>
And indeed, this form is quite similar to the Interpreter pattern from [<a href="#GHJ+94">GHJ+94</a>].
</p>
</aside>

<p>
<a href="js/lab/lamfa-oo-standard.js">js/lab/lamfa-oo-standard.js</a>
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">bottom</span> = {
  eval_apply(&#963;) {
    <span style="font-weight: bold;">return</span> [ &#963;, bottom ];
  },

  eval_deref() {
    <span style="font-weight: bold;">return</span> bottom;
  },

  eval_assign(&#963;) {
    <span style="font-weight: bold;">return</span> &#963;;
  }
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">address</span>(<span style="font-weight: bold; font-style: italic;">a</span>) {
  <span style="font-weight: bold;">return</span> {
    eval_deref(&#963;) {
      <span style="font-weight: bold;">return</span> &#963;[a];
    },

    eval_assign(&#963;, v) {
      <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;);
      &#963;2[a] = v;
      <span style="font-weight: bold;">return</span> &#963;2;
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">closure</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>, &#952;) {
  <span style="font-weight: bold;">return</span> {
    eval_apply(&#963;, v) {
      <span style="font-weight: bold;">let</span> &#952;1 = Object.create(&#952;);
      &#952;1[x] = v;
      <span style="font-weight: bold;">return</span> e.eval(&#963;, &#952;1);
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">c</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">return</span> [ &#963;, e ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">v</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">return</span> [ &#963;, &#952;[e] ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">fun</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">return</span> [ &#963;, closure(x, e, &#952;) ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">app</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">let</span> [&#963;1, v1] = e1.eval(&#963;, &#952;);
      <span style="font-weight: bold;">let</span> [&#963;2, v2] = e2.eval(&#963;1, &#952;);
      <span style="font-weight: bold;">return</span> v1.eval_apply(&#963;2, v2);
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">let</span> [&#963;1, v] = e.eval(&#963;, &#952;);
      <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
      <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
      &#963;2[a] = v;
      <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">deref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">let</span> [&#963;1, v] = e.eval(&#963;, &#952;);
      <span style="font-weight: bold;">return</span> [ &#963;1, v.eval_deref(&#963;1, v) ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">assign</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">let</span> [&#963;1, v1] = e1.eval(&#963;, &#952;);
      <span style="font-weight: bold;">let</span> [&#963;2, v2] = e2.eval(&#963;1, &#952;);
      <span style="font-weight: bold;">return</span> [ v1.eval_assign(&#963;2, v2), v2 ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretProgram</span>(<span style="font-weight: bold; font-style: italic;">AST</span>, <span style="font-weight: bold; font-style: italic;">env</span> = {}, <span style="font-weight: bold; font-style: italic;">store</span> = {}) {
  <span style="font-weight: bold;">return</span> AST.eval(env, store);
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Test</span>
interpretProgram(
  app(fun(<span style="font-style: italic;">'x'</span>, deref(v(<span style="font-style: italic;">'x'</span>))),
      ref(c(42)))
);
</pre>
</div>

<p>
<a href="js/lab/lamfa-oo-facets.js">js/lab/lamfa-oo-facets.js</a>
</p>
<div class="org-src-container">

<pre class="src src-js">Set.<span style="font-weight: bold; text-decoration: underline;">prototype</span>.union = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">elem</span>) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">n</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(<span style="font-weight: bold; text-decoration: underline;">this</span>);
  n.add(elem);
  <span style="font-weight: bold;">return</span> n;
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">mk_facet</span>(<span style="font-weight: bold; font-style: italic;">pc</span>, <span style="font-weight: bold; font-style: italic;">v1</span>, <span style="font-weight: bold; font-style: italic;">v2</span>) {
  <span style="font-weight: bold;">if</span> (pc.size === 0)
    <span style="font-weight: bold;">return</span> v1;

  <span style="font-weight: bold;">let</span> [k, ...rest] = pc;
  rest = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(rest);

  <span style="font-weight: bold;">if</span> (k &gt; 0)
    <span style="font-weight: bold;">return</span> facet(k, mk_facet(rest, v1, v2), v2);
  <span style="font-weight: bold;">else</span>
    <span style="font-weight: bold;">return</span> facet(k, v2, mk_facet(rest, v1, v2));
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">facet</span>(<span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; font-style: italic;">vh</span>, <span style="font-weight: bold; font-style: italic;">vl</span>) {
  <span style="font-weight: bold;">return</span> {
    eval_apply(&#963;, pc, v2) {
      <span style="font-weight: bold;">if</span> (pc.has(k)) {
        <span style="font-weight: bold;">return</span> vh.eval_apply(&#963;, pc, v2);
      }

      <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (pc.has(-k)) {
        <span style="font-weight: bold;">return</span> vl.eval_apply(&#963;, pc, v2);
      }

      <span style="font-weight: bold;">else</span> {
        <span style="font-weight: bold;">let</span> [&#963;1, vh1] = vh.eval_apply(&#963;, pc.union(k), v2);
        <span style="font-weight: bold;">let</span> [&#963;2, vl1] = vl.eval_apply(&#963;1, pc.union(-k), v2);
        <span style="font-weight: bold;">return</span> [ &#963;2, mk_facet(k, vh1, vl1) ];
      }
    },

    eval_deref(&#963;, pc) {
      <span style="font-weight: bold;">if</span> (pc.has(k))
        <span style="font-weight: bold;">return</span> vh.eval_deref(&#963;, pc);
      <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (pc.has(-k))
        <span style="font-weight: bold;">return</span> vl.eval_deref(&#963;, pc);
      <span style="font-weight: bold;">else</span>
        <span style="font-weight: bold;">return</span> mk_facet(k, vh.eval_deref(&#963;, pc), vl.eval_deref(&#963;, pc));
    },

    eval_assign(&#963;, pc, v) {
      <span style="font-weight: bold;">let</span> &#963;1 = vh.eval_assign(&#963;, pc.union(k), v);
      <span style="font-weight: bold;">return</span> vl.eval_assign(&#963;1, pc.union(-k), v);
    }
  };
}

<span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">bottom</span> = {
  eval_apply(&#963;) {
    <span style="font-weight: bold;">return</span> [ &#963;, bottom ];
  },

  eval_deref() {
    <span style="font-weight: bold;">return</span> bottom;
  },

  eval_assign(&#963;) {
    <span style="font-weight: bold;">return</span> &#963;;
  }
};

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">address</span>(<span style="font-weight: bold; font-style: italic;">a</span>) {
  <span style="font-weight: bold;">return</span> {
    eval_deref(&#963;) {
      <span style="font-weight: bold;">return</span> &#963;[a];
    },

    eval_assign(&#963;, v) {
      <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;);
      &#963;2[a] = v;
      <span style="font-weight: bold;">return</span> &#963;2;
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">closure</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>, &#952;) {
  <span style="font-weight: bold;">return</span> {
    eval_apply(&#963;, pc, v) {
      <span style="font-weight: bold;">let</span> &#952;1 = Object.create(&#952;);
      &#952;1[x] = v;
      <span style="font-weight: bold;">return</span> e.eval(&#963;, &#952;1, pc);
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">c</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">return</span> [ &#963;, e ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">v</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">return</span> [ &#963;, &#952;[e] ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">fun</span>(<span style="font-weight: bold; font-style: italic;">x</span>, <span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">return</span> [ &#963;, closure(x, e, &#952;) ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">app</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">let</span> [&#963;1, v1] = e1.eval(&#963;, &#952;, pc);
      <span style="font-weight: bold;">let</span> [&#963;2, v2] = e2.eval(&#963;1, &#952;, pc);
      <span style="font-weight: bold;">return</span> v1.eval_apply(&#963;2, pc, v2);
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">let</span> [&#963;1, v] = e.eval(&#963;, &#952;, pc);
      <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
      <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
      &#963;2[a] = mk_facet(pc, v, bottom);
      <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">deref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">let</span> [&#963;1, v] = e.eval(&#963;, &#952;, pc);
      <span style="font-weight: bold;">return</span> [ &#963;1, v.eval_deref(&#963;1, pc, v) ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">assign</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;, pc) {
      <span style="font-weight: bold;">let</span> [&#963;1, v1] = e1.eval(&#963;, &#952;, pc);
      <span style="font-weight: bold;">let</span> [&#963;2, v2] = e2.eval(&#963;1, &#952;, pc);
      <span style="font-weight: bold;">return</span> [ v1.eval_assign(&#963;2, pc, v2), v2 ];
    }
  };
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretProgram</span>(<span style="font-weight: bold; font-style: italic;">AST</span>, <span style="font-weight: bold; font-style: italic;">env</span> = {}, <span style="font-weight: bold; font-style: italic;">store</span> = {}, <span style="font-weight: bold; font-style: italic;">pc</span> = []) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pc</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(pc);
  <span style="font-weight: bold;">return</span> AST.eval(env, store, pc);
}

<span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Test</span>
interpretProgram(
  app(fun(<span style="font-style: italic;">'x'</span>, deref(v(<span style="font-style: italic;">'x'</span>))),
      ref(c(42))),
  {}, {}, [1]
);
</pre>
</div>

<p>
But here again, the pattern appears when looking at the diff.
</p>

<div class="org-src-container">

<pre class="src src-sh">diff js/lab/lamfa-oo-standard.js js/lab/lamfa-oo-facets.js; <span style="font-weight: bold;">exit</span> 0
</pre>
</div>

<div class="org-src-container">

<pre class="src src-diff"><span style="font-weight: bold;">0a1,53</span>
&gt; Set.prototype.union = function(elem) {
&gt;   let n = new Set(this);
&gt;   n.add(elem);
&gt;   return n;
&gt; }
&gt;
&gt; function mk_facet(pc, v1, v2) {
&gt;   if (pc.size === 0)
&gt;     return v1;
&gt;
&gt;   let [k, ...rest] = pc;
&gt;   rest = new Set(rest);
&gt;
&gt;   if (k &gt; 0)
&gt;     return facet(k, mk_facet(rest, v1, v2), v2);
&gt;   else
&gt;     return facet(k, v2, mk_facet(rest, v1, v2));
&gt; }
&gt;
&gt; function facet(k, vh, vl) {
&gt;   return {
&gt;     eval_apply(&#963;, pc, v2) {
&gt;       if (pc.has(k)) {
&gt;         return vh.eval_apply(&#963;, pc, v2);
&gt;       }
&gt;
&gt;       else if (pc.has(-k)) {
&gt;         return vl.eval_apply(&#963;, pc, v2);
&gt;       }
&gt;
&gt;       else {
&gt;         let [&#963;1, vh1] = vh.eval_apply(&#963;, pc.union(k), v2);
&gt;         let [&#963;2, vl1] = vl.eval_apply(&#963;1, pc.union(-k), v2);
&gt;         return [ &#963;2, mk_facet(k, vh1, vl1) ];
&gt;       }
&gt;     },
&gt;
&gt;     eval_deref(&#963;, pc) {
&gt;       if (pc.has(k))
&gt;         return vh.eval_deref(&#963;, pc);
&gt;       else if (pc.has(-k))
&gt;         return vl.eval_deref(&#963;, pc);
&gt;       else
&gt;         return mk_facet(k, vh.eval_deref(&#963;, pc), vl.eval_deref(&#963;, pc));
&gt;     },
&gt;
&gt;     eval_assign(&#963;, pc, v) {
&gt;       let &#963;1 = vh.eval_assign(&#963;, pc.union(k), v);
&gt;       return vl.eval_assign(&#963;1, pc.union(-k), v);
&gt;     }
&gt;   };
&gt; }
&gt;
<span style="font-weight: bold;">31c84</span>
&lt;     eval_apply(&#963;, v) {
<span style="font-weight: bold;">---</span>
&gt;     eval_apply(&#963;, pc, v) {
<span style="font-weight: bold;">34c87</span>
&lt;       return e.eval(&#963;, &#952;1);
<span style="font-weight: bold;">---</span>
&gt;       return e.eval(&#963;, &#952;1, pc);
<span style="font-weight: bold;">41c94</span>
&lt;     eval(&#963;, &#952;) {
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
<span style="font-weight: bold;">49c102</span>
&lt;     eval(&#963;, &#952;) {
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
<span style="font-weight: bold;">57c110</span>
&lt;     eval(&#963;, &#952;) {
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
<span style="font-weight: bold;">65,68c118,121</span>
&lt;     eval(&#963;, &#952;) {
&lt;       let [&#963;1, v1] = e1.eval(&#963;, &#952;);
&lt;       let [&#963;2, v2] = e2.eval(&#963;1, &#952;);
&lt;       return v1.eval_apply(&#963;2, v2);
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
&gt;       let [&#963;1, v1] = e1.eval(&#963;, &#952;, pc);
&gt;       let [&#963;2, v2] = e2.eval(&#963;1, &#952;, pc);
&gt;       return v1.eval_apply(&#963;2, pc, v2);
<span style="font-weight: bold;">75,76c128,129</span>
&lt;     eval(&#963;, &#952;) {
&lt;       let [&#963;1, v] = e.eval(&#963;, &#952;);
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
&gt;       let [&#963;1, v] = e.eval(&#963;, &#952;, pc);
<span style="font-weight: bold;">79c132</span>
&lt;       &#963;2[a] = v;
<span style="font-weight: bold;">---</span>
&gt;       &#963;2[a] = mk_facet(pc, v, bottom);
<span style="font-weight: bold;">87,89c140,142</span>
&lt;     eval(&#963;, &#952;) {
&lt;       let [&#963;1, v] = e.eval(&#963;, &#952;);
&lt;       return [ &#963;1, v.eval_deref(&#963;1, v) ];
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
&gt;       let [&#963;1, v] = e.eval(&#963;, &#952;, pc);
&gt;       return [ &#963;1, v.eval_deref(&#963;1, pc, v) ];
<span style="font-weight: bold;">96,99c149,152</span>
&lt;     eval(&#963;, &#952;) {
&lt;       let [&#963;1, v1] = e1.eval(&#963;, &#952;);
&lt;       let [&#963;2, v2] = e2.eval(&#963;1, &#952;);
&lt;       return [ v1.eval_assign(&#963;2, v2), v2 ];
<span style="font-weight: bold;">---</span>
&gt;     eval(&#963;, &#952;, pc) {
&gt;       let [&#963;1, v1] = e1.eval(&#963;, &#952;, pc);
&gt;       let [&#963;2, v2] = e2.eval(&#963;1, &#952;, pc);
&gt;       return [ v1.eval_assign(&#963;2, pc, v2), v2 ];
<span style="font-weight: bold;">104,105c157,159</span>
&lt; function interpretProgram(AST, env = {}, store = {}) {
&lt;   return AST.eval(env, store);
<span style="font-weight: bold;">---</span>
&gt; function interpretProgram(AST, env = {}, store = {}, pc = []) {
&gt;   let pc = new Set(pc);
&gt;   return AST.eval(env, store, pc);
<span style="font-weight: bold;">111c165,166</span>
&lt;       ref(c(42)))
<span style="font-weight: bold;">---</span>
&gt;       ref(c(42))),
&gt;   {}, {}, [1]
</pre>
</div>

<p>
Hence, these patterns appear regardless of the instrumented language
(lambda calculus or JavaScript), and regardless of the language
features used by the implementation (pattern matching or dynamic
dispatch).  Therefore, the problem of finding a way to describe the
instrumentation as a module and minimizing coupling is not specific to
Narcissus or JavaScript interpreters.
</p>

<p>
We will now exhibit variations in writing the instrumentation as
a separate module with minimal code duplication.
</p>
</div>
</div>

<div id="outline-container-orgheadline63" class="outline-4">
<h4 id="orgheadline63"><span class="section-number-4">5.0.2</span> The expression problem</h4>
<div class="outline-text-4" id="text-5-0-2">
<p>
First, let&rsquo;s list the additions brought by our extension to the
interpreter:
</p>

<ul class="org-ul">
<li>we add a new constructor <code>Couple</code> to the data type <code>Term</code></li>
<li>we add a new constructor <code>Pair</code> to the data type <code>Value</code></li>
<li>we add a new case <code>Couple</code> to the function <code>interp</code></li>
<li>we add two new (symmetric) cases <code>Pair</code> to the function <code>plus</code></li>
</ul>

<p>
Now, what would a differential description of the extension to our
interpreter look like?
</p>

<div class="org-src-container">

<pre class="src src-haskell">extend data Term = Couple Int Int
extend data Value = Pair Int Int

extend interp (Couple i1 i2) = (Pair i1 i2)
extend plus (Number a) (Pair i1 i2) = (Pair (a + i1) (a + i2))
extend plus (Pair i1 i2) (Number a) = (Pair (a + i1) (a + i2))
</pre>
</div>

<p>
These are all the additions brought by the extension to the original
interpreter.  The new <code>extend</code> keyword allows us to:
</p>

<ol class="org-ol">
<li>Extend data types with new constructors.</li>
<li>Extend function definitions with new cases.</li>
</ol>

<p>
How to extend both data types and functions in a program, without
sacrificing modularity, is a problem known as the <i>expression problem</i>
[Wadler].  This (imaginary) <code>extend</code> keyword is a solution; there are
real solutions [<a href="http://www.andres-loeh.de/OpenDatatypes.pdf">Open Data Types and Open Functions</a>] (Instead of an
<code>extend</code> keyword, they provide an <code>open</code> keyword to prefix to initial
declarations of data types and functions.  One could also require both
extended and original codes to include keywords.)
</p>
</div>
</div>

<div id="outline-container-orgheadline64" class="outline-4">
<h4 id="orgheadline64"><span class="section-number-4">5.0.3</span> The expression problem, with a twist</h4>
<div class="outline-text-4" id="text-5-0-3">
<p>
The expression problem is only concerned with <i>adding</i> data types and
functions, but when we instrument an interpreter, we will often want
to <i>modify</i> its behavior rather than just extend it.
</p>

<p>
When we take modification into account, what does a differential
description look like?
</p>

<p>
First, let&rsquo;s go back to the original interpreter, and modify its
behavior.
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Term = Plus Term Term | Constant Int
data Value = Number Int

interp :: Term -&gt; Value
interp (Plus t1 t2) = plus (interp t1) (interp t2)
interp (Constant i) = (Number i)

plus :: Value -&gt; Value -&gt; Value
plus (Number a) (Number b) = (Number (a + b))
</pre>
</div>

<p>
Say we need to change the value returned by the interpretation of the
term ‚ÄòConstant&rsquo;.  We want to return a ‚ÄòPair&rsquo; value instead of a single
number, the second value being a default zero.  We would write the
full version, with replication as:
</p>

<div class="org-src-container">

<pre class="src src-haskell">data Term = Plus Term Term | Constant Int
data Value = Number Int | Pair Int Int

interp :: Term -&gt; Value
interp (Plus t1 t2) = plus (interp t1) (interp t2)
interp (Constant i) = (Pair i 0)

plus :: Value -&gt; Value -&gt; Value
plus (Number a) (Number b) = (Number (a + b))
</pre>
</div>

<p>
What would be the differential description of this change?
</p>

<div class="org-src-container">

<pre class="src src-haskell">extend data Value = Pair Int Int

modify interp (Constant i) = (Pair i 0)
</pre>
</div>

<p>
The keyword <code>modify</code> replaces the definition for the targeted case of
<code>interp</code>.
</p>

<p>
[What if we want to combine multiple modifications to the same case
function? A: You&rsquo;d have to have a clue about the precedence order to
make sense of the result, but these problems are shared by other AOP
applications.]
</p>
</div>
</div>

<div id="outline-container-orgheadline65" class="outline-4">
<h4 id="orgheadline65"><span class="section-number-4">5.0.4</span> The modular instrumentation problem</h4>
<div class="outline-text-4" id="text-5-0-4">
<p>
We have an interpreter I for a language L, and the source code for I.
We want to instrument the interpreter I, by extending and modifying
its behavior.  Namely, the instrumentation can:
</p>
<ul class="org-ul">
<li>add terms to the base language</li>
<li>add values to the base language</li>
<li>add new operations</li>
<li>alter the behavior of existing operations, or even suppress them
entirely.</li>
</ul>

<p>
We constrain the instrumentation by imposing the following
restrictions:
</p>

<ul class="org-ul">
<li>The instrumented interpreter I&rsquo; must still be able to execute
programs written in the language L.  The instrumentation cannot
remove or modify existing terms of the language.</li>
<li>The instrumentation must modify only a part of the original
interpreter operations.  Otherwise, the instrumented interpreter
may end up with semantics so different from the original interpreter
that it does not qualify as &laquo;&nbsp;instrumentation&nbsp;&raquo; anymore; it might as
well be another interpreter in its own right.</li>
</ul>

<p>
The implementation of this instrumentation will give a new interpreter
I&rsquo;.  Ideally, this implementation should be as modular as possible; it
should:
</p>
<ul class="org-ul">
<li>promote isolated reasoning,</li>
<li>minimize code replication and accidental complexity.  We should be
able to map the differential description of the instrumentation and
the code for its implementation.</li>
</ul>

<p>
The <i>modular instrumentation problem</i> is then: how to implement the
instrumentation with the above constraints of modularity?
</p>

<p>
Note that the changes may bring only additional side effects, and
leave the original behavior unaltered.  How to recognize or enforce
&laquo;&nbsp;side-effects only&nbsp;&raquo; instrumentation is an interesting
question. [&laquo;&nbsp;Recognize&nbsp;&raquo; I don&rsquo;t know how.  &laquo;&nbsp;Enforce&nbsp;&raquo; you can do with
monads, if you have a monadic interpreter.]
</p>
</div>
</div>

<div id="outline-container-orgheadline79" class="outline-3">
<h3 id="orgheadline79"><span class="section-number-3">5.1</span> Variations</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-orgheadline78" class="outline-4">
<h4 id="orgheadline78"><span class="section-number-4">5.1.1</span> JavaScript</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
See <a href="js/aoping.html">js/aoping.html</a>.
</p>

<p>
See also <a href="lassy15.html">lassy15.html</a> for a way to build interpreters incrementally.
</p>
</div>

<div id="outline-container-orgheadline66" class="outline-5">
<h5 id="orgheadline66">Split OO-style instrumented interpreter into modules</h5>
<div class="outline-text-5" id="text-orgheadline66">
<p>
Let&rsquo;s try to separate the object-oriented instrumented interpreter in
two modules: one for the base interpreter, ‚Äòbase.js&rsquo;, and one for the
instrumentation, ‚Äòfacets.js&rsquo;.  The ‚Äòbase.js&rsquo; file should not contain
any instrumentation-specific code, and be as close as possible to the
standard interpreter.
</p>

<p>
Looking at the diff, we can put <code>mk_facet</code>, <code>facet</code> and the extension
to <code>Set.prototype</code> in a separate file right away.
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline67"></a>Handling the extra PC parameter<br ><div class="outline-text-6" id="text-orgheadline67">
<p>
The second, more pervasive change is the addition of the program
counter context in every call.  There are at least two solutions to
this problem:
</p>
<ol class="org-ol">
<li>Using a global variable.</li>
<li>Using a context object.</li>
</ol>
</div>

<ul class="org-ul"><li><a id="orgheadline68"></a>Using a global variable<br ><div class="outline-text-7" id="text-orgheadline68">
<p>
<a href="js/lab/oo-split-global/base.js">js/lab/oo-split-global/base.js</a>
<a href="js/lab/oo-split-global/facets.js">js/lab/oo-split-global/facets.js</a>
</p>

<p>
We can use a global variable for the ‚Äòpc&rsquo;.  This eliminates the need
to pass the ‚Äòpc&rsquo; as a formal parameter to most functions, and to pass
it down to tail calls.  However, we then need to save the previous
value of this global pc when temporarily changing the current pc to
evaluate branches in <code>facet.eval_assign</code> and <code>facet.eval_apply</code>.
</p>

<p>
With the ‚Äòpc&rsquo; argument:
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> [&#963;1, vh1] = vh.eval_apply(&#963;, pc.union(k), v2);
<span style="font-weight: bold;">let</span> [&#963;2, vl1] = vl.eval_apply(&#963;1, pc.union(-k), v2);
</pre>
</div>

<p>
With a global variable ‚Äòpc&rsquo;:
</p>
<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">pc_old</span> = pc;
pc = pc.union(k);
<span style="font-weight: bold;">let</span> [&#963;1, vh1] = vh.eval_apply(&#963;, v2);
pc = pc.union(-k);
<span style="font-weight: bold;">let</span> [&#963;2, vl1] = vl.eval_apply(&#963;1, v2);
pc = pc_old;
</pre>
</div>

<p>
This temporary rewriting of a variable is essentially emulating a
dynamic binding of the ‚Äòpc&rsquo; variable.  There are no built-ins
constructs or syntactic sugar for dynamic binding in JavaScript, but
we can add one for this particular variable.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">with_pc</span>(<span style="font-weight: bold; font-style: italic;">new_pc</span>, <span style="font-weight: bold; font-style: italic;">thunk</span>) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">old_pc</span> = pc;
  pc = new_pc;
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">ret</span> = thunk();
  pc = old_pc;
  <span style="font-weight: bold;">return</span> ret;
}
</pre>
</div>

<p>
Now the <code>facet.eval_apply</code> function is cleaner:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> [&#963;1, vh1] = with_pc(pc.union(k), () =&gt; vh.eval_apply(&#963;, v2));
<span style="font-weight: bold;">let</span> [&#963;2, vl1] = with_pc(pc.union(-k), () =&gt; vl.eval_apply(&#963;1, v2));
<span style="font-weight: bold;">return</span> [ &#963;2, mk_facet(k, vh1, vl1) ];
</pre>
</div>

<p>
The ‚Äòpc&rsquo; parameter is thus part of the closure of all facet-related
functions.  The <code>with_pc</code> construct require mutability in order to
change the current program counter referenced in the closure.
Mutability can be waived as a requirement if the language supports
dynamic scoping [Art of Interp].
</p>
</div></li>

<li><a id="orgheadline69"></a>Using a context object<br ><div class="outline-text-7" id="text-orgheadline69">
<p>
<a href="js/lab/oo-split-context/base.js">js/lab/oo-split-context/base.js</a>
<a href="js/lab/oo-split-context/facets.js">js/lab/oo-split-context/facets.js</a>
</p>

<p>
Using a global variable for just the ‚Äòpc&rsquo; and not the store or
environment seems heterogeneous.  We can adopt the position that the
‚Äòpc&rsquo; is an extension to the state of the interpreter, and bundle all
this state in a ‚Äòcontext&rsquo; objet passed around in function calls.  Then
we profit from the dynamic nature of JavaScript objects: we can add
any property at runtime.  Rather than hiding the ‚Äòpc&rsquo; away, it makes
the state passing explicit, and removes the need for <code>with_pc</code>.
</p>

<p>
This solution has the benefit of homogenizing the order of formal
parameters: the context object will always be the first one, and the
<code>eval</code> functions will always return a context object rather than just
the store.
</p>

<p>
Here is what the third branch of <code>facet.eval_apply</code> looks like:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> [<span style="font-weight: bold; font-style: italic;">C1</span>, <span style="font-weight: bold; font-style: italic;">vh1</span>] = vh.eval_apply(with_pc(C, C.pc.union(k)), v2);
<span style="font-weight: bold;">let</span> [<span style="font-weight: bold; font-style: italic;">C2</span>, <span style="font-weight: bold; font-style: italic;">vl1</span>] = vl.eval_apply(with_pc(C1, C.pc.union(-k)), v2);
<span style="font-weight: bold;">return</span> [ C2, mk_facet(k, vh1, vl1) ];
</pre>
</div>

<p>
The evaluation of functions now explicitly deals with contexts:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">app</span>(<span style="font-weight: bold; font-style: italic;">e1</span>, <span style="font-weight: bold; font-style: italic;">e2</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(C) {
      <span style="font-weight: bold;">let</span> [<span style="font-weight: bold; font-style: italic;">C1</span>, <span style="font-weight: bold; font-style: italic;">v1</span>] = e1.eval(C);
      <span style="font-weight: bold;">let</span> [<span style="font-weight: bold; font-style: italic;">C2</span>, <span style="font-weight: bold; font-style: italic;">v2</span>] = e2.eval(C1);
      <span style="font-weight: bold;">return</span> v1.eval_apply(C2, v2);
    }
  };
}
</pre>
</div>

<p>
The signatures are simpler, though we lose a bit in legibility, as <code>C</code>
is opaque: we do not see what the context made is of by looking at the
formal parameters.  Only looking at the entry point
(<code>interpretProgram</code>) reveals its contents.
</p>

<p>
The context object bundles all the state needed by the interpreter,
and its extensions.  Adding another piece of state is modular since
the base interpreter already passes down this context object.
</p>

<p>
This solution does not require mutability, but it benefits from
dynamic typing.  In the case of the base interpreter, the context
object has type (Store * Environment), while in the faceted
interpreter, it has type (Store * Environment * PC).
</p>

<p>
Note that we could combine both methods, and avoid passing the context
object explicitly in all functions by using a global variable.  In
that case, both mutability and dynamic typing are leveraged.
</p>
</div></li></ul></li>

<li><a id="orgheadline70"></a>Handling the change in the reference rule<br ><div class="outline-text-6" id="text-orgheadline70">
<p>
<a href="js/lab/oo-split-global/base.js">js/lab/oo-split-global/base.js</a>
<a href="js/lab/oo-split-global/facets.js">js/lab/oo-split-global/facets.js</a>
</p>

<p>
With the extra ‚Äòpc&rsquo; out of the way, the only change remaining is the
<code>mk_facet</code> call in the reference rule.  This is how runtime faceted
values are effectively created.
</p>

<div class="org-src-container">

<pre class="src src-diff"><span style="font-weight: bold;">79c79</span>
&lt;       &#963;2[a] = mk_facet(pc, v, bottom);
<span style="font-weight: bold;">---</span>
&gt;       &#963;2[a] = v;
</pre>
</div>

<p>
We can solve this by creating two different versions of the <code>ref</code>
function, one with the standard behavior, and one suited for the
instrumentation.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">let</span> [&#963;1, v] = e.eval(&#963;, &#952;);
      <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
      <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
      &#963;2[a] = v;
      <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
    }
  };
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> {
    eval(&#963;, &#952;) {
      <span style="font-weight: bold;">let</span> [&#963;1, v] = e.eval(&#963;, &#952;);
      <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
      <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
      &#963;2[a] = mk_facet(pc, v, bottom); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">this line changes</span>
      <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
    }
  };
}
</pre>
</div>

<p>
But how do we differentiate which version of <code>ref</code> to use when calling
<code>interpretProgram</code>?  We need namespaces.  Using objects as namespaces,
both versions of <code>ref</code> can coexist.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold; text-decoration: underline;">this</span>.base = {
  interpretProgram,
  c, v, fun, app, ref, deref, assign,
  _innards: { bottom, address, closure}
};
</pre>
</div>

<p>
The base interpreter exports both public interface and a &laquo;&nbsp;restricted&nbsp;&raquo;
one intended for extension purposes.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold; text-decoration: underline;">this</span>.facets = {
  __proto__: <span style="font-weight: bold; text-decoration: underline;">this</span>.base,
  interpretProgram,
  ref
};
</pre>
</div>

<p>
The instrumented interpreter exports the same interface as the base,
only overriding definitions for <code>ref</code> and <code>interpretProgram</code>.
</p>

<p>
Both interpreters can then be tested independently.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">with</span> (base) {
  console.log(<span style="font-style: italic;">'std'</span>, interpretProgram(
    app(fun(<span style="font-style: italic;">'x'</span>, deref(v(<span style="font-style: italic;">'x'</span>))),
        ref(c(42))),
    {}, {}
  ));
}

<span style="font-weight: bold;">with</span> (facets) {
  console.log(<span style="font-style: italic;">'facets'</span>, interpretProgram(
    app(fun(<span style="font-style: italic;">'x'</span>, deref(v(<span style="font-style: italic;">'x'</span>))),
        ref(c(42))),
    {}, {}, [1]
  ));
}
</pre>
</div>

<p>
Finally, both base interpreters (with a global ‚Äòpc&rsquo;, and with a
context object) are free of instrumentation-specific concerns.  In
fact, the base interpreter with the global ‚Äòpc&rsquo; is <i>identical</i> to the
base object-oriented interpreter.
</p>
</div></li>

<li><a id="orgheadline71"></a>Summary<br ><div class="outline-text-6" id="text-orgheadline71">
<p>
We split the object-oriented interpreter into two modules:
</p>
<ol class="org-ol">
<li>The base interpreter which contains no concerns pertaining to
faceted evaluation.</li>
<li>The facet interpreter which extends the context of the base
interpreter, either by using a (delimited) global, or by extending
the context object.  The facet interpreter then selects and
overrides the entry point (<code>interpretProgram</code>) and the reference
rule (<code>ref</code>).</li>
</ol>

<p>
We used two different mechanisms to handle the extra ‚Äòpc&rsquo; parameter:
</p>
<ol class="org-ol">
<li>A ‚Äòpc&rsquo; variable in the closure of all facet-related functions.
This solution works if the language provides mutable variables or
dynamic scoping.</li>
<li>Modifying the base interpreter to use a context object for the
store and environment.  We then leveraged the ability to add
properties to existing objects and included the program counter in
this context.  Mutability is not required, but dynamic typing
allows us to use a context object with two incompatibles types.</li>
</ol>

<p>
Overriding the <code>ref</code> function required only delegation using the
prototype chain.
</p>
</div></li></ul>
</div>

<div id="outline-container-orgheadline72" class="outline-5">
<h5 id="orgheadline72">Split pattern-matching instrumented interpreter into modules</h5>
<div class="outline-text-5" id="text-orgheadline72">
<p>
<a href="js/lab/es6-split-global/base.js">js/lab/es6-split-global/base.js</a>
<a href="js/lab/es6-split-global/facets.js">js/lab/es6-split-global/facets.js</a>
</p>

<p>
We can handle the extra ‚Äòpc&rsquo; parameter in the same ways we did with
the object-oriented interpreter.
</p>

<p>
However, when we try to extend the <code>ref</code> rule, two things are
different.
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline73"></a>The facet-specific rules are scattered<br ><div class="outline-text-6" id="text-orgheadline73">
<p>
The <code>eval_apply</code>, <code>eval_deref</code> and <code>eval_assign</code> code for facet values
is split across the three <code>application_rules</code>, <code>deref_rules</code> and
<code>assign_rules</code> objects.  In the object-oriented approach, they were
regrouped under the same <code>facet</code> object.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">facet</span>(<span style="font-weight: bold; font-style: italic;">k</span>, <span style="font-weight: bold; font-style: italic;">vh</span>, <span style="font-weight: bold; font-style: italic;">vl</span>) {
  <span style="font-weight: bold;">return</span> {
    eval_apply(&#963;, v2) {...},
    eval_deref(&#963;) {...},
    eval_assign(&#963;, v) {...}
  };
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">base.application_rules.facet = (&#963;, {k, vh, vl}, v2) =&gt; {...};
base.deref_rules.facet = (&#963;, {k, vh, vl}) =&gt; {...};
base.assign_rules.facet = (&#963;, {k, vh, vl}, v) =&gt; {...};
</pre>
</div>

<p>
This is a manifestation of the expression problem, or the &laquo;&nbsp;tyranny of
the primary decomposition&nbsp;&raquo;: in the object-oriented approach, adding a
term is just adding an object with all its evaluation functions; while
adding evaluation functions requires modifying all the objects.  Note
that since in JavaScript objects can be extended at runtime, the
primary decomposition has a lower impact.
</p>

<p>
However, here we have to add the <code>facet</code> rules to the base objects
directly.  A more modular approach would be to create new rules
objects that extends (by prototype links) the base rules objects.  But
this is not an option here because the base rules objects are enclosed
by the evaluation functions.  If we create a <code>facet_application_rules</code>
object like so:
</p>

<div class="org-src-container">

<pre class="src src-js">facet_application_rules = {
  __proto__: base.application_rules,
  facet(&#963;, {k, vh, vl}, v2) =&gt; {...}
};
</pre>
</div>

<p>
Then we have to redefine the <code>eval_apply</code> function to call this new
object instead of the <code>base.application_rules</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">eval_apply</span>(&#963;, v1, v2) {
  <span style="font-weight: bold;">return</span> facet_application_rules[v1.type](&#963;, v1, v2);
}
</pre>
</div>

<p>
But <code>eval_apply</code> is in the closure of the <code>rules.app</code> function, so we
have to redefine it as well just to be able to update its closure.
</p>

<div class="org-src-container">

<pre class="src src-js">app(&#963;, &#952;, {e1, e2}) {
  ...
  <span style="font-weight: bold;">return</span> eval_apply(&#963;2, v1, v2);
},
</pre>
</div>

<p>
And we would have to do the same for every rules object, and for every
function that refer to these rules object.  In the end, we are back to
copy-pasting the base interpreter just to update the closures of its
functions.
</p>

<p>
It is clear that the lexical scoping of the rules object is the issue.
Being able to refer to these object from a dynamic scope would resolve
it.
</p>
</div></li>

<li><a id="orgheadline74"></a>Extending the ref function<br ><div class="outline-text-6" id="text-orgheadline74">
<p>
In the object-oriented approach, we redefined the <code>ref</code> function in
the facets module and delegated the other rules to the base
interpreter.  Here we cannot do so.
</p>

<p>
In the object-oriented interpreter, the <code>ref</code> function returns an
object which contains its own evaluation method.  Thus, by overriding
this <code>ref</code> function we can change the way <code>ref</code> nodes are evaluated.
In the client code, a call to <code>ref</code> is dynamically dispatched to
either the base or facet version.
</p>

<p>
In the pattern matching interpreter, the <code>ref</code> function returns an
object <i>without</i> an evaluation function &#x2013; only bearing a type used by
<code>interpretNode</code> to dispatch to the correct evaluation function.  The
evaluation function is in the <code>rules</code> object, separated from the
object created by <code>ref</code>.  To change the evaluation of <code>ref</code> nodes, we
need to change the <code>ref</code> function inside the <code>rules</code> object, but we
also need to update the dispatching function.
</p>

<p>
The <code>rules</code> object is in the closure of <code>base.interpretNode</code>.
Extending the <code>rules</code> object with a new <code>ref</code> function would not
change the behavior of <code>base.interpretNode</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">rules</span> = {
  __proto__: base.rules,
  ref(&#963;, &#952;, {e}) {
    <span style="font-weight: bold;">let</span> [&#963;1, v] = &#8582;(&#963;, &#952;, e);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
    <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
    &#963;2[a] = mk_facet(pc, v, bottom);
    <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
  }
};
</pre>
</div>

<p>
Trying to redefine a new <code>interpretNode</code> function in the facets module
to close over this new <code>rules</code> object is not a solution.  Rules from
the base interpreter will still call the <code>base.interpretNode</code> function
which refer to the <code>base.rules</code> object.  Redefining every function
that calls <code>base.interpretNode</code> to call <code>facets.interpretNode</code> would
work, but that&rsquo;s basically duplicating the base interpreter.
</p>

<p>
What does work is to ‚Äòfluid-let&rsquo; the <code>rules</code> object inside
<code>facets.interpretProgram</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretProgram</span>(<span style="font-weight: bold; font-style: italic;">AST</span>, <span style="font-weight: bold; font-style: italic;">env</span> = {}, <span style="font-weight: bold; font-style: italic;">store</span> = {}, <span style="font-weight: bold; font-style: italic;">default_pc</span> = []) {
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">old_ref</span> = base._innards.rules.ref;
  base._innards.rules.ref = (&#963;, &#952;, {e}) =&gt; {
    <span style="font-weight: bold;">let</span> [&#963;1, v] = &#8582;(&#963;, &#952;, e);
    <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">a</span> = Object.keys(&#963;1).length;
    <span style="font-weight: bold;">let</span> &#963;2 = Object.create(&#963;1);
    &#963;2[a] = mk_facet(pc, v, bottom);
    <span style="font-weight: bold;">return</span> [ &#963;2, address(a) ];
  };
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">r</span> = with_pc(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(default_pc), () =&gt;
                  base.interpretProgram(AST, env, store));
  base._innards.rules.ref = old_ref;
  <span style="font-weight: bold;">return</span> r;
}
</pre>
</div>

<p>
Note that, again, this construct is emulating a dynamic scoping of the
<code>rules.ref</code> function.  We could define a function similar to <code>with_pc</code>
and write the following instead:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">interpretProgram</span>(<span style="font-weight: bold; font-style: italic;">AST</span>, <span style="font-weight: bold; font-style: italic;">env</span> = {}, <span style="font-weight: bold; font-style: italic;">store</span> = {}, <span style="font-weight: bold; font-style: italic;">default_pc</span> = []) {
  <span style="font-weight: bold;">return</span> with_ref((&#963;, &#952;, {e}) =&gt; { ... }, () =&gt;
                  with_pc(<span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>(default_pc), () =&gt;
                          base.interpretProgram(AST, env, store)));
}
</pre>
</div>

<p>
But at this point, having to write several ‚Äòwith&rsquo; functions becomes a
pattern we would like to abstract away once and for all.
</p>

<p>
Furthermore, this emulation is a brittle way of extending the
functionality.  First we add coupling by using the <code>base._innards</code>
interface; secondly we disallow any opportunity for combining
extensions (since we do not <i>extend</i> but <i>replace</i> the base
functionality).  A proper dynamic scoping of the <code>rules</code> object has
none of these downsides.
</p>

<p>
As a compromise, we can recognize that the pattern matching done for
AST nodes is trivial: the objects returned by <code>app</code>, <code>ref</code>, etc. only
have one method, <code>eval</code>.  Instead of returning objects, we can return
closures directly and eliminate the need for the <code>rules</code> object.
</p>

<p>
<a href="js/lab/closures/base.js">js/lab/closures/base.js</a>
<a href="js/lab/closures/facets.js">js/lab/closures/facets.js</a>
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ref</span>(<span style="font-weight: bold; font-style: italic;">e</span>) {
  <span style="font-weight: bold;">return</span> (&#963;, &#952;) =&gt; { ... };
}
</pre>
</div>

<p>
This allows us to override the functionality of <code>ref</code> using a
namespace, as we did in the object-oriented approach.
</p>
</div></li>

<li><a id="orgheadline75"></a>Summary<br ><div class="outline-text-6" id="text-orgheadline75">
<p>
The two solutions (global variable and context object) for dealing
with the extra ‚Äòpc&rsquo; parameter can be applied here as well.  The same
remarks apply.
</p>

<p>
However, extending the <code>ref</code> function requires the ability to modify
values inside the closures of the evaluation function <code>interpretNode</code>.
This ability is not provided by the language, but shadowing the <code>ref</code>
function (or the rules object, or the <code>interpretNode</code> dispatcher) by
using dynamic scoping achieves the same effects.
</p>
</div></li></ul>
</div>

<div id="outline-container-orgheadline77" class="outline-5">
<h5 id="orgheadline77">Summary of JavaScript variations</h5>
<div class="outline-text-5" id="text-orgheadline77">
<p>
It appears that, the more the interpreter rely on dynamic features,
the easier it is to instrument.  The <i>dynamic dispatching</i> of the
object-oriented interpreter allows the effortless addition of the
<code>facet</code> value.  In all the other cases, <i>dynamic scoping</i> was
prescribed.  We also saw that <i>dynamic typing</i> was required at least
in the ‚Äòcontext object&rsquo; solution to the extra ‚Äòpc&rsquo; argument.
</p>

<p>
Intuitively, it makes sense.  We want different instances of the same
names (<code>interpretProgram</code>, <code>ref</code>, <code>rules</code>) to have different
behaviors, depending on context.  This is exactly what dynamic
dispatching is for: the same method slot can refer to different
implementations, depending on the actual instance of the receiver.
This is also the difference between lexical and dynamic scoping: the
former binds free names to their static surrounding context at
definition time, while the latter binds free names to their caller&rsquo;s
context at runtime.
</p>

<p>
In a language with dynamic scoping the interpreter should be a breeze
to instrument.  That is the focus of the <a href="#orgheadline76">Lisp variations</a>.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline76" class="outline-3">
<h3 id="orgheadline76"><span class="section-number-3">5.2</span> Lisp</h3>
<div class="outline-text-3" id="text-5-2">
<p>
<a href="lisp/pm.lisp">lisp/pm.lisp</a>
</p>

<p>
Common Lisp offers both lexical and dynamic scoping of variables.  We
implement the pattern-matching standard interpreter by defining the
<code>*rules*</code> object to be dynamically scoped (by using <code>defparameter</code>).
We follow the Common Lisp convention of using stars to surround a
dynamically-scoped name.
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*rules*</span>
  `((c . ,(<span style="font-weight: bold;">lambda</span> (s env node) ...))

    (ref . ,(<span style="font-weight: bold;">lambda</span> (s env node) ...))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">eval-node</span> (store env node)
  (<span style="font-weight: bold;">let</span> ((f (lookup (car node) *rules*)))
    (funcall f store env node)))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">eval-program</span> (AST env store)
  (eval-node store env AST))

(eval-program
 '(app (fun <span style="font-style: italic;">"x"</span> (deref (v <span style="font-style: italic;">"x"</span>)))
       (ref (c 42)))
 '() '())
</pre>
</div>

<p>
Instrumentation is then effortless.  First we define facet-specific
rules by extending the basic rules objects (<code>append ... *rules*</code>).
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*facets/rules*</span>
  (append
   `((ref . ,(<span style="font-weight: bold;">lambda</span> (s env node)
               ...
               (mk-facet *pc* v1 bottom)
               ...)))
   *rules*
   ))

(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*facets/application-rules*</span> ...)
(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*facets/deref-rules*</span> ...)
(<span style="font-weight: bold;">defparameter</span> <span style="font-weight: bold; font-style: italic;">*facets/assign-rules*</span> ...)
</pre>
</div>

<p>
Note the reference to the free dynamic variable <code>*pc*</code>.  In the entry
point to facet evaluation, we override the standard rules with the new
ones.  We also declare the <code>*pc*</code> argument to be dynamically scoped
inside this call, using <code>(declare (special *pc*))</code>.
</p>

<div class="org-src-container">

<pre class="src src-lisp">(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">facets/eval-program</span> (AST env store *pc*)
  (<span style="font-weight: bold;">declare</span> (special *pc*))
  (<span style="font-weight: bold;">let</span> ((*rules* *facets/rules*)
        (*application-rules* *facets/application-rules*)
        (*deref-rules* *facets/deref-rules*)
        (*assign-rules* *facets/assign-rules*))
    (eval-program AST env store)))

(facets/eval-program
 '(app (fun <span style="font-style: italic;">"x"</span> (deref (v <span style="font-style: italic;">"x"</span>)))
       (ref (c 42)))
 '() '() '(1))
</pre>
</div>

<p>
So as anticipated, dynamic scoping is an adequate solution to the
issues we ran into in the JavaScript variations.  But dynamic scoping
is not available in all languages.  As a fallback, we saw that a
language with mutable global variables could emulate dynamic scoping.
This begs the question: in an immutable language without dynamic
scoping, how do we deal with the problem of modular instrumentation?
</p>

<p>
Furthermore, we also saw that dynamic typing was useful in the
‚Äòcontext&rsquo; object case.  What if we want to benefit from the guarantees
provided by static types?  Is the modular instrumentation still
feasible?  Is it cumbersome to write?  That is the focus of the
<a href="#orgheadline80">Haskell variations</a>.
</p>
</div>
</div>

<div id="outline-container-orgheadline80" class="outline-3">
<h3 id="orgheadline80"><span class="section-number-3">5.3</span> Haskell</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Building scaffolding with languages features has the following
advantages:
</p>
<ul class="org-ul">
<li>No extra syntax or rewriting program required</li>
<li>In statically-typed Haskell, the scaffolding is type-checked</li>
</ul>

<p>
Downsides:
</p>
<ul class="org-ul">
<li>The scaffolding might is seldom straightforward</li>
<li>Extension + overriding of existing definitions leads to very complex
code</li>
</ul>

<p>
Extending the syntax is the same, with pros and cons inversed:
</p>
<ul class="org-ul">
<li>Extra syntax and rewriting program required</li>
<li>Rewritten program is type-checked, but transformation must be proven
correct</li>
</ul>

<p>
Advantages:
</p>
<ul class="org-ul">
<li>Lightweight syntax is straightforward to use</li>
<li>Overriding it still awkward to read</li>
</ul>
</div>

<div id="outline-container-orgheadline94" class="outline-4">
<h4 id="orgheadline94"><span class="section-number-4">5.3.1</span> Building scaffolding with language features</h4>
<div class="outline-text-4" id="text-5-3-1">
</div><div id="outline-container-orgheadline81" class="outline-5">
<h5 id="orgheadline81">Monadic interpreters</h5>
<div class="outline-text-5" id="text-orgheadline81">
<p>
The monadic interpreter is mostly taken from <a href="http://homepages.inf.ed.ac.uk/wadler/papers/essence/essence.ps">Wadler</a>.
</p>

<ul class="org-ul">
<li><a href="http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html">Monads Transformers and Modular Interpreters</a>
<ul class="org-ul">
<li><a href="http://www.cas.mcmaster.ca/~kahl/FP/2003/Interpreter.pdf">Haskell implementation</a></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline82" class="outline-5">
<h5 id="orgheadline82">Either data type</h5>
<div class="outline-text-5" id="text-orgheadline82">
<p>
See <a href="hs/extend-types/Extension.fail.1.hs">hs/extend-types/Extension.fail.1.hs</a>.  Types are extended like
so:
</p>

<pre class="example">
data FacetTerm  = Facet Principal FacetTerm FacetTerm | BaseTerm Term
</pre>
</div>

<ul class="org-ul"><li><a id="orgheadline83"></a>What does work<br ><div class="outline-text-6" id="text-orgheadline83">
<ul class="org-ul">
<li>Maximum reuse from the file ‚ÄòBase.hs&rsquo;</li>
<li>Able to execute `term0` and `term1`</li>
</ul>
</div></li>

<li><a id="orgheadline84"></a>What fails<br ><div class="outline-text-6" id="text-orgheadline84">
<ul class="org-ul">
<li>`term2` gives a type error:
&laquo;&nbsp;Couldn&rsquo;t match expected type `Term&nbsp;&raquo; with actual type `FacetTerm&nbsp;&raquo;&nbsp;&raquo;</li>
</ul>

<pre class="example">
term2 = (Lam "y" (Facet 0 (BaseTerm (Lam "x" Bot)) (BaseTerm Bot)))
</pre>

<ul class="org-ul">
<li>Also, have to wrap Base.Term values with the BaseTerm constructor</li>
</ul>
</div></li>

<li><a id="orgheadline85"></a>What I wanted<br ><div class="outline-text-6" id="text-orgheadline85">
<ul class="org-ul">
<li>`eval term2` gives the same result as when using Extended.eval.</li>

<li>The raw term1 and term2 should type without wrapping values.</li>
</ul>
</div></li>

<li><a id="orgheadline86"></a>Why it doesn&rsquo;t work<br ><div class="outline-text-6" id="text-orgheadline86">
<p>
A FacetTerm is either a Facet or a BaseTerm.  A Facet can contain
FacetTerms (and hence BaseTerms), but since BaseTerms are just Terms,
they cannot contain Facets.
</p>
</div></li>

<li><a id="orgheadline87"></a>Conclusion<br ><div class="outline-text-6" id="text-orgheadline87">
<p>
What we really want is to insert the constructor `Facet` into the
existing data type `Term`.
</p>
</div></li></ul>
</div>

<div id="outline-container-orgheadline88" class="outline-5">
<h5 id="orgheadline88">Type classes</h5>
<div class="outline-text-5" id="text-orgheadline88">
<p>
Another suggestion by R√©mi.
</p>

<div class="org-src-container">

<pre class="src src-haskell">interp :: Dom d =&gt; Term -&gt; d
interp (Add l r) = myAdd (interp l) (interp r)

class Dom d where
  myAdd :: d -&gt; d -&gt; d

instance Dom Int where
  myAdd = +

instance Dom OddOrEven where
  myAdd = xor
</pre>
</div>

<p>
Here you must generalize the interpreter, to accomodate multiple
domains.  But at least the generalization is done using types: the
overhead is minimal.  Though you still need to have indirect calls.
</p>

<p>
&gt; Ismael: Some disadvantages of this approach are discussed in the
Open Data Types paper, in Section 6.4.
</p>
</div>

<ul class="org-ul"><li><a id="orgheadline89"></a>Multi-param types classes<br ><div class="outline-text-6" id="text-orgheadline89">
<div class="org-src-container">

<pre class="src src-haskell">class Eval term value where
  eval :: term -&gt; value
</pre>
</div>

<p>
Becomes quite complicated rapidly.  First you need an extension, then
you quickly run into typing issues that are not worth the flexibility
offered by this strategy.
</p>
</div></li></ul>
</div>

<div id="outline-container-orgheadline91" class="outline-5">
<h5 id="orgheadline91">Data types √† la carte</h5>
<div class="outline-text-5" id="text-orgheadline91">
<p>
From Swierstra, 2008.
</p>

<p>
<a href="hs/extend-types/Extension.swierstra.hs">A first attempt</a>
</p>

<p>
<a href="hs/InterpreterALC.hs">Another one, with Ismael</a>
</p>

<p>
<a href="hs/ALC-Lambda.hs">Lambda calculus with references and bottom</a>
</p>

<p>
<a href="hs/ALC-Lambda-Facets.hs">Lambda calculus with faceted evaluation</a>
</p>

<p>
<a href="hs/ALC-Facets-Flow.hs">Lambda calculus with faceted evaluation and FlowR tainting</a>
</p>

<p>
Overview of this scaffolding:
</p>

<p>
Pros:
</p>
<ul class="org-ul">
<li>Allows type-checked extension of terms</li>
</ul>

<p>
Cons:
</p>
<ul class="org-ul">
<li>Quite hairy</li>
<li>Cannot change the resulting value with using the same approach for
the value type, which would be even <i>hairier</i>.</li>
</ul>

<p>
See also my <a href="#orgheadline90">my second attempt</a> at Swierstra, in 2015.
</p>
</div>
</div>

<div id="outline-container-orgheadline92" class="outline-5">
<h5 id="orgheadline92">Implicit arguments</h5>
<div class="outline-text-5" id="text-orgheadline92">
<p>
A simple idea: implicit arguments can replace global variables.
</p>

<p>
Unfortunately, describing an override of the base eval function is still an
issue.  Maybe use type classes?
</p>

<p>
See <a href="hs/implicit">implicit</a>.
</p>
</div>
</div>

<div id="outline-container-orgheadline93" class="outline-5">
<h5 id="orgheadline93">Facets as a monad</h5>
<div class="outline-text-5" id="text-orgheadline93">
<p>
The faceted evaluation strategy requires a new state global: the program
counter.  It makes sense to add this state in a state monad to a monadic
interpreter.  This can be done using monad transformers, or monad views, or
whatever is more convenient.
</p>

<p>
But maybe we can also view facet values themselves as a specific case of the
list monad.
</p>

<p>
See <a href="hs/list-monad/">list-monad</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline95" class="outline-4">
<h4 id="orgheadline95"><span class="section-number-4">5.3.2</span> Extending the syntax</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
See <a href="hs/transform/notes.html">hs/transform/notes.html</a>
</p>

<p>
<a href="hs/transform/tests/2/LC.hs">Lambda calculus with FlowR instrumentation</a>
</p>

<ul class="org-ul">
<li>Cannot override existing definitions (like one would do with aspects)</li>
<li>Extending the monadic stack is best done with scaffolding, though
obliviousness is lost</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline99" class="outline-3">
<h3 id="orgheadline99"><span class="section-number-3">5.4</span> Modular monadic interpreters</h3>
<div class="outline-text-3" id="text-5-4">
</div><div id="outline-container-orgheadline97" class="outline-4">
<h4 id="orgheadline97"><span class="section-number-4">5.4.1</span> The giants</h4>
<div class="outline-text-4" id="text-5-4-1">
<p>
There&rsquo;s a body of work on monadic interpreters in functional programming
languages built around monads, dating from the ‚Äò90s.
</p>

<p>
Starting with Eugenio Moggi lectures at Edinburgh in 1990, then followed by
Wadler, Steele, Hudak and Jones.
</p>

<ul class="org-ul">
<li>Eugenio Moggi.  An abstract view of programming languages. 1990</li>
<li>Philip Wadler.  The essence of functional programming. 1992</li>
<li>Guy Steele.  Building interpreters by composing monads. 1994</li>
<li>Sheng Liang, Paul Hudak, Mark Jones.  Monad Transformers and Modular
Interpreters. 1995</li>
<li>Luc Duponcheel.  Using catamorphisms, subtypes and monad transformers for
writing modular functional interpreters.  1995</li>
<li>David Spinoza.  Semantic Lego (thesis).  1995</li>
</ul>

<p>
Then there is the, more recent, use of the free monad to build DSLs and
interpreters in functional languages.  Swierstra reports that free monads were
well-known in category theory, but unfamiliar to functional programmers.
</p>

<ul class="org-ul">
<li>Wouter Swierstra.  Data types √† la carte.  2008</li>
<li>Tom Schrijvers, Bruno C.d.S. Oliveira.  Functional Pearl: The Monad Zipper.
2010</li>
<li>Oleg Kiselyov, Amr Sabry, Cameron Swords.  Extensible Effects &#x2013; An
Alternative to Monad Transformers.  2013</li>
<li>R√∫nar √ìli.  Compositional application architecture with reasonably-priced
monads (Scala Days talk).  2014</li>
</ul>

<p>
On the other side of the fence, in OO-land, the go-to solution is a mix of
modules and design patterns.
</p>

<ul class="org-ul">
<li>Robert Bruce Findler and Matthew Flatt.  Modular Object-Oriented Programming
with Units and Mixins.  1998</li>
<li>Bruno C.d.S. Oliveira.  Modular Visitor Components &#x2013; A practical Solution to
the Expression Families Problem.  2009</li>
<li>Brudo C.d.S. Oliveira, William R. Cook.  Extensibility for the Masses &#x2013;
Practical Extensibility with Object Algebras.  2012</li>
</ul>
</div>

<div id="outline-container-orgheadline90" class="outline-5">
<h5 id="orgheadline90">Data types  √† la carte (2015)</h5>
<div class="outline-text-5" id="text-orgheadline90">
<p>
Re-reading Swiestra in 2015, my brain parses it much better.
</p>

<ul class="org-ul">
<li>Coproduct is just disjoint-union.</li>
<li><p>
Construction of values of the coproduct type are unwieldy, hence the recourse
to type classes that will automatically call the right injection into the
coproduct based on the type of the expression.  Expression types are required,
otherwise the compiler cannot find the right injection.
</p>

<p>
The use class constraints and instances to automatically figure out the right
injection is quite clever.
</p></li>
<li>Can&rsquo;t we derive functors, for the coproduct, since they seem rather
straightforward?  We can.  Probably `deriving Functor` was not available in
Haskell in 2008, when Swierstra wrote it.</li>
<li>We can give a larger type signature than necessary, since the compiler cannot
infer it for us.  <code>Add :+: Val :+: Add :+: Val</code> is perfectly acceptable.  In
practice, this is harmless.</li>
<li>While we can easily extend the language and compose languages using this
approach, modifying behavior requires defining a new algebra.  Can we re-use
parts of a previous algebra?  There is no clue as to how to achieve that in
this paper.</li>
<li>Having terms appear in the signature to programs gives you guarantees for
free.  As illustrated in the paper, a program of type <code>Term Recall Int</code> (&sect;6)
will never modify the value of the memory cell.  Also the topic of &sect;7, and
related work on type systems for effects.</li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline96" class="outline-5">
<h5 id="orgheadline96">Wadler ‚Äî The essence of functional programming</h5>
<div class="outline-text-5" id="text-orgheadline96">
<p>
How to build a monadic interpreter.  Also serves as a tutorial on monads.
</p>

<p>
An interpreter just creates computations inside a monad M.  By changing the
definition of M (its type, unit and bind) <i>and other small changes</i>, one is able
to change the evaluation order of arguments (from call-by-value to
call-by-name), or give a non-deterministic interpreter.
</p>

<p>
Plugging the identity monad reduces the monadic interpreter to a straightforward
lambda-calculus interpreter, showing that the monadic interpreter is a
generalization.
</p>

<p>
Variation one already requires changes in addition to redefining the monad.
This is inevitable to be able to distinguish between calls of <code>unitM</code> that
signal errors from calls that produce ground values.
</p>

<p>
Variation two requires to extend the <code>interp</code> function.  The current position is
saved in the <code>P</code> monad, which is akin to a &laquo;&nbsp;forgetful&nbsp;&raquo; state monad.
</p>

<p>
One important observation on monadic interpreters is that if the interpreter
code needs to interact with the monad (e.g., for resetting the current
position), then the <code>interp</code> code needs to make a call to <code>resetP</code>.  Monads are
not oblivious at all in this case.  But if the interpreter code does not need to
interact with the monad, then changes to the monad can affect the meaning of the
interpreter in an oblivious fashion.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline98" class="outline-4">
<h4 id="orgheadline98"><span class="section-number-4">5.4.2</span> The bigger picture</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
In the solutions from the functional programming world, the idea seems to
revolve around reifying the computation (the target program of an interpreter),
and write different interpreters.  In other words, to achieve modularity, one
must turn behavior into data: data has no effect unless it is executed by some
interpreter and turned into an actual computation.
</p>

<p>
So, essentially we are writing programs in a DSL of which we know one
interpreter (hopefully).  This is high-level, programming the specification.
Then we are free to write other interpreters for the same program, to change its
meaning slightly.
</p>

<p>
The connection to DSLs of course brings works from other communities to the
table.
</p>

<p>
Viewing the interpreter as data is something that is free in Lisps.  The code
can always be seen as a data structure that is easily parsed.  If turning your
code to data gives you the greatest modularity, then homoiconic languages have
a clear advantage of not requiring a parser.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline105" class="outline-2">
<h2 id="orgheadline105"><span class="section-number-2">6</span> <span class="todo TRANSLATE">TRANSLATE</span> Construire un interpr√©teur par modules</h2>
<div class="outline-text-2" id="text-6">
<p>
<i>Contenu principalement tir√© d&rsquo;un papier pr√©sent√© √† l&rsquo;atelier LASSY&rsquo;15 [<a href="#KNS-15">MdKNS15b</a>]</i>.
</p>

<p>
√âtendre un interpr√©teur peut √™tre vu comme une extension du probl√®me de
l&rsquo;expression [<a href="#Wad-98">Wad98</a>].  Wadler d√©finit le problem de l&rsquo;expression ainsi:
</p>

<blockquote>
<p>
The Expression Problem is a new name for an old problem.  The goal is to define
a datatype by cases, where one can add new cases to the datatype and new
functions over the datatype, without recompiling existing code, and while
retaining static type safety (e.g., no casts).
</p>
</blockquote>

<p>
Mais l√† o√π le probl√®me de l&rsquo;expression ne s&rsquo;int√©resse qu&rsquo;√† √©tendre un langage
par de <i>nouveaux</i> termes, dans notre cas on cherche √©galement √† <i>modifier</i> des
termes existants.
</p>

<p>
Suivons l&rsquo;exemple du langage minimal propos√© par Wadler (mais √©galement utilis√©
par Odersky et Zenger [<a href="#OZ-05">OZ05</a>]), un langage d&rsquo;expressions arithm√©tiques qu&rsquo;on va
augmenter par morceaux.
</p>
</div>

<div id="outline-container-orgheadline101" class="outline-3">
<h3 id="orgheadline101"><span class="section-number-3">6.1</span> Ajouter des termes</h3>
<div class="outline-text-3" id="text-6-1">
<p>
Le premier langage a un terme unique pour repr√©senter des constantes, et une
op√©ration pour √©valuer cette constante vers sa valeur.  Pour impl√©menter ce
terme, on utilise une d√©composition objet en JavaScript, qui rappelle le patron
<i>Interpreter</i> de [<a href="#GHJ+94">GHJ+94</a>].
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {
  <span style="font-weight: bold;">new</span>(n) { <span style="font-weight: bold;">return</span> {__proto__: <span style="font-weight: bold; text-decoration: underline;">this</span>, n} },
  eval() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n }
}

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e1</span> = num.<span style="font-weight: bold;">new</span>(3)
e1.eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
</pre>
</div>

<aside>
<p>
Dans les programmes de ce chapitre, le trigramme <code>//:</code> indique la valeur de
l&rsquo;expression qui pr√©c√®de.  C&rsquo;est la syntaxe de l&rsquo;√©diteur interactif [<a href="#s3c">s3c</a>].
</p>
</aside>


<figure>
<p><img src="img/lassy-0.svg" alt="lassy-0.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;27&nbsp;:</span> Repr√©sentation de la m√©moire du programme apr√®s la cr√©ation de l&rsquo;objet <code>num</code>, mais avant la cr√©ation de <code>e1</code>.</figcaption>
</figure>

<p>
L&rsquo;objet <code>num</code> comporte deux fonctions: <code>new</code> pour retourner un objet qui pour
prototype <code>this</code> et contient la valeur <code>n</code> de la constante; et <code>eval</code> pour
retourner cette constante ult√©rieurement.  √Ä la derni√®re ligne, on appelle
<code>eval</code> sur l&rsquo;instance <code>e1</code> de la constante 3, et c&rsquo;est bien le r√©sultat
obtenu.
</p>

<p>
Le second terme repr√©sente l&rsquo;addition entre deux constantes.  Dans notre
impl√©mentation par objets, un nouveau terme est simplement ajout√© en cr√©ant un
objet <code>plus</code> avec une fonction <code>eval</code>.  L&rsquo;√©valuation de <code>plus</code> appelle
r√©cursivement la fonction <code>eval</code> sur les op√©randes de l&rsquo;addition.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">plus</span> = {
  <span style="font-weight: bold;">new</span>(l, r) { <span style="font-weight: bold;">return</span> {__proto__: <span style="font-weight: bold; text-decoration: underline;">this</span>, l, r } },
  eval() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.l.eval() + <span style="font-weight: bold; text-decoration: underline;">this</span>.r.eval() }
}

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e2</span> = plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2))
e2.eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline102" class="outline-3">
<h3 id="orgheadline102"><span class="section-number-3">6.2</span> Ajouter des op√©rations</h3>
<div class="outline-text-3" id="text-6-2">
<p>
Maintenant on souhaite ajouter une seconde op√©ration au langage: afficher une
expression plut√¥t que l&rsquo;√©valuer.  Dans certains langages objets, ajouter une
op√©ration ne serait pas aussi simple que d&rsquo;ajouter un terme.  La tension entre
ces deux axes d&rsquo;extension (ajouter des termes / ajouter des op√©rations) est au
c≈ìur du probl√®me de l&rsquo;expression.  En JavaScript, ajouter une op√©ration se fait
simplement:
</p>

<div class="org-src-container">

<pre class="src src-js">num.show = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n.toString() }
plus.show = <span style="font-weight: bold;">function</span>() {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.l.show() + <span style="font-style: italic;">'+'</span> + <span style="font-weight: bold; text-decoration: underline;">this</span>.r.show() }

plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "1+2"</span>
e1.show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "3"</span>
e2.show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "1+2"</span>
</pre>
</div>

<p>
Les deux premi√®res lignes √©tendent les objets <code>num</code> et <code>plus</code> avec l&rsquo;op√©ration
<code>show</code>.  Comme l&rsquo;attestent les lignes suivantes, cette nouvelle op√©ration est
disponible sur de nouvelles instances de termes, mais √©galement sur des
instances cr√©√©es <i>avant</i> l&rsquo;ajout de l&rsquo;op√©ration.  Cette flexibilit√© du langage
est pratique pour √©tendre un interpr√©teur sans avoir √† le relancer, ni
reconstruire l&rsquo;AST d&rsquo;un programme.  On peut ainsi √©tendre un syst√®me pendant
qu&rsquo;il s&rsquo;ex√©cute, et √©valuer un m√™me programme avec diff√©rentes version de
l&rsquo;interpr√©teur.
</p>

<p>
En revanche, dans certains cas on peut vouloir pr√©server les versions
ant√©rieures de <code>num</code> et <code>plus</code>, et cr√©er des d√©riv√©s qui poss√®dent l&rsquo;op√©ration
<code>show</code>.  On ne peut pas donner √† ces d√©riv√©s les m√™me noms que les objets
originaux, donc on utilise un nouvel objet en tant qu&rsquo;espace de nom.  On ne
souhaite pas non plus coupler pr√©matur√©ment les d√©riv√©s de <code>num</code> et <code>plus</code> aux
objets dont ils d√©rivent; on abstrait donc ces objets parents √† l&rsquo;aide d&rsquo;une
fonction.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">show</span> = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">base</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {__proto__: base.num,
    show() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n.toString() }}

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">plus</span> = {__proto__: base.plus,
    show() { <span style="font-weight: bold;">return</span>.<span style="font-weight: bold; text-decoration: underline;">this</span>.l.show() + <span style="font-style: italic;">'+'</span> + <span style="font-weight: bold; text-decoration: underline;">this</span>.r.show() }}

  <span style="font-weight: bold;">return</span> {num, plus} }

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">s</span> = show({num, plus})
e2.show <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: undefined</span>
s.plus.<span style="font-weight: bold;">new</span>(s.num.<span style="font-weight: bold;">new</span>(1), s.num.<span style="font-weight: bold;">new</span>(2)).show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "1+2"</span>
s.plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), s.num.<span style="font-weight: bold;">new</span>(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
</pre>
</div>

<p>
Le code √©mule un syst√®me de module: la fonction <code>show</code> prend un objet qui
contient les noms import√©s en argument et retourne les noms export√©s dans un
autre objet.  Apr√®s la d√©finition de <code>show</code>, une expression d√©j√† construite,
comme <code>e2</code>, ne fait pas r√©f√©rence √† l&rsquo;op√©ration <code>show</code>.  Mais une op√©ration
construire √† partir des nouveaux termes <code>s.plus</code> et <code>s.num</code> peut √™tre √©valu√©e
avec <code>eval</code> ou affich√©e avec <code>show</code>.
</p>

<p>
√Ä la derni√®re ligne on voit qu&rsquo;il est m√™me possible de mixer des termes qui
supportent l&rsquo;op√©ration <code>show</code> et ceux qui ne la supportent pas: le premier
argument de <code>s.plus.new</code> est <code>num.new</code> et le second <code>s.num.new</code>.  Puisqu&rsquo;on
appelle <code>eval</code> sur l&rsquo;expression retourn√©e, et que tous les termes supportent
cette op√©ration, √ßa ne pose aucun probl√®me.  Mais puisque JavaScript n&rsquo;est pas
typ√© statiquement, rien ne nous emp√™che d&rsquo;appeler l&rsquo;op√©ration <code>show</code> sur une
expression de termes mix√©s, ce qui d√©clencherait une erreur √† l&rsquo;ex√©cution.
</p>

<p>
C&rsquo;est possible d&rsquo;emp√™cher l&rsquo;√©criture de telles expressions en rendant les
r√©f√©rences vers les <code>num</code> et <code>plus</code> originaux inaccessibles.  En utilisant la
construction <code>with</code> de JavaScript sur un objet, toutes les propri√©t√©s de cet
objet sont mises dans l&rsquo;environnement du code d√©limit√© par <code>with</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">with</span> (show({num,plus})) {
  plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "1+2"</span>
}
</pre>
</div>

<p>
L&rsquo;expression construite √† l&rsquo;int√©rieur du bloc d√©limit√© par <code>with</code> fait r√©f√©rence
simplement √† <code>num</code> et <code>plus</code>.  Mais ici, comme nous somme dans le corps du
<code>with</code>, <code>num</code> et <code>plus</code> font r√©f√©rence aux objets retourn√©s par l&rsquo;appel de
<code>show</code>.  Les objets <code>num</code> et <code>plus</code> originaux sont en revanche inaccessibles car
les noms des d√©riv√©s cachent les d√©finitions initiales dans l&rsquo;environnement.  Un
autre aspect de cette construction est que les d√©riv√©s de <code>num</code> et <code>plus</code>
existent uniquement dans le corps du <code>with</code>, on peut donc restreindre
l&rsquo;activation de l&rsquo;op√©ration <code>show</code>.
</p>

<p>
Utiliser <code>with</code> ne nous permet de choisir quels noms importer du module <code>show</code>:
toutes les propri√©t√©s de l&rsquo;objet pass√© en argument √† <code>with</code> sont mises dans la
port√©e du code d√©limit√© par <code>with</code>.  Si on doit plut√¥t importer un sous-ensemble
de ces propri√©t√©s, alors on peut utiliser une fonction invoqu√©e imm√©diatement
pour s√©lectionner les noms qui nous int√©ressent.  Par exemple, pour importer
juste le nouveau terme <code>num</code>:
</p>

<div class="org-src-container">

<pre class="src src-js">(<span style="font-weight: bold;">function</span>({num}) {
  num.<span style="font-weight: bold;">new</span>(1).show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "1"</span>
}(show({num,plus}))
</pre>
</div>

<p>
Cet exemple montre que le <code>with</code> n&rsquo;est pas strictement n√©cessaire, car une
fonction peut le remplacer.  N√©anmoins, c&rsquo;est une des rares situations o√π il est
l√©gitime d&rsquo;utiliser cette construction controvers√©e.  Puisque les exemples sont
plus lisibles avec <code>with</code> qu&rsquo;avec une fonction, on continuera de l&rsquo;utiliser dans
les extraits de code qui suivent.
</p>

<p>
Jusqu&rsquo;ici, on a vu comment:
</p>
<ul class="org-ul">
<li>ajouter de nouveaux termes au langage en d√©finissant un objet,</li>
<li>ajouter de nouvelles op√©rations,</li>
</ul>

<p>
et cela sans modifier du code √©crit au pr√©alable.  Essentiellement, on a montr√©
comment r√©soudre le probl√®me de l&rsquo;expression comme il s&rsquo;applique √† JavaScript;
c&rsquo;est √† dire sans garantie de typage statique.
</p>

<p>
En passant, on a vu comment ajouter des op√©rations de deux fa√ßons diff√©rentes:
soit en modifiant directement le prototype des objets repr√©sentants les termes
pour y ajouter les op√©rations, soit en d√©rivant les prototypes.  Dans la
premi√®re solution, tous les objets ob√©issent aux m√™mes op√©rations.  Dans la
seconde solution, on peut mixer des termes qui ne supportent pas toutes les
op√©rations, ce qui peut causer une erreur √† l&rsquo;ex√©cution.  C&rsquo;est alors qu&rsquo;on peut
restreindre les termes utilisables dans un bloc de code en utilisant <code>with</code>, ou
une fonction.
</p>
</div>
</div>

<div id="outline-container-orgheadline103" class="outline-3">
<h3 id="orgheadline103"><span class="section-number-3">6.3</span> Modifier des op√©rations</h3>
<div class="outline-text-3" id="text-6-3">
<p>
On va maintenant s&rsquo;int√©resser √† modifier des op√©rations.  Par exemple, en
changeant le comportement de l&rsquo;op√©ration <code>eval</code> pour renvoyer le double d&rsquo;une
constante.
</p>

<p>
√áa reste simple √† exprimer en JavaScript, puisque les fonctions contenues dans
des objets sont comme les autres propri√©t√©s: rempla√ßables √† tout moment par
simple assignation.  On a utilis√© l&rsquo;assignation pour ajouter <code>show</code>, maintenant
on s&rsquo;en sert pour √©craser la d√©finition de <code>eval</code> et la remplacer par une
nouvelle:
</p>

<div class="org-src-container">

<pre class="src src-js">num.eval = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n * 2 }

num.<span style="font-weight: bold;">new</span>(1).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 6</span>
</pre>
</div>

<p>
Maintenant, une variante.  Plut√¥t que de retourner le double de <code>n</code>,
l&rsquo;√©valuation d&rsquo;un <code>num</code> doit retourner le double du r√©sultat de l&rsquo;√©valuation
d&rsquo;origine.  Pour impl√©menter cette variante, il nous faut pouvoir faire
r√©f√©rence √† l&rsquo;√©valuation d&rsquo;origine dans la nouvelle version de <code>num.eval</code>.  On
peut sauvegarder la version d&rsquo;origine dans une fermeture:
</p>

<div class="org-src-container">

<pre class="src src-js">(<span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">previous_eval</span>) {
  num.eval = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> previous_eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) * 2 }
}(num.eval))

num.<span style="font-weight: bold;">new</span>(1).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 6</span>
</pre>
</div>

<aside>
<p>
Une fonctionnalit√© similaire au mot-cl√© <code>proceed</code> en AspectJ et autres langages
√† aspects.
</p>
</aside>

<p>
Il ne reste plus qu&rsquo;√† appeler cette version ant√©rieure en lui passant l&rsquo;objet
courant comme receveur √† l&rsquo;aide de l&rsquo;appel <code>call(this)</code>.
</p>

<p>
Mais modifier l&rsquo;objet <code>num</code> d&rsquo;origine de cette fa√ßon est destructif: la fonction
<code>num.eval</code> d&rsquo;origine n&rsquo;est sauvegard√©e que dans la fermeture, et inaccessible
par la suite.  C&rsquo;est un mauvais choix si on souhaite rendre l&rsquo;interpr√©teur
extensible.  Dans ce cas, on peut plut√¥t cr√©er un nouveau terme qui fait
r√©f√©rence √† la fonction <code>num.eval</code> pour √©viter la duplication de code.  Pour
cela, on cr√©e une fonction qui sert de module, param√©tr√©e par l&rsquo;objet <code>num</code>
d&rsquo;origine:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; text-decoration: underline;">double</span> = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">base</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {__proto__: base.num,
    eval() { <span style="font-weight: bold;">return</span> base.num.eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) * 2 }}
  <span style="font-weight: bold;">return</span> {num} }

<span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) {
  plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 6</span>
}
</pre>
</div>

<p>
Dans le module <code>double</code>, on red√©finit <code>eval</code> √† partir de l&rsquo;√©valuation
pr√©c√©dente.  Ceci nous permet de <i>composer</i> les modifications d&rsquo;op√©rations en
passant une base modifi√©e comme param√®tre au module <code>double</code>.  L&rsquo;exemple qui
suit illustre comment combiner ces extensions avec des appels de <code>with</code> en
cascade:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) {
  <span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) {
    <span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) {
      plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 24</span>
}}}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline104" class="outline-3">
<h3 id="orgheadline104"><span class="section-number-3">6.4</span> Passer de l&rsquo;√©tat aux op√©rations</h3>
<div class="outline-text-3" id="text-6-4">
<p>
Dans l&rsquo;instrumentation de Narcissus pour l&rsquo;√©valuation √† facettes, on a vu que de
l&rsquo;√©tat √©tait pass√© r√©cursivement dans l&rsquo;interpr√©teur: le <i>program counter</i>.
Pour simuler cette situation dans notre interpr√©teur de langage arithm√©tique, on
va compter le nombre d&rsquo;appels √† <code>eval</code>.
</p>

<p>
Pour cela, on √©crit une fonction <code>state</code> qui d√©rive des termes <code>num</code> et <code>plus</code>
et incr√©mente une variable locale lors d&rsquo;un appel √† <code>num.eval</code> ou <code>plus.eval</code>.
L&rsquo;√©valuation est ensuite d√©l√©gu√©e aux prototypes de ces termes.  La valeur du
compteur est accessible via la fonction <code>getCount</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">state</span> = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">base</span>, <span style="font-weight: bold; font-style: italic;">count</span> = 0) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {__proto__: base.num,
    eval() { count++; <span style="font-weight: bold;">return</span> base.num.eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) }}

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">plus</span> = {__proto__: base.plus,
    eval() { count++; <span style="font-weight: bold;">return</span> base.plus.eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) }}

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">getCount</span> = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> count }

  <span style="font-weight: bold;">return</span> {num, plus, getCount}}

<span style="font-weight: bold;">with</span> (state({num,plus})) {
  getCount() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 0</span>
  plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
  getCount() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
}
</pre>
</div>

<p>
Lors du premier appel √† <code>getCount</code>, le compteur est bien √† z√©ro, puisqu&rsquo;aucune
instruction n&rsquo;a √©t√© √©valu√©e.  Le second appel retourne 3, apr√®s l&rsquo;√©valuation de
l&rsquo;expression, ce qui correspond bien aux 3 appels de <code>eval</code>: un pour <code>plus</code>, et
un pour chaque <code>num</code>.
</p>

<p>
Dans la d√©finition de <code>state</code>, les nouvelles versions de <code>eval</code> sont d√©finies √†
partir des termes pass√©s en argument dans l&rsquo;objet <code>base</code>, ce qui permet encore
une fois la composition d&rsquo;extensions.  Par exemple, on peut ajouter l&rsquo;extension
<code>double</code>:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) {
  <span style="font-weight: bold;">with</span> (state({num, plus})) {
    getCount() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 0</span>
    plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.enw(2)).eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 6</span>
    getCount() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
}}
</pre>
</div>

<p>
Le r√©sultat de l&rsquo;√©valuation est 6, ce qui indique que la modification <code>double</code>
est bien active.  En m√™me temps, le compteur fonctionne √©galement.  Notons que
l&rsquo;ordre d&rsquo;activation des modules n&rsquo;importe pas ici:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">with</span> (state({num, plus})) {
  <span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) { ... }}
</pre>
</div>

<p>
donnerait le m√™me r√©sultat.  La commutativit√© d√©pend de la d√©finition des
modules, bien entendu.  Dans le cas pr√©sent, le compteur peut √™tre vu comme un
effet de bord qui n&rsquo;interf√®re pas avec l&rsquo;√©valuation.
</p>

<p>
Enfin, on peut ajouter le module <code>show</code> sans avoir √† modifier une seule des
d√©finitions pr√©c√©dentes.  Ici encore, l&rsquo;ordre d&rsquo;activation des modules n&rsquo;a pas
d&rsquo;incidence sur le r√©sultat:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">with</span> (state({num, plus})) {
  <span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>({num})) {
    <span style="font-weight: bold;">with</span> (show({num, plus})) {
      getCount() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 0</span>
      <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">n</span> = plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2))
      n.eval() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 6</span>
      getCount() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 3</span>
      n.show() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: "1+2"</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline116" class="outline-2">
<h2 id="orgheadline116"><span class="section-number-2">7</span> Dynamic scoping to build interpreters</h2>
<div class="outline-text-2" id="text-7">
<p>
From the LASSY&rsquo;15 paper.
</p>

<p>
An arithmetic expression language, the example taken by Wadler and
Odersky as a base to propose solutions to the expression problem.
</p>
</div>

<div id="outline-container-orgheadline106" class="outline-3">
<h3 id="orgheadline106"><span class="section-number-3">7.1</span> The base datatype</h3>
<div class="outline-text-3" id="text-7-1">
<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock2"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {
  <span style="font-weight: bold;">new</span>: <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">n</span>) { <span style="font-weight: bold;">return</span> {__proto__: <span style="font-weight: bold; text-decoration: underline;">this</span>, n} },
  <span style="font-weight: bold;">eval</span>: <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n }};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e1</span> = num.<span style="font-weight: bold;">new</span>(3);
print(e1.eval());
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;

&lt;&lt;svg&gt;&gt;
redirect(<span style="font-style: italic;">'img/num.svg'</span>)
svg(ref(name(<span style="font-style: italic;">'e1'</span>),
        proto(obj(num.<span style="font-weight: bold;">new</span>(3)),
              ref(obj(num), name(<span style="font-style: italic;">'num'</span>),
                  {reversed:<span style="font-weight: bold; text-decoration: underline;">true</span>}))))
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline107" class="outline-3">
<h3 id="orgheadline107"><span class="section-number-3">7.2</span> Adding a data variant</h3>
<div class="outline-text-3" id="text-7-2">
<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock3"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">plus</span> = {
  <span style="font-weight: bold;">new</span>: <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">l</span>, <span style="font-weight: bold; font-style: italic;">r</span>) { <span style="font-weight: bold;">return</span> {__proto__: <span style="font-weight: bold; text-decoration: underline;">this</span>, l, r,} },
  <span style="font-weight: bold;">eval</span>: <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.l.eval() + <span style="font-weight: bold; text-decoration: underline;">this</span>.r.eval() }};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e2</span> = plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2));
print(e2.eval());
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline108" class="outline-3">
<h3 id="orgheadline108"><span class="section-number-3">7.3</span> Adding an operation</h3>
<div class="outline-text-3" id="text-7-3">
<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock4">num.show = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n.toString() }
plus.show = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.l.show() + <span style="font-style: italic;">'+'</span> + <span style="font-weight: bold; text-decoration: underline;">this</span>.r.show() }
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e2</span> = plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2));

&lt;&lt;show-invasive&gt;&gt;

print(e2.show()); <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">Dynamic extension, without recreating the expression</span>
print(plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).show());
</pre>
</div>

<p>
This extension is invasive: it modifies the prototypes of <code>num</code> and
<code>plus</code>.  If we want, we can extend safely both objects.
</p>
</div>
</div>

<div id="outline-container-orgheadline111" class="outline-3">
<h3 id="orgheadline111"><span class="section-number-3">7.4</span> Adding an operation as a module</h3>
<div class="outline-text-3" id="text-7-4">
<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock5"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">show</span> = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">base</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {__proto__: base.num,
    show() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n.toString() }};

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">plus</span> = {__proto__: base.plus,
    show() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.l.show() + <span style="font-style: italic;">'+'</span> + <span style="font-weight: bold; text-decoration: underline;">this</span>.r.show() }};

  <span style="font-weight: bold;">return</span> {num, plus};
};
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock6">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;
&lt;&lt;show&gt;&gt;

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">s</span> = show({num, plus});
print(s.plus.<span style="font-weight: bold;">new</span>(s.num.<span style="font-weight: bold;">new</span>(1), s.num.<span style="font-weight: bold;">new</span>(2)).show());
</pre>
</div>

<p>
Works, but can mix languages in unsafe ways:
</p>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;
&lt;&lt;show&gt;&gt;

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">s</span> = show({num, plus});

<span style="font-weight: bold;">try</span> { print(s.plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), s.num.<span style="font-weight: bold;">new</span>(2)).show()); }
<span style="font-weight: bold;">catch</span> (e) { print(e) }
</pre>
</div>
</div>

<div id="outline-container-orgheadline109" class="outline-4">
<h4 id="orgheadline109"><span class="section-number-4">7.4.1</span> A use-case for <code>with</code></h4>
<div class="outline-text-4" id="text-7-4-1">
<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;
&lt;&lt;show&gt;&gt;

<span style="font-weight: bold;">with</span>(show({num, plus})) {
  print(plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).show())
}
</pre>
</div>

<p>
Cannot mix languages anymore because of name shadowing: only one <code>num</code>
and one <code>plus</code> is known in the body of <code>with</code>, and they are both from
the same language.
</p>

<p>
Inside <code>with</code>, here is what we see:
</p>

<p>
Outside <code>with</code>, the <code>show</code> module is out of scope:
</p>
</div>
</div>

<div id="outline-container-orgheadline110" class="outline-4">
<h4 id="orgheadline110"><span class="section-number-4">7.4.2</span> Selective imports with an IIFE</h4>
<div class="outline-text-4" id="text-7-4-2">
<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;
&lt;&lt;show&gt;&gt;

(<span style="font-weight: bold;">function</span>({num}) {
  print(num.<span style="font-weight: bold;">new</span>(1).show())
}(show({num, plus})))
</pre>
</div>

<p>
Of course, here <code>plus</code> is in context, but we would actually put it in
a <code>base</code> module as well.
</p>

<p>
The two forms have a subtle difference: in a <code>with</code> we can modify the
values of the scope object by assigning to them, but in the IIFE,
assigning to the arguments has no effect outside the function.  In our
two examples, we always pass a fresh module so there is no issue.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline113" class="outline-3">
<h3 id="orgheadline113"><span class="section-number-3">7.5</span> Modifying an operation</h3>
<div class="outline-text-3" id="text-7-5">
<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;

num.eval = <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> <span style="font-weight: bold; text-decoration: underline;">this</span>.n * 2 }

print(num.<span style="font-weight: bold;">new</span>(1).eval())
print(plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval())
</pre>
</div>

<p>
Previous version of <code>num.eval</code> is lost: we have no reference to it
anymore.
</p>
</div>

<div id="outline-container-orgheadline112" class="outline-4">
<h4 id="orgheadline112"><span class="section-number-4">7.5.1</span> Non-destructive modification</h4>
<div class="outline-text-4" id="text-7-5-1">
<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock7">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; text-decoration: underline;">double</span> = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">num_orig</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {__proto__: num_orig,
    eval() { <span style="font-weight: bold;">return</span> num_orig.eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) * 2 }}
  <span style="font-weight: bold;">return</span> {num}
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;<span style="font-weight: bold; text-decoration: underline;">double</span>&gt;&gt;

<span style="font-weight: bold;">with</span>(<span style="font-weight: bold; text-decoration: underline;">double</span>(num)) {
  <span style="font-weight: bold;">with</span>(<span style="font-weight: bold; text-decoration: underline;">double</span>(num)) {
    print(plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval())
  }
}
</pre>
</div>

<p>
Inside the inner-most <code>with</code>, the objects in scope are the modified
<code>num</code>, and the original <code>plus</code>.
</p>

<p>
While after the <code>with</code>, <code>num</code> refers to the original, unmodified object.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline114" class="outline-3">
<h3 id="orgheadline114"><span class="section-number-3">7.6</span> Passing state</h3>
<div class="outline-text-3" id="text-7-6">
<p>
Add a program counter incremented each time a data variant calls
<code>eval</code>.
</p>

<div class="org-src-container">

<pre class="src src-js" id="orgsrcblock8"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">state</span> = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">base</span>, <span style="font-weight: bold; font-style: italic;">pc</span> = 0) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">num</span> = {__proto__: base.num,
             eval() { pc++; <span style="font-weight: bold;">return</span> base.num.eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) }}

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">plus</span> = {__proto__: base.plus,
             eval() { pc++; <span style="font-weight: bold;">return</span> base.plus.eval.call(<span style="font-weight: bold; text-decoration: underline;">this</span>) }}

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">getPC</span> = () =&gt; pc

  <span style="font-weight: bold;">return</span> {num, plus, getPC}
}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;
&lt;&lt;state&gt;&gt;

<span style="font-weight: bold;">with</span> (state({num, plus})) {
  print(getPC())
  print(plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2)).eval())
  print(getPC())
}
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline115" class="outline-3">
<h3 id="orgheadline115"><span class="section-number-3">7.7</span> All in one</h3>
<div class="outline-text-3" id="text-7-7">
<p>
Combine all the extensions without effort.
</p>

<div class="org-src-container">

<pre class="src src-js">&lt;&lt;num&gt;&gt;
&lt;&lt;plus&gt;&gt;
&lt;&lt;show&gt;&gt;
&lt;&lt;state&gt;&gt;
&lt;&lt;<span style="font-weight: bold; text-decoration: underline;">double</span>&gt;&gt;

<span style="font-weight: bold;">with</span> (state({num,plus})) {
  <span style="font-weight: bold;">with</span> (<span style="font-weight: bold; text-decoration: underline;">double</span>(num)) {
    <span style="font-weight: bold;">with</span> (show({num,plus})) {
      print(getPC())
      <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">n</span> = plus.<span style="font-weight: bold;">new</span>(num.<span style="font-weight: bold;">new</span>(1), num.<span style="font-weight: bold;">new</span>(2))
      print(n.eval())
      print(getPC())
      print(n.show())
    }}}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline134" class="outline-2">
<h2 id="orgheadline134"><span class="section-number-2">8</span> <span class="done STABLE">STABLE</span> √âtendre un interpr√©teur par manipulation de port√©e</h2>
<div class="outline-text-2" id="text-8">
<p>
<i>Chapitre principalement tir√© d&rsquo;un papier rejet√© √† DLS&rsquo;15 et √† SAC&rsquo;16 [<a href="#KNS-15b">MdKNS15a</a>]</i>.
</p>

<div class="epigraph">
<p>
The whole purpose of this work is to be able to modify the original interpreter
in the less possible intrusive way, and this appears to be the case, so I find
this work interesting, and since it is self-contained and properly grounded into
existing work, it is certainly worthy of publication. &#x2013;¬†Relecteur¬†DLS¬†n¬∞1
</p>

<p>
Readers not familiar with evaluation contexts and scoping will find that the
paper provides a didactic introduction to the concepts, but familiarised readers
will find the paper rather dull. &#x2013;¬†Relecteur¬†DLS¬†n¬∞2
</p>

<p>
The pattern is either elegant JavaScript hacking or severe abuse of
modularity. I can&rsquo;t tell which! I guess I like it. It illustrates how using
language constructs to implement your own module system, rather than having a
built-in one, enables it to be modified to allow
extensibility. &#x2013;¬†Relecteur¬†DLS¬†n¬∞3
</p>

<p>
I like the simplicity of the approach and the clever use of the &laquo;&nbsp;with&nbsp;&raquo; statement
semantics to achieve the dynamic extension of the scope from the outside code.
&#x2013;¬†Relecteur¬†SAC¬†n¬∞1
</p>

</div>

<p>
Nous avons vu dans l&rsquo;√©tude de cas que Narcissus n&rsquo;√©tait pas √©tendu de fa√ßon
modulaire.  Dans ce chapitre, on propose une fa√ßon simple d&rsquo;√©tendre cet
interpr√©teur, en se basant uniquement sur les fonctionnalit√©s pr√©sentes dans le
langage JavaScript.
</p>
</div>

<div id="outline-container-orgheadline120" class="outline-3">
<h3 id="orgheadline120"><span class="section-number-3">8.1</span> Manipuler la port√©e des variables pour l&rsquo;instrumentation</h3>
<div class="outline-text-3" id="text-8-1">
<p>
L&rsquo;ingr√©dient cl√© de cette section est la notion de <i>port√©e de variable</i>, et
comment manipuler cette port√©e.  Une variable d√©clar√©e dans une fonction n&rsquo;est
pas accessible depuis une autre fonction; on dit alors que la port√©e de cette
variable est la fonction dans laquelle elle est d√©finie, ou encore que la
variable est locale √† la fonction.  √Ä l&rsquo;inverse, une variable d√©clar√©e globale
sera accessible par tout point d&rsquo;ex√©cution du programme.
</p>

<p>
En JavaScript typiquement, on peut consid√©rer que l&rsquo;ensemble des variables
accessibles √† un point d&rsquo;ex√©cution donn√© est d√©termin√© par un objet qu&rsquo;on
appelle <i>l&rsquo;environnement</i>.  Un environnement associe chaque nom de variable √†
une valeur (valeur primitive comme un nombre, ou une r√©f√©rence vers un objet),
et poss√®de un lien vers un environnement parent.  Pour nos besoins, un
environnement est donc tr√®s similaire √† un objet JavaScript.
</p>

<p>
Les programmes donn√©s en exemple de cette section sont volontairement triviaux,
puisque ce sont les m√©canismes de manipulation de l&rsquo;environnement qui nous
int√©ressent, et non le code m√©tier.  √Ä la fin du chapitre, on applique ces
m√©canismes √† un cas concret, Narcissus.
</p>

<p>
Les exemples de code sont √©crits en suivant un sous-ensemble du standard
ECMAScript 5.1, que l&rsquo;on va enrichir avec la possibilit√© de manipuler des
environnements.  On ne donnera pas de s√©mantique de ce langage √©tendu, mais ces
manipulations seront expliqu√©es √† l&rsquo;aide de diagrammes qui pars√®ment ce
chapitre.  Les diagrammes refl√®tent le mod√®le qu&rsquo;on cherche √† atteindre; ce
mod√®le est inspir√© du fonctionnement de JavaScript, mais n&rsquo;est pas forc√©ment li√©
√† ce langage.  N√©anmoins, la seconde section montre comment impl√©menter ce
mod√®le en JavaScript.
</p>
</div>

<div id="outline-container-orgheadline117" class="outline-4">
<h4 id="orgheadline117"><span class="section-number-4">8.1.1</span> La port√©e dans le motif module</h4>
<div class="outline-text-4" id="text-8-1-1">
<p>
L&rsquo;interpr√©teur Narcissus est construit √† partir du motif module.  Il n&rsquo;y a pas
de syst√®me de module en JavaScript, et c&rsquo;est ce motif simple qui est souvent
utilis√© √† la place.  Le motif utilis√© par Narcissus se pr√©sente ainsi:
</p>

<aside>
<p>
Du moins, pas dans le standard ECMAScript 5.1.  Un syst√®me de module est propos√©
dans la prochaine version.
</p>
</aside>

<div class="org-src-container">

<pre class="src src-js"><span id="coderef-ex0-iife-start" class="coderef-off"><span class="linenr"> 1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">Narcissus</span> = (<span style="font-weight: bold;">function</span>(){</span>
<span id="coderef-ex0-defs-start" class="coderef-off"><span class="linenr"> 2: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">globalBase</span> = { ... }</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ExecutionContext</span>(<span style="font-weight: bold; font-style: italic;">type</span>, <span style="font-weight: bold; font-style: italic;">version</span>) { ... }
<span class="linenr"> 5: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">getValue</span>(<span style="font-weight: bold; font-style: italic;">v</span>) { ... }
<span class="linenr"> 6: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">putValue</span>(<span style="font-weight: bold; font-style: italic;">v</span>, <span style="font-weight: bold; font-style: italic;">w</span>) { ... }
<span id="coderef-ex0-defs-end" class="coderef-off"><span class="linenr"> 7: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">evaluate</span>(<span style="font-weight: bold; font-style: italic;">code</span>) { ... }</span>
<span class="linenr"> 8: </span>
<span id="coderef-ex0-return-start" class="coderef-off"><span class="linenr"> 9: </span>  <span style="font-weight: bold;">return</span> {</span>
<span class="linenr">10: </span>    globalBase: globalBase,
<span class="linenr">11: </span>    evaluate: evaluate,
<span class="linenr">12: </span>    ...
<span id="coderef-ex0-return-end" class="coderef-off"><span class="linenr">13: </span>  }</span>
<span id="coderef-ex0-iife-end" class="coderef-off"><span class="linenr">14: </span>}())</span>
</pre>
</div>

<p>
Le but de ce motif est de cr√©er un environnement pour toutes les d√©finitions du
module.  En JavaScript, une d√©finition faite √† la racine d&rsquo;un fichier (un
d√©claration de variable avec <code>var</code> ou une d√©finition de <code>function</code>) cr√©√©e une
entr√©e dans l&rsquo;environnement global.  Les entr√©es du l&rsquo;environnement global sont
accessibles en lecture et √©criture par n&rsquo;importe quel point du code, et m√™me par
du code d&rsquo;autres fichiers charg√©s dynamiquement.  Mettre ses d√©finitions dans
l&rsquo;environnement global a deux d√©savantages imm√©diats: 1) n&rsquo;importe quel code
peut √©craser ces d√©finitions, et 2) vos propres d√©finitions peuvent √©craser les
d√©finitions faites pr√©c√©demment par d&rsquo;autres fichiers, et m√™me √©craser des
parties de l&rsquo;API standard du langage.  √âcraser une d√©finition ne l√®ve pas
d&rsquo;erreur ou d&rsquo;avertissement en JavaScript; donc utiliser l&rsquo;environnement global
peut facilement casser du code charg√© pr√©c√©demment, et rend votre propre code
fragile pour les m√™mes raisons.  En outre, les diff√©rents moteurs d&rsquo;ex√©cution de
JavaScript peuvent proposer diff√©rentes extensions √† l&rsquo;API standard, ce qui se
traduit par diff√©rents noms suppl√©mentaires dans l&rsquo;environnement global.  Pour
toutes ces raisons, les programmeurs JavaScript apprennent rapidement √† enrober
leurs d√©finitions dans un environnement s√©par√©.  Cet environnement est cr√©e en
enrobant les d√©finitions dans une fonction, ouverte √† la ligne <a href="#coderef-ex0-iife-start"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-iife-start');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-iife-start');">1</a>
et ferm√©e √† la ligne <a href="#coderef-ex0-iife-end"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-iife-end');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-iife-end');">14</a>.  Toutes les d√©finitions de variables et
fonctions des lignes <a href="#coderef-ex0-defs-start"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-defs-start');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-defs-start');">2</a> √† <a href="#coderef-ex0-defs-end"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-defs-end');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-defs-end');">7</a> sont ainsi prot√©g√©es de
tout code ext√©rieur au module, car inaccessibles.
</p>

<p>
Si le module est l√† pour fournir une fonctionnalit√© sp√©cifique, ce qui est le
cas de l&rsquo;interpr√©teur qui fournit une fonction d&rsquo;√©valuation, alors il doit
exposer au moins une d√©finition au monde ext√©rieur, les exporter.  Exporter des
d√©finitions se fait √† travers un objet JavaScript (un simple dictionnaire, qui
associe des cha√Ænes de caract√®res √† des valeurs), aux lignes <a href="#coderef-ex0-return-start"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-return-start');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-return-start');">9</a>
√† <a href="#coderef-ex0-return-end"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-return-end');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-return-end');">13</a>.  Cet objet, appelons-le l&rsquo;objet export√©, est la valeur de
retour de la fonction qui cr√©√©e l&rsquo;environnement du module.
</p>

<p>
Enfin, l&rsquo;objet export√© est assign√© √† la variable <code>Narcissus</code> (ligne
<a href="#coderef-ex0-iife-start"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-iife-start');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-iife-start');">1</a>), une d√©finition faite √† la racine et qui peut √™tre utilis√©e
par n&rsquo;importe quel code charg√© dynamiquement, pour acc√©der √† la fonctionnalit√©
propos√©e par le module.  La fonction qui cr√©e l&rsquo;environnement du module est
appel√©e juste apr√®s sa d√©finition (les <code>()</code> ligne <a href="#coderef-ex0-iife-end"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex0-iife-end');" onmouseout="CodeHighlightOff(this, 'coderef-ex0-iife-end');">14</a> appellent la
fonction), on la nomme donc une <i>fonction imm√©diatement appel√©e</i>, ou FIA.
</p>

<p>
Essayons de comprendre exactement les m√©canismes du langage en jeu dans ce
module.  D&rsquo;abord, on va construire un exemple minimal de module qui a un
comportement observable:
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>(){
<span id="coderef-ex1-defs-start" class="coderef-off"><span class="linenr">2: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1</span>
<span class="linenr">3: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a }
<span id="coderef-ex1-defs-end" class="coderef-off"><span class="linenr">4: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x) }</span>
<span id="coderef-ex1-return" class="coderef-off"><span class="linenr">5: </span>  <span style="font-weight: bold;">return</span> {g: g}</span>
<span class="linenr">6: </span>}())
<span class="linenr">7: </span>
<span id="coderef-ex1-test" class="coderef-off"><span class="linenr">8: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span></span>
</pre>
</div>

<p>
On a ici un simple module qui retourne une seule fonction, <code>g</code>.  Cette fonction
appelle la fonction <code>f</code> et retourne sa valeur, et <code>f</code> √† son tour retourne
l&rsquo;addition de son argument et de <code>a</code>, une variable interne au module.  Quand on
appelle <code>m.g(0)</code> √† l&rsquo;ext√©rieur du module, on obtient <code>1</code>, qui est la valeur de
<code>a</code>.
</p>

<div style="margin-top:-20rem" class="side-figure">

<figure>
<p><img src="img/dls0.svg" alt="dls0.svg">
</p>
</figure>

</div>

<p>
Le diagramme illustre les environnements les objets cr√©es apr√®s l&rsquo;appel de le la
FIA et avant l&rsquo;appel de la ligne <code>m.g</code> √† la ligne <a href="#coderef-ex1-test"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex1-test');" onmouseout="CodeHighlightOff(this, 'coderef-ex1-test');">8</a>.  Les objets
JavaScript sont repr√©sent√©s par des bo√Ætes qui contiennent des paires.  Une
paire est une propri√©t√©, avec √† gauche le nom de la propri√©t√© et √† droite sa
valeur.  Lorsque la valeur de la pair est une r√©f√©rence, la case contient une
puce d&rsquo;o√π part un trait qui finit sur l&rsquo;objet r√©f√©renc√©.  Par exemple, on peut
voir l&rsquo;objet export√© √† gauche, qui a une propri√©t√© <code>g</code> qui pointe vers la
fonction <code>g</code>.
</p>

<p>
On repr√©sente les environnements avec des bo√Ætes √©galement, et l&rsquo;environnement
parent est reli√© par le trait qui part de la puce du coin sup√©rieur gauche de
l&rsquo;environnement.  Lorsqu&rsquo;un nom est recherch√© dans un environnement et que ce
nom n&rsquo;est pas pr√©sent dans les propri√©t√©s de cet environnement, la recherche
continue dans l&rsquo;environnement parent, et r√©cursivement jusqu&rsquo;√† ce que soit le
parent n&rsquo;existe pas, soit la propri√©t√© est trouv√©e.  L&rsquo;environnement global est
en haut √† gauche.
</p>

<p>
On peut expliquer le motif module en regardant le diagramme qui accompagne le
code.  Avant d&rsquo;ex√©cuter la code de l&rsquo;exemple, l&rsquo;environnement global est vide.
Lorsque la FIA est appel√©e, elle cr√©e l&rsquo;environnement en <span class="color c1">‚ñ¨</span>.
Puisque la FIA est d√©finie √† la racine, l&rsquo;environnement parent est l&rsquo;objet
global.  √Ä l&rsquo;int√©rieur de la FIA, trois noms sont d√©finis: une variable <code>a</code> et
deux fonctions <code>f</code> et <code>g</code> (lignes <a href="#coderef-ex1-defs-start"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex1-defs-start');" onmouseout="CodeHighlightOff(this, 'coderef-ex1-defs-start');">2</a> √† <a href="#coderef-ex1-defs-end"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex1-defs-end');" onmouseout="CodeHighlightOff(this, 'coderef-ex1-defs-end');">4</a>).
Lorsqu&rsquo;une fonction est d√©finie, un objet fonction est cr√©e qui contient son
code et son environnement lexical.  Cet environnement sera utilis√© pour ex√©cuter
le corps de la fonction lorsqu&rsquo;elle sera invoqu√©e.  Avant que la FIA ne
retourne, elle cr√©e l&rsquo;objet export√© (ligne <a href="#coderef-ex1-return"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex1-return');" onmouseout="CodeHighlightOff(this, 'coderef-ex1-return');">5</a>) qui contient la
propri√©t√© <code>g</code>.  Cette propri√©t√© r√©f√®re la fonction <code>g</code> d√©finie √† l&rsquo;int√©rieur du
module.  Notons qu&rsquo;il y a <i>deux</i> r√©f√©rences √† la fonction <code>g</code> √† l&rsquo;ex√©cution.
Enfin, la FIA retourne l&rsquo;objet export√©, qui devient la valeur de la variable
globale <code>m</code>.
</p>

<div class="side-figure">

<figure>
<p><img src="img/dls1.svg" alt="dls1.svg">
</p>
</figure>

</div>

<p>
On peut aussi suivre le flot de contr√¥le suscit√© par l&rsquo;appel √† la ligne
<a href="#coderef-ex1-test"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex1-test');" onmouseout="CodeHighlightOff(this, 'coderef-ex1-test');">8</a> sur ce second diagramme.  D&rsquo;abord, la r√©f√©rence <code>m.g</code> est r√©solue en
cherchant la propri√©t√© <code>m</code> dans l&rsquo;environnement courant, c&rsquo;est √† dire,
l&rsquo;environnement global.  <code>m</code> existe et pointe vers un objet, donc l&rsquo;interpr√©teur
cherche maintenant la propri√©t√© <code>g</code> dans cet objet.  <code>g</code> existe, et r√©f√®re un
objet fonction, on peut donc proc√©der √† l&rsquo;appel <code>m.g(0)</code>.  Lorsque la fonction
est appel√©e dans l&rsquo;environnement global, l&rsquo;interpr√©teur cr√©e un environnement
pour le corps de la fonction qu&rsquo;on appelle l&rsquo;objet <i>d&rsquo;activation</i> de <code>g</code>.  Cet
objet associe les noms des param√®tres d√©clar√©s par la fonction aux valeurs
pass√©es par l&rsquo;appel; ici, il y a donc une seule entr√©e <code>x : 0</code>.  L&rsquo;objet
d&rsquo;activation de <code>g</code> est un environnement, et il a comme environnement parent
l&rsquo;objet r√©f√©renc√© par la propri√©t√© <i>env</i> de l&rsquo;objet fonction de <code>g</code>.  Puis, le
contr√¥le est transf√©r√© au corps de la fonction <code>g</code>, qui contient <code>f(x)</code>.
L&rsquo;interpr√©teur r√©sout les noms <code>f</code> et <code>x</code> en cherchant √† travers la cha√Æne
d&rsquo;environnement: d&rsquo;abord dans l&rsquo;environnement courant (l&rsquo;objet d&rsquo;activation de
<code>g</code>).  <code>f</code> n&rsquo;existe pas dans cet objet, mais il existe dans son objet parent.
<code>x</code> existe, et sa valeur est utilis√©e pour continuer l&rsquo;ex√©cution de l&rsquo;appel
<code>f(x)</code>.  Lorsque <code>f</code> est appel√©e, l&rsquo;interpr√©teur cr√©e un nouvel objet
d&rsquo;activation pour les param√®tres formels, qui a l&rsquo;environnement de la FIA comme
environnement parent.  Apr√®s √ßa, l&rsquo;interpr√©teur continue l&rsquo;ex√©cution avec le
corps de <code>f</code>, <code>x+a</code>.  La propri√©t√© <code>x</code> se trouve dans l&rsquo;objet d&rsquo;activation de
<code>f</code> (0), et la propri√©t√© <code>a</code> dans l&rsquo;environnement parent (1).  L&rsquo;interpr√©teur
somme les deux valeurs et retourne le r√©sultat.
</p>

<p>
Le second diagramme sert √† illustrer deux points importants sur le motif module:
</p>

<ol class="org-ol">
<li>La seul fa√ßon que du code ext√©rieur au module a d&rsquo;acc√©der aux d√©finitions
faites √† l&rsquo;int√©rieur du module est de passer par l&rsquo;objet retourn√©.  Dans
l&rsquo;exemple que l&rsquo;on a suivi, <code>g</code> est la seule r√©f√©rence export√©e, mais c&rsquo;est
un alias.  Remarquons que si on essayait de changer la valeur de <code>m.g</code> par
une autre fonction, <code>m.g = function() { ... }</code>, seule la r√©f√©rence <code>m.g</code>
serait affect√©e, mais la propri√©t√© <code>g</code> dans l&rsquo;environnement de la FIA ferait
toujours r√©f√©rence √† la fonction <code>g</code> d√©finie dans le module.  Si l&rsquo;on veut
modifie les r√©f√©rences internes au module, il faut acc√©der directement √†
l&rsquo;environnement de la FIA.</li>

<li>Toutes les fonctions cr√©√©es √† l&rsquo;int√©rieur du module utilisent l&rsquo;environnement
de la FIA comme environnement parent.  Autrement dit, les fonctions se
referment sur leur environnement de d√©finition (leur environnement
<i>lexical</i>), et c&rsquo;est pourquoi on appelle ces fonctions des <i>fermetures</i>.  Si
l&rsquo;on a acc√®s √† l&rsquo;environnement de la FIA, on peut changer le comportement des
fonctions internes au module en changeant les r√©f√©rences de cet
environnement.</li>
</ol>

<p>
On voit alors que l&rsquo;environnement de la FIA est le point central du module, l√†
o√π tous les noms utilis√©s par le module sont recherch√©s.  On voit aussi que le
motif module ne permet pas, en l&rsquo;√©tat, d&rsquo;acc√©der √† ces noms de l&rsquo;ext√©rieur du
module.
</p>
</div>
</div>

<div id="outline-container-orgheadline118" class="outline-4">
<h4 id="orgheadline118"><span class="section-number-4">8.1.2</span> Ouvrir le motif module</h4>
<div class="outline-text-4" id="text-8-1-2">
<p>
On cherche maintenant √† acc√©der √† l&rsquo;environnement de la FIA de l&rsquo;ext√©rieur du
module; c&rsquo;est √† dire obtenir une r√©f√©rence vers cet environnement.  En regardant
les diagrammes pr√©c√©dents, on pourrait penser que <code>m.g.env</code> suffit: il s&rsquo;agit
bien d&rsquo;une r√©f√©rence √† l&rsquo;environnement qui nous int√©resse depuis l&rsquo;ext√©rieur du
module.  Malheureusement, cette r√©f√©rence est <i>interne</i> au moteur d&rsquo;ex√©cution du
langage, donc n&rsquo;est pas accessible par le code ex√©cut√©.  Mais m√™me si on
modifiait le moteur d&rsquo;ex√©cution pour rendre cette r√©f√©rence publique, elle n&rsquo;est
pas fiable.  Suivant la construction de <code>g</code>, l&rsquo;environnement qu&rsquo;elle retourne
pourrait tr√®s bien √™tre diff√©rent de celui de la FIA.
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>(){
<span class="linenr">2: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">mkG</span> = <span style="font-weight: bold;">function</span>() {
<span class="linenr">3: </span>    <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x }
<span class="linenr">4: </span>  }
<span id="coderef-ex2-return" class="coderef-off"><span class="linenr">5: </span>  <span style="font-weight: bold;">return</span> {g: mkG()}</span>
<span class="linenr">6: </span>}())
</pre>
</div>

<div style="margin-top:-10rem" class="side-figure">

<figure>
<p><img src="img/dls3.svg" alt="dls3.svg">
</p>
</figure>

</div>

<aside style="margin-top:7rem">
<p>
Dans les diagrammes suivants, on n&rsquo;illustrera plus les objets d&rsquo;activation des
fonctions.  Il suffit de se rappeler que l&rsquo;environnement utilis√© pour rechercher
les variables libres est celui de la propri√©t√© <code>env</code>.
</p>
</aside>

<p>
Dans cet exemple, la fonction <code>g</code> export√©e par le module ne capture pas
l&rsquo;environnement de la FIA.  √Ä la ligne <a href="#coderef-ex2-return"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex2-return');" onmouseout="CodeHighlightOff(this, 'coderef-ex2-return');">5</a> on exporte la valeur de
retour de la function <code>mkG</code> sous le nom <code>g</code>.  La fonction <code>mkG</code> retourne
exactement la m√™me fonction <code>g</code> que dans l&rsquo;exemple pr√©c√©dent, avec une
diff√©rence notable: cette fonction <code>g</code> capture l&rsquo;environnement de l&rsquo;appel √†
<code>mkG</code>.  Le diagramme qui l&rsquo;accompagne illustre cette diff√©rence par l&rsquo;apparition
d&rsquo;un nouvel objet d&rsquo;activation pour <code>mkG</code> qui est r√©f√©renc√© comme environnement
de <code>g</code>.  On a <code>m.g.env</code> qui pointe vers l&rsquo;environnement cr√©e par <code>mkG</code>
(<span class="color c1">‚ñ¨</span>), et non l&rsquo;environnement cr√©e par la FIA (<span class="color c2">‚ñ¨</span>).
On voit alors que la propri√©t√© <code>env</code> d&rsquo;une fonction n&rsquo;est pas garantie de
pointer vers l&rsquo;environnement dont nous avons besoin.
</p>

<p>
On va maintenant s&rsquo;√©loigner du comportement standard de JavaScript que nous
avons suivi jusqu&rsquo;ici.  Supposons que nous <i>pouvons</i> acc√©der √† l&rsquo;environnement
cr√©e par la FIA gr√¢ce √† une nouvelle propri√©t√© <i>E</i> qui serait automatiquement
ajout√©e sur l&rsquo;objet export√© par le module.  Supposons √©galement que cet
environnement se comporte comme un objet JavaScript r√©gulier; on peut lire et
changer ses propri√©t√©s.
</p>

<aside style="margin-top:-4rem">
<p>
La section suivante montre comment retrouver cette fonctionnalit√© dans le
langage standard.
</p>
</aside>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr"> 1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>(){
<span class="linenr"> 2: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span class="linenr"> 3: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a }
<span class="linenr"> 4: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x) }
<span class="linenr"> 5: </span>  <span style="font-weight: bold;">return</span> {g: g}
<span class="linenr"> 6: </span>}())
<span class="linenr"> 7: </span>
<span id="coderef-ex3-test1" class="coderef-off"><span class="linenr"> 8: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span></span>
<span id="coderef-ex3-change" class="coderef-off"><span class="linenr"> 9: </span>m.E.a = 2</span>
<span id="coderef-ex3-test2" class="coderef-off"><span class="linenr">10: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span></span>
</pre>
</div>

<div style="margin-top:-6rem" class="side-figure">

<figure>
<p><img src="img/dls4.svg" alt="dls4.svg">
</p>
</figure>

</div>

<p>
Reprenons le module du d√©but, mais avec l&rsquo;addition de cette nouvelle propri√©t√©
<code>E</code>.  Si on ex√©cute <code>m.g(0)</code> √† la ligne <a href="#coderef-ex3-test1"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex3-test1');" onmouseout="CodeHighlightOff(this, 'coderef-ex3-test1');">8</a>, on obtient toujours <code>1</code>.
Par contre, cette fois on a acc√®s √† l&rsquo;environnement interne au module via la
propri√©t√© <code>m.E</code>.  Si on change la valeur de <code>a</code> dans cet environnement (ligne
<a href="#coderef-ex3-change"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex3-change');" onmouseout="CodeHighlightOff(this, 'coderef-ex3-change');">9</a>), alors l&rsquo;appel <code>m.g(0)</code> qui suit utilise cette nouvelle valeur, et
c&rsquo;est pourquoi <i>le m√™me appel</i> donne le r√©sultat diff√©rent, <code>2</code>, √† la ligne
<a href="#coderef-ex3-test2"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex3-test2');" onmouseout="CodeHighlightOff(this, 'coderef-ex3-test2');">10</a>.  Le diagramme qui accompagne l&rsquo;exemple donne une autre fa√ßon de
voir ce qui se passe.  On y voit la nouvelle propri√©t√© <code>E</code> en <span class="color c1">‚ñ¨</span>
sur l&rsquo;objet export√© et r√©f√©renc√© par la propri√©t√© globale <code>m</code>.  Cette propri√©t√©
<code>m.E</code> donne un acc√®s en lecture et √©criture sur l&rsquo;environnement de la FIA.
Ainsi, l&rsquo;affectation de la ligne <a href="#coderef-ex3-change"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex3-change');" onmouseout="CodeHighlightOff(this, 'coderef-ex3-change');">9</a> modifie la valeur de <code>a</code> dans le
module; dans le diagramme <code>a</code> a la valeur 2 en cons√©quence.
</p>

<p>
En ajoutant cette r√©f√©rence directe √† l&rsquo;environnement interne du module, on est
d√©j√† capable de changer les r√©sultats de l&rsquo;appel <code>m.g</code>, juste en changeant la
valeur de la variable <code>a</code>.  Mais on peut aussi changer les fonctions.  Si l&rsquo;on
souhaite changer la fonction <code>f</code> pour qu&rsquo;elle retourne <code>x + 2 * a</code> au lieu de
<code>x + a</code>, la ligne <a href="#coderef-ex4-change-f"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex4-change-f');" onmouseout="CodeHighlightOff(this, 'coderef-ex4-change-f');">4</a> de l&rsquo;exemple suivant nous indique comment:
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>() { ... }())
<span class="linenr">2: </span>
<span class="linenr">3: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
<span id="coderef-ex4-change-f" class="coderef-off"><span class="linenr">4: </span>m.E.f = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + 2 * m.E.a }</span>
<span class="linenr">5: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
<span id="coderef-ex4-change-a" class="coderef-off"><span class="linenr">6: </span>m.E.a = 2</span>
<span class="linenr">7: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 4</span>
</pre>
</div>

<div style="margin-top:-4rem" class="side-figure">

<figure>
<p><img src="img/dls5.svg" alt="dls5.svg">
</p>
</figure>

</div>

<p>
Notons qu&rsquo;on ne peut pas simplement √©crire <code>x + 2 * a</code>.  Si on changeait la
d√©finition de <code>f</code> √† l&rsquo;int√©rieur du module, on pourrait r√©f√©rencer <code>a</code>
directement.  Mais ici, on cr√©e une fonction √† l&rsquo;ext√©rieur du module, qui doit
faire r√©f√©rence au <code>a</code> qui n&rsquo;est d√©clar√© que dans l&rsquo;environnement du module.  Si
on √©crit juste <code>a</code>, ce sera une variable libre pour cette fonction.  Mais
puisqu&rsquo;on a une r√©f√©rence √† l&rsquo;environnement du module via <code>m.E</code>, on peut acc√©der
au <code>a</code> √† travers elle.
</p>

<p>
Le diagramme illustre clairement le probl√®me: la nouvelle fonction <code>f</code>
(<span class="color c1">‚ñ¨</span>) n&rsquo;a pas le m√™me environnement que l&rsquo;ancienne.  Puisqu&rsquo;elle est
cr√©√©e en dehors du module, son environnement est l&rsquo;objet global (lien
<span class="color c2">‚ñ¨</span>).  Le diagramme nous indique aussi une autre solution: modifier
la propri√©t√© <code>env</code> de la fonction qui vient remplacer <code>f</code>.  Si l&rsquo;on modifie
cette propri√©t√© pour pointer vers l&rsquo;environnement de la FIA, la variable <code>a</code> ne
sera recherch√©e dans le m√™me environnement que pour la fonction <code>f</code> d&rsquo;origine;
c&rsquo;est comme si l&rsquo;on cr√©ait une fermeture dans le module, mais d√©finit de
l&rsquo;ext√©rieur:
</p>

<aside>
<p>
Malheureusement, on ne peut pas modifier l&rsquo;environnement captur√© par une
fonction en JavaScript.  On ne peut m√™me pas <i>acc√©der</i> √† l&rsquo;environnement
captur√©.  Cette solution ne peut donc pas √™tre impl√©ment√©e sans modifier le
moteur d&rsquo;ex√©cution du langage, ce qui n&rsquo;est pas notre but ici.
</p>
</aside>

<div class="org-src-container">

<pre class="src src-js">m.E.f = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + 2 * a }
m.E.f.env = m.E
</pre>
</div>

<p>
Les deux approches pour r√©f√©rencer <code>a</code> sont des compromis diff√©rents.  Utiliser
<code>m.E</code> est plus explicite, et permet √† la nouvelle fonction de capturer
l&rsquo;environnement dans lequel elle est d√©finie.  Modifier l&rsquo;environnement de
d√©finition permet d&rsquo;√©crire le code de la fonction comme si on l&rsquo;√©crivait √†
l&rsquo;int√©rieur du module, ce qui rend les diff√©rences de code plus lisibles.
</p>

<p>
Dans les deux cas, on peut voir que l&rsquo;appel <code>m.g(0)</code> qui suit la red√©finition de
<code>f</code> est bien affect√© par le changement.  Qui plus est, puisque cette nouvelle
version de <code>f</code> fait r√©f√©rence au <code>a</code> du module, on peut changer <code>a</code> (ligne
<a href="#coderef-ex4-change-a"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex4-change-a');" onmouseout="CodeHighlightOff(this, 'coderef-ex4-change-a');">6</a>) et constater que le dernier appel <code>m.g(0)</code> utilise √† la fois la
nouvelle fonction <code>f</code> et la nouvelle valeur de <code>a</code>.  On peut donc modifier le
comportement de la fonction <code>g</code> en manipulant les variables et les fonctions
d√©finies √† <i>l&rsquo;int√©rieur</i> du module, mais en √©crivant ces changements de
<i>l&rsquo;√©xt√©rieur</i> du module.  On n&rsquo;a pas √† toucher le code du module pour pouvoir
changer les r√©sultats des appels √† <code>m.g</code>.
</p>

<p>
Mais les changements que l&rsquo;on a apport√© au module sont <i>destructifs</i>.  En
changeant la valeur de <code>a</code>, on d√©truit sa valeur initiale.  En changeant la
fonction <code>f</code> aussi.  Dans les deux cas, on modifie la valeur directement dans
l&rsquo;environnement de la FIA.  Comme ces red√©finitions sont de simples
affectations, on peut sauvegarder la valeur initiale dans une variable pour
pouvoir les r√©utiliser apr√®s:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a_orig</span> = m.E.a
<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">f_orig</span> = m.E.f
</pre>
</div>

<p>
Il y a une solution plus √©l√©gante qui tire partie du m√©canisme de r√©solution des
noms de variable dans une cha√Æne d&rsquo;environnements.
</p>
</div>
</div>

<div id="outline-container-orgheadline119" class="outline-4">
<h4 id="orgheadline119"><span class="section-number-4">8.1.3</span> Disposer les environnements en couches</h4>
<div class="outline-text-4" id="text-8-1-3">
<p>
On a vu que tout environnement a un environnement parent.  Si un nom n&rsquo;est pas
trouv√© dans un environnement, la recherche se poursuit dans l&rsquo;environnement
parent.  La recherche continue ainsi jusqu&rsquo;√† ce que le nom soit trouv√©, ou que
la cha√Æne d&rsquo;environnement s&rsquo;arr√™te car le lien vers l&rsquo;environnement parent est
√† <code>null</code>.  On peut profiter de ce m√©canisme pour construire une fa√ßon √©l√©gante
de changer les d√©finitions internes au module.
</p>

<div style="margin-top:-16rem" class="side-figure">

<figure>
<p><img src="img/dls6.svg" alt="dls6.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;33&nbsp;:</span> Exemple de recherche dans une cha√Æne d&rsquo;environnements.  La recherche de la propri√©t√© <code>a</code> commence par en bas, et retourne la valeur de la premi√®re cellule qui contient une propri√©t√© &laquo;&nbsp;a&nbsp;&raquo;; ici c&rsquo;est le second objet.  La recherche de <code>g</code> √©choue.  Notons que le <code>f</code> du second objet est cach√© par le <code>f</code> de l&rsquo;objet en t√™te de la cha√Æne.</figcaption>
</figure>

</div>

<p>
Nous allons faire une seconde addition √† notre variante de JavaScript.  On
suppose que lorsqu&rsquo;un module est cr√©e, un nouvel environnement vide, appel√©
<i>l&rsquo;environnement frontal</i> est cr√©e √©galement.  L&rsquo;environnement frontal a pour
parent l&rsquo;environnement de la FIA, mais les fonctions d√©finies √† la racine du
module capturent l&rsquo;environnement frontal plut√¥t que celui de la FIA.  La
propri√©t√© <code>m.E</code> est modifi√©e √©galement pour pointer vers cet environnement
frontal.
</p>

<div style="margin-top:12rem" class="side-figure">

<figure>
<p><img src="img/dls7.svg" alt="dls7.svg">
</p>
</figure>

</div>

<p>
Si l&rsquo;on reprend exactement le code du module, sans modifications, mais qu&rsquo;on
l&rsquo;ex√©cute avec cette modification s√©mantique, on obtient la situation de la
figure suivante.  La red√©finition de <code>a</code> √† <code>2</code> est enregistr√©e par
l&rsquo;environnement frontal (<span class="color c1">‚ñ¨</span>), plut√¥t que l&rsquo;environnement de la FIA.
Puisque les deux fonctions <code>f</code> et <code>g</code> capturent l&rsquo;environnement frontal, elles
utilisent bien la valeur red√©finie de <code>a</code> quand elles sont appel√©es.  Le
m√©canisme de r√©solution des noms de variable examine les environnements de bas
en haut, en suivant les liens des coins des objets.  On voit donc que n&rsquo;importe
quelle propri√©t√© pr√©sente dans l&rsquo;environnement frontal a priorit√© sur les
propri√©t√©s de l&rsquo;environnement de la FIA.  C&rsquo;est pourquoi la red√©finition de <code>a</code>
affecte bien l&rsquo;appel <code>m.g(0)</code> de la m√™me mani√®re que dans les exemples
pr√©c√©dents.  Mais on a maintenant la possibilit√© <i>d&rsquo;annuler</i> cette red√©finition
en supprimant la propri√©t√© <code>m.E.a</code> de l&rsquo;environnement frontal.  Puisque
l&rsquo;environnement frontal ne contient que notre red√©finition, la valeur originale
n&rsquo;est jamais alt√©r√©e.  Lorsque l&rsquo;on supprime <code>m.E.a</code>, on vide l&rsquo;environnement
frontal, et l&rsquo;appel final <code>m.g(0)</code> va trouver la propri√©t√© <code>a</code> dans
l&rsquo;environnement de la FIA, o√π la valeur est rest√©e √† <code>1</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>() { ... }())
<span class="linenr">2: </span>
<span class="linenr">3: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
<span class="linenr">4: </span>m.E.a = 2
<span class="linenr">5: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
<span class="linenr">6: </span><span style="font-weight: bold;">delete</span> m.E.a
<span class="linenr">7: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
</pre>
</div>

<p>
Avec cet environnement frontal, on peut surcharger et masquer les d√©finitions du
module <i>sans toucher au code √† l&rsquo;int√©rieur du module</i>.  Dans la pratique, on ne
se contenterait pas de changer une seule valeur mais plusieurs, et on voudrait
pouvoir les injecter dans le module et les supprimer d&rsquo;un coup.  En outre, si on
souhaite exp√©rimenter diff√©rents ensembles de changements, on voudrait pouvoir
activer un premier ensemble, puis un second, puis d√©sactiver le premier.
L&rsquo;environnement frontal n&rsquo;est pas suffisant pour ce sc√©nario, mais on peut
en utiliser plusieurs.
</p>

<p>
Pour cela, il faut faire une derni√®re addition √† la s√©mantique du langage: on
suppose que l&rsquo;on peut r√©cup√©rer et modifier le parent de n&rsquo;importe quel
environnement √† travers la propri√©t√© <code>parent</code>.  Avec cette propri√©t√©, on peut
√©tendre la cha√Æne d&rsquo;environnements utilis√©e par les fonctions d√©finies dans le
module avec un nombre quelconque d&rsquo;environnements.  Puisque tout environnement a
un parent, et que l&rsquo;on a une r√©f√©rence vers l&rsquo;environnement par lequel d√©bute la
r√©solution de noms (<code>m.E</code>), la cha√Æne d&rsquo;environnement a une structure similaire
√† une liste cha√Æn√©e, o√π l&rsquo;environnement frontal serait la t√™te de la liste.  Et
puisqu&rsquo;on peut modifier le parent d&rsquo;un environnement, on peut ins√©rer de
nouveaux environnements √† n&rsquo;importe quel point dans cette cha√Æne.
</p>

<p>
Le plus utile pour nos besoins est d&rsquo;ins√©rer un environnement juste apr√®s
l&rsquo;environnement frontal.  Supposons que l&rsquo;on dispose d&rsquo;une fonction
<code>pushEnv(e, chain)</code> qui ins√®re l&rsquo;environnement <code>e</code> dans la cha√Æne juste apr√®s
l&rsquo;environnement frontal; et une fonction <code>removeEnv(e, chain)</code> qui retire
l&rsquo;environnement de la cha√Æne (quelque soit sa position).  Alors on peut √©crire:
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr"> 1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>() { ... }())
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e1</span> = { a:2, f: <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + 2 * m.E.a }}
<span id="coderef-ex6-push1" class="coderef-off"><span class="linenr"> 6: </span>pushEnv(e1, m.E)</span>
<span class="linenr"> 7: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 4</span>
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e2</span> = { f: <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> -m.E.a }}
<span class="linenr">10: </span>pushEnv(e2, m.E)
<span id="coderef-ex6-diag" class="coderef-off"><span class="linenr">11: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: -2</span></span>
<span class="linenr">12: </span>
<span class="linenr">13: </span>removeEnv(e1, m.E)
<span class="linenr">14: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: -1</span>
</pre>
</div>

<p>
Sans changer le module, on ajoute toutes les red√©finitions de <code>e1</code> en appelant
<code>pushEnv</code> (ligne <a href="#coderef-ex6-push1"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex6-push1');" onmouseout="CodeHighlightOff(this, 'coderef-ex6-push1');">6</a>).  On change √† nouveau le comportement de <code>f</code> dans
l&rsquo;environnement <code>e2</code> qu&rsquo;on ins√®re dans le module gr√¢ce au second appel √†
<code>pushEnv</code>.  On voit que l&rsquo;appel <code>m.g(0)</code> qui suit utilise la fonction <code>f</code> de
<code>e2</code>, puisque le r√©sultat est n√©gatif, et la valeur de <code>a</code> de l&rsquo;environnement
<code>e1</code>, puisque la valeur est <code>-2</code>.  Puis, on retire les changements de <code>e1</code> gr√¢ce
√† <code>removeEnv</code>.  L&rsquo;appel <code>m.g(0)</code> utilise encore le <code>f</code> de <code>e2</code>, mais la valeur
de <code>a</code> est la valeur initiale du module, <code>1</code>.
</p>

<div style="margin-top:-10rem" class="side-figure">

<figure>
<p><img src="img/dls8.svg" alt="dls8.svg">
</p>
</figure>

</div>

<p>
Le diagramme illustre la cha√Æne d&rsquo;environnements quand l&rsquo;ex√©cution atteint la
ligne <a href="#coderef-ex6-diag"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex6-diag');" onmouseout="CodeHighlightOff(this, 'coderef-ex6-diag');">11</a>.  L&rsquo;environnement frontal (vide) a pour parent l&rsquo;environnement
<code>e2</code> (<span class="color c3">‚ñ¨</span>), qui lui a comme parent <code>e1</code> (<span class="color c1">‚ñ¨</span>), qui
d√©l√®gue √† l&rsquo;environnement de la FIA.  Chaque ensemble de changements est isol√©
des autres, ce qui permet de les supprimer sans toucher aux autres, et tous sont
ordonn√©s lin√©airement (le fil <span class="color c2">‚ñ¨</span>), comme les couches d&rsquo;un g√¢teau.
Ainsi, la priorit√© de red√©finition est toujours d√©terministe: les d√©finitions
qui se trouvent le plus en t√™te (plus proches de l&rsquo;environnement frontal) ont
toujours priorit√© sur celles des environnements du bout de la cha√Æne.
</p>

<hr >

<p>
On a donc une fa√ßon de modifier le comportement d&rsquo;un module sans toucher au code
qui le d√©finit.  Les changements sont √©crits √† l&rsquo;ext√©rieur du module, et peuvent
m√™me √™tre d√©clar√©es dans des fichiers s√©par√©s.  De plus, on peut dynamiquement
activer ou d√©sactiver des ensembles de changements d&rsquo;un seul coup.  Mais pour
l&rsquo;instant rien de ce qu&rsquo;on a d√©finit n&rsquo;est ex√©cutable.  Il s&rsquo;agissait
d&rsquo;illustrer le mod√®le de fonctionnement dans le cadre d&rsquo;un langage inspir√© de
JavaScript.  Ce faisant, on a d√©vi√© de JavaScript en supposant:
</p>

<ol class="org-ol">
<li>que les environnements se comportent comme des objets JavaScript standards,
comme des dictionnaires auxquels on peut ajouter des propri√©t√©s, r√©cup√©rer
leur valeur;</li>

<li>qu&rsquo;un <i>environnement frontal</i> est cr√©e lors d&rsquo;un appel √† une fonction
imm√©diatement appel√©e (FIA) sur laquelle repose le motif module, et qu&rsquo;une
r√©f√©rence vers cet environnement est retourn√©e par la FIA;</li>

<li>que l&rsquo;on pouvait obtenir et modifier le parent de n&rsquo;importe quel
environnement.</li>
</ol>

<p>
Aucune de ces suppositions n&rsquo;est valide en JavaScript.  Cependant, il y a moyen
de r√©aliser ce mod√®le en utilisant des constructions JavaScript standard.  C&rsquo;est
l&rsquo;objet de la section suivante.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline121" class="outline-3">
<h3 id="orgheadline121"><span class="section-number-3">8.2</span> Ouvrir le motif module en JavaScript</h3>
<div class="outline-text-3" id="text-8-2">
<p>
Pour r√©aliser le mod√®le illustr√© dans la section pr√©c√©dente, on peut tirer
partie de deux ingr√©dients de JavaScript que sont <code>with</code> et la d√©l√©gation par
prototype.  On va utiliser <code>with</code> pour cr√©er un environnement manipulable, puis
r√©pliquer les exemples de composition d&rsquo;environnement par couches gr√¢ce aux
prototypes.
</p>

<aside style="margin-top:-7rem">
<p>
Tous les exemples de cette section sont ex√©cutables sur un interpr√©teur
JavaScript qui suit le standard ECMAScript 5.1.
</p>
</aside>

<p>
L&rsquo;expression <code>with</code> est grammaticalement similaire √† un <code>if</code>.  Elle prend une
expression entre parenth√®ses, qui est √©valu√©e pour constituer son <i>objet de
liaison</i>, et un bloc de code entre accolades.  Voici un exemple d&rsquo;utilisation de
<code>with</code>:
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">o</span> = { a: 42 }
<span class="linenr">2: </span><span style="font-weight: bold;">with</span> (o) {
<span id="coderef-ex7-f" class="coderef-off"><span class="linenr">3: </span>  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>() { <span style="font-weight: bold;">return</span> a }</span>
<span class="linenr">4: </span>}
<span id="coderef-ex7-call" class="coderef-off"><span class="linenr">5: </span>f() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 42</span></span>
</pre>
</div>

<div style="margin-top:-8rem" class="side-figure">

<figure>
<p><img src="img/dls9.svg" alt="dls9.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;36&nbsp;:</span> L&rsquo;environnement cr√©e par <code>with</code> entoure l&rsquo;objet de liaison.  Notons que les deux sont distincts: <code>o</code> pointe vers l&rsquo;objet de liaison, tandis que <code>f.env</code> pointe vers l&rsquo;environnement.</figcaption>
</figure>

</div>

<p>
On d√©finit une fonction <code>f</code> dans le corps de <code>with</code> √† la ligne <a href="#coderef-ex7-f"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex7-f');" onmouseout="CodeHighlightOff(this, 'coderef-ex7-f');">3</a>.  La
fonction va simplement retourner la valeur de la variable <code>a</code>.  Notons que <code>a</code>
est libre dans ce contexte, mais pourtant l&rsquo;appel de <code>f</code> √† la ligne <a href="#coderef-ex7-call"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex7-call');" onmouseout="CodeHighlightOff(this, 'coderef-ex7-call');">5</a>
retourne 42.  Quand <code>f</code> est d√©finie, elle capture l&rsquo;environnement lexical, et il
se trouve que <code>with</code> cr√©e un environnement lexical pour le code qu&rsquo;il entoure;
cet environnement est bas√© sur l&rsquo;objet de liaison, <code>o</code>.  Puisque <code>o</code> associe le
nom <code>a</code> √† 42, l&rsquo;appel de <code>f</code> va trouver cette association et renvoyer 42.
</p>

<p>
En voyant cet exemple, on peut se demander si l&rsquo;effet de <code>with</code> sur le bloc de
code qu&rsquo;il entoure n&rsquo;est pas simplement de la liaison dynamique.  Dans un
langage qui permet la liaison dynamique des fonctions, les variables libres sont
r√©solues en parcourant les environnements de la pile d&rsquo;appel, plut√¥t que de
parcourir l&rsquo;environnement lexical.  Or, ce n&rsquo;est pas ce qui se passe ici.  Dans
l&rsquo;exemple ci-dessous, on cr√©e la fonction <code>f</code> √† la racine, puis on l&rsquo;appelle √†
l&rsquo;int√©rieur d&rsquo;un <code>with</code>, de fa√ßon √† ce que <code>with</code> cr√©e un environnement sur la
pile lorsque <code>f</code> est appel√©e.  L&rsquo;appel √©choue, car la r√©solution de noms ne
trouve aucune occurrence de <code>a</code>.  La fonction <code>f</code> n&rsquo;est donc pas dynamiquement
li√©e si elle est appel√©e dans un <code>with</code>.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>() { <span style="font-weight: bold;">return</span> a }
<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">o</span> = { a: 42 }
<span style="font-weight: bold;">with</span> (o) { f() } <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: ReferenceError: a is undefined</span>
</pre>
</div>

<div style="margin-top:-6rem" class="side-figure">

<figure>
<p><img src="img/dls10.svg" alt="dls10.svg">
</p>
</figure>

</div>

<p>
Ce qui se passe dans le premier exemple, c&rsquo;est que lorsque la fonction <code>f</code> est
d√©finie dans <code>with</code> elle capture l&rsquo;environnement lexical cr√©e par <code>with</code>; <code>f</code>
suit donc une liaison statique.  Mais l&rsquo;environnement g√©n√©r√© par <code>with</code> est
particulier car la r√©solution de noms dans cet environnement est d√©l√©gu√©e √†
l&rsquo;objet de liaison.  Et l&rsquo;objet de liaison peut √™tre dynamique: on peut y
ajouter ou y supprimer des propri√©t√©s.  Donc, on dira que la fonction <code>f</code>
<i>capture statiquement un environnement dynamique</i>.  L&rsquo;environnement ne peut √™tre
captur√© qu&rsquo;√† la d√©finition de <code>f</code>, mais cet environnement peut √™tre modifi√© par
la suite.  Les deux diagrammes illustrent clairement la diff√©rence de
comportement: dans le premier, <code>f.env</code> pointe vers l&rsquo;environnement cr√©e par
<code>with</code>, et dans le second cas, <code>f.env</code> pointe vers l&rsquo;environnement global; cette
propri√©t√© <code>f.env</code> ne peut pas √™tre chang√©e dynamiquement, donc l&rsquo;appel de <code>f</code>
dans <code>with</code> n&rsquo;a aucun effet.  Ce comportement des fonctions d√©finies √†
l&rsquo;int√©rieur d&rsquo;un <code>with</code> est exactement ce qu&rsquo;il nous faut pour ouvrir le motif
module.
</p>

<p>
Dans le code qui suit, on utilise <code>with</code> pour cr√©er l&rsquo;environnement captur√© par
<code>f</code> et <code>g</code>, et obtenir une r√©f√©rence vers cet environnement.  On commence par
cr√©er un objet vide <code>E</code> ligne <a href="#coderef-ex8-create"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex8-create');" onmouseout="CodeHighlightOff(this, 'coderef-ex8-create');">2</a>.  Puis on passe cet objet √† <code>with</code>,
pour qu&rsquo;il devienne son objet de liaison.  Dans le corps de <code>with</code>, on d√©clare
la variable <code>a</code> et les deux fonctions <code>g</code> exactement comme dans le module qui
nous int√©ressait dans la section pr√©c√©dente.  Ligne <a href="#coderef-ex8-return"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex8-return');" onmouseout="CodeHighlightOff(this, 'coderef-ex8-return');">7</a> en revanche on
retourne une propri√©t√© suppl√©mentaire: l&rsquo;objet <code>E</code>.  Le premier appel <code>m.g(0)</code>
retourne encore 1, indiquant que <code>g</code> appelle bien <code>f</code>, qui fait bien r√©f√©rence
au <code>a</code> d√©fini dans le module.
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr"> 1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>(){
<span id="coderef-ex8-create" class="coderef-off"><span class="linenr"> 2: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">E</span> = Object.create(<span style="font-weight: bold; text-decoration: underline;">null</span>)</span>
<span class="linenr"> 3: </span>  <span style="font-weight: bold;">with</span> (E) {
<span class="linenr"> 4: </span>    <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span class="linenr"> 5: </span>    <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a }
<span class="linenr"> 6: </span>    <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x) }
<span id="coderef-ex8-return" class="coderef-off"><span class="linenr"> 7: </span>    <span style="font-weight: bold;">return</span> { g: g, E: E }</span>
<span class="linenr"> 8: </span>  }
<span class="linenr"> 9: </span>}())
<span class="linenr">10: </span>
<span class="linenr">11: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
<span class="linenr">12: </span>
<span id="coderef-ex8-a" class="coderef-off"><span class="linenr">13: </span>m.E.a = 2</span>
<span class="linenr">14: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
</pre>
</div>

<p>
Comme on a une r√©f√©rence vers l&rsquo;objet de liaison <code>E</code>, on red√©finit la valeur de
<code>a</code> ligne <a href="#coderef-ex8-a"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex8-a');" onmouseout="CodeHighlightOff(this, 'coderef-ex8-a');">13</a>.  L&rsquo;appel <code>m.g(0)</code> qui suit retourne 2, ce qui montre que la
fonction <code>f</code> va bien prendre la valeur de <code>a</code> dans l&rsquo;objet <code>E</code>.
</p>

<div style="margin-top:-20rem" class="side-figure">

<figure>
<p><img src="img/dls11.svg" alt="dls11.svg">
</p>
</figure>

</div>

<p>
On peut se demander pourquoi la valeur de <code>m.E.a</code> est pr√©f√©r√©e √† la d√©claration
de <code>a</code>, alors que cette derni√®re est <i>plus proche</i> lexicalement de la fonction
<code>f</code> que le d√©but du <code>with</code>.  On a vu que <code>with</code> cr√©e un environnement pour le
code qu&rsquo;il entoure, mais cet environnement <i>ne capture pas</i> les d√©clarations.
Les d√©clarations de variables et fonctions sont captur√©es par l&rsquo;environnement
cr√©e par la fonction qui enrobe le module‚Äîla FIA.  Le diagramme illustre la
situation.  L&rsquo;environnement cr√©e par <code>with</code> est mis en √©vidence; il contient
l&rsquo;objet de liaison.  Dans l&rsquo;objet de liaison il n&rsquo;y a que la propri√©t√© <code>a</code>
associ√©e √† 2.  Les d√©clarations de <code>a</code>, <code>f</code> et <code>g</code> faites dans le module
n&rsquo;existent que dans l&rsquo;environnement cr√©e par la FIA.  On voit par contre que <code>f</code>
et <code>g</code> capturent l&rsquo;environnement cr√©e par <code>with</code>, puisque leur propri√©t√© <code>env</code>
pointe dessus.  C&rsquo;est pourquoi la valeur de <code>m.E.a</code> est trouv√©e en premier par
la r√©solution de nom lors de l&rsquo;ex√©cution de <code>f</code>.
</p>

<aside style="margin-top:-14rem">
<p>
En fait, le standard ECMAScript 5.1 ne pr√©cise pas quel environnement doit
capturer la fonction dans ce cas; c&rsquo;est laiss√© √† la discr√©tion du moteur
d&rsquo;ex√©cution.  SpiderMonkey, le moteur utilis√© par Firefox, a le comportement
d√©crit ici.  Mais V8, utilis√© par Chrome, suit des r√®gles diff√©rentes, et pour
pouvoir r√©pliquer l&rsquo;exemple, il faut d√©clarer les fonctions par des expressions
(<code>var f = function...</code>).  Le cr√©ateur de JavaScript, Brendan Eich, <a href="https://bugs.chromium.org/p/v8/issues/detail?id=686">indique</a> que
le comportement de Firefox dans ce cas est compatible avec la prochaine version
du standard.  N&rsquo;ayant pas encore acc√®s √† une impl√©mentation compl√®te de ce
standard, j&rsquo;invite donc le lecteur du futur √† tester si ce comportement est
effectivement standard.
</p>
</aside>

<p>
D&rsquo;apr√®s le diagramme, il est clair que si l&rsquo;objet de liaison est vide, le module
se comportera exactement comme si <code>with</code> n&rsquo;√©tait pas utilis√©, puisque
l&rsquo;environnement de <code>with</code> a pour parent l&rsquo;environnement de la FIA.  La seule
diff√©rence observable serait un l√©ger surco√ªt d√ª √† l&rsquo;objet suppl√©mentaire sur la
cha√Æne de r√©solution de noms.
</p>

<p>
Une diff√©rence cruciale entre le mod√®le annonc√© dans la section pr√©c√©dente et ce
qu&rsquo;on obtient ici, c&rsquo;est qu&rsquo;ci l&rsquo;environnement cr√©e par <code>with</code> et l&rsquo;objet de
liaison sont deux objets distincts, alors que dans le mod√®le il ne sont qu&rsquo;un
seul et m√™me objet.  En particulier, la propri√©t√© <code>m.E</code> pointe vers l&rsquo;objet de
liaison, tandis que les propri√©t√©s <code>env</code> des fonctions <code>f</code> et <code>g</code> pointent vers
l&rsquo;environnement.  La cons√©quence de cette distinction est qu&rsquo;on si peut se
servir de <code>m.env</code> pour surcharger les d√©finitions faites dans le module, on ne
peut pas s&rsquo;en servir pour <i>acc√©der</i> aux valeurs de ces d√©finitions de
l&rsquo;ext√©rieur du module.  Par exemple, <code>m.E.f</code> ne fait pas r√©f√©rence au <code>f</code> de
l&rsquo;environnement de la FIA; <code>m.E.f</code> n&rsquo;est pas d√©fini.
</p>

<p>
Pour rem√©dier √† cette d√©viation du mod√®le, on peut cr√©er un objet parent √† <code>E</code>.
Cet objet contiendra une r√©f√©rence pour chaque d√©claration faite dans le module.
On assigne ensuite cet objet parent au <i>prototype</i> de l&rsquo;objet de liaison, <code>E</code>.
JavaScript est un objet √† prototypes: chaque objet a un lien de prototype vers
un autre objet, ou vers <code>null</code>.  Lorsque la r√©solution de nom cherche la
propri√©t√© <code>p</code> sur un objet qui ne la contient pas, la recherche continue sur le
prototype, et s&rsquo;arr√™te si le prototype est nul.  La recherche de nom dans la
cha√Æne de prototype d&rsquo;un objet se comporte donc exactement comme la r√©solution
de noms de variable dans les environnements.  La solution se pr√©sente donc
ainsi:
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr"> 1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>(){
<span class="linenr"> 2: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">E</span> = Object.create(<span style="font-weight: bold; text-decoration: underline;">null</span>)
<span class="linenr"> 3: </span>  <span style="font-weight: bold;">with</span> (E) {
<span class="linenr"> 4: </span>    <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span class="linenr"> 5: </span>    <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a }
<span class="linenr"> 6: </span>    <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x) }
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    Object.setPrototypeOf(E,
<span id="coderef-ex9-parent" class="coderef-off"><span class="linenr"> 9: </span>      { a: a, f: f, g: g }</span>
<span class="linenr">10: </span>    )
<span class="linenr">11: </span>    <span style="font-weight: bold;">return</span> { g: g, E: E }
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>}())
<span class="linenr">14: </span>
<span class="linenr">15: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
<span class="linenr">16: </span>
<span id="coderef-ex9-f" class="coderef-off"><span class="linenr">17: </span>m.E.f = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + 2 * m.E.a }</span>
<span class="linenr">18: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
<span class="linenr">19: </span>
<span class="linenr">20: </span>m.E.a = 2
<span class="linenr">21: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 4</span>
<span class="linenr">22: </span>
<span class="linenr">23: </span><span style="font-weight: bold;">delete</span> m.E.f
<span class="linenr">24: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
<span class="linenr">25: </span>
<span class="linenr">26: </span><span style="font-weight: bold;">delete</span> m.E.a
<span class="linenr">27: </span>m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
</pre>
</div>

<div class="side-figure">

<figure>
<p><img src="img/dls12.svg" alt="dls12.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;39&nbsp;:</span> On ajoute un objet parent pour contourner la distinction entre l&rsquo;objet de liaison et l&rsquo;environnement cr√©e par <code>with</code>.</figcaption>
</figure>

</div>

<p>
On cr√©e un objet parent ligne <a href="#coderef-ex9-parent"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex9-parent');" onmouseout="CodeHighlightOff(this, 'coderef-ex9-parent');">9</a> qui contient une r√©f√©rence pour
chaque d√©claration du module, et on assigne cet objet au prototype de <code>E</code>.
Gr√¢ce √† cet objet, on peut faire r√©f√©rence √† <code>a</code> √† travers <code>m.E.a</code> lors de la
red√©finition de <code>f</code> ligne <a href="#coderef-ex9-f"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex9-f');" onmouseout="CodeHighlightOff(this, 'coderef-ex9-f');">17</a>.  Puis, lorsqu&rsquo;on red√©finit <code>a</code> √† travers
<code>m.E.a</code>, cette nouvelle valeur a priorit√© sur la valeur initiale du module, et
est bien captur√©e par la nouvelle fonction <code>f</code>.  Tout cela est illustr√© par le
diagramme.  La propri√©t√© <code>m.E</code> pointe sur l&rsquo;objet de liaison (<span class="color c1">‚ñ¨</span>),
qui contient les red√©finitions de <code>a</code> et <code>f</code>.  Si l&rsquo;objet de liaison est vide,
alors on recherche les propri√©t√©s sur l&rsquo;objet parent (<span class="color c2">‚ñ¨</span>) avant de
les chercher dans l&rsquo;environnement de la FIA.  Ainsi, lorsque l&rsquo;on supprime les
propri√©t√©s <code>a</code> et <code>f</code>, le dernier appel <code>m.g(0)</code> retourne la m√™me valeur que le
premier, avant les modifications.
</p>

<p>
On peut se demander si l&rsquo;objet parent n&rsquo;apporte que de la redondance de code.
Principalement oui.  Mais cette redondance nous apporte aussi une flexibilit√©
suppl√©mentaire par rapport au mod√®le.  Seules les propri√©t√©s mentionn√©es dans
l&rsquo;objet parent seront accessibles de l&rsquo;ext√©rieur du module, ce qui nous permet
de contr√¥ler quelles propri√©t√©s sont expos√©es.  Mais surtout, les valeurs
expos√©es par l&rsquo;objet parent ne sont pas forc√©ment celles de l&rsquo;environnement de
la FIA, ce qui permet encore une fois de contr√¥ler ce que le code externe au
module peut voir.
</p>

<p>
Enfin, puisque la cha√Æne de prototype d&rsquo;un objet JavaScript peut √™tre vue comme
une liste cha√Æn√©e, on peut directement impl√©menter l&rsquo;id√©e des couches
d&rsquo;environnements du mod√®le de la section pr√©c√©dente.  Dans le code suivant, on
d√©finit la fonction <code>pushEnv(e, head)</code> qui ins√®re l&rsquo;objet <code>e</code> comme parent de
<code>head</code>; la fonction <code>removeEnv(e, head)</code> retire l&rsquo;objet <code>e</code> de la cha√Æne,
quelque soit sa position.  Si on reprend le module <code>m</code> d√©finit dans l&rsquo;exemple
pr√©c√©dent, on peut maintenant utiliser des objets JavaScript pour grouper les
modifications que l&rsquo;on souhaite apporter au module (<code>e1</code> et <code>e2</code>), et utiliser
<code>pushEnv</code> et <code>removeEnv</code> pour activer ou d√©sactiver ces changements
dynamiquement.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>(){ ... }())

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">pushEnv</span>(<span style="font-weight: bold; font-style: italic;">e</span>, <span style="font-weight: bold; font-style: italic;">head</span>) {
  Object.setPrototypeOf(e, Object.getPrototypeOf(head))
  Object.setPrototypeOf(head, e)
}

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">removeEnv</span>(<span style="font-weight: bold; font-style: italic;">e</span>, <span style="font-weight: bold; font-style: italic;">head</span>) {
  <span style="font-weight: bold;">while</span> (Object.getPrototypeOf(head) != <span style="font-weight: bold; text-decoration: underline;">null</span>
      &amp;&amp; Object.getPrototypeOf(head) !== e)
    head = Object.getPrototypeOf(head)

  <span style="font-weight: bold;">if</span> (Object.getPrototypeOf(head) === e) {
    Object.setPrototypeOf(head, Object.getPrototypeOf(e))
    Object.setPrototypeOf(e, <span style="font-weight: bold; text-decoration: underline;">null</span>)
  }
}

m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e1</span> = { a: 2, f: <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + 2 * m.E.a }}
pushEnv(e1, m.E)
m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 4</span>

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">e2</span> = { f: <span style="font-weight: bold;">function</span>() { <span style="font-weight: bold;">return</span> -m.E.a }}
pushEnv(e2, m.E)
m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: -2</span>

removeEnv(e1, m.E)
m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: -1</span>
</pre>
</div>

<p>
Donc <code>with</code> permet de r√©aliser l&rsquo;id√©e de l&rsquo;environnement frontal, et la cha√Æne
de prototype de l&rsquo;objet de liaison de <code>with</code> permet de disposer les
environnements en couches.  Et gr√¢ce √† ces m√©canismes, on parvient √† ouvrir le
motif module; on peut changer les d√©finitions internes au module par du code
√©crit √† l&rsquo;ext√©rieur.
</p>

<p>
Cependant, les exemples que l&rsquo;on a utilis√©s sont rest√©s tr√®s simples.  Il serait
plus int√©ressant de voir comment on peut ouvrir un module plus r√©aliste, et
quels sont les probl√®mes qui apparaissent.  Dans la section suivante, on
applique ces m√©canismes √† Narcissus.
</p>
</div>
</div>

<div id="outline-container-orgheadline127" class="outline-3">
<h3 id="orgheadline127"><span class="section-number-3">8.3</span> √âtendre Narcissus par manipulation de port√©e</h3>
<div class="outline-text-3" id="text-8-3">
<p>
Dans cette section, on reprend une version non instrument√©e de Narcissus, √†
laquelle on va ajouter plusieurs analyses en essayant de minimiser les
changements de code √† l&rsquo;int√©rieur du module de Narcissus.  Pour ouvrir le module
de Narcissus, il suffit d&rsquo;ajouter <code>with</code> autour du corps du code ainsi que
l&rsquo;objet <code>parent</code>:
</p>

<div class="org-src-container">

<pre class="src src-diff">Narcissus.interpreter = (function() {
+  var _env = Object.create(null);
+  with (_env) {
   ...
   // 1500 lines later
   ...
+  var _parent = {
+    globalBase: globalBase,
+    execute: execute,
+    getValue: getValue,
+    ...
+  };
+  Object.setPrototypeOf(_env, _parent);
   return {
     evaluate: evaluate,
     ...
+    _env: _env,
   };
+  }
}());
</pre>
</div>

<p>
Les changements n&rsquo;affectent que le d√©but et la fin du fichier.  Puisque le
module exporte d√©j√† des propri√©t√©s dans le <code>return</code>, on y ajoute juste la
propri√©t√© <code>_env</code>.  Les analyses qui nous int√©ressent n√©cessitent √©galement
d&rsquo;exposer des propri√©t√©s internes au module √† travers l&rsquo;objet <code>_parent</code> (nous en
avons utilis√© 14 en tout dans notre version instrument√©e de Narcissus).  Notons
au passage que les propri√©t√©s <code>_env</code> et <code>_parent</code> sont pr√©fix√©es d&rsquo;un tiret bas
pour √©viter une collision de nom avec les variables d√©clar√©es √† la racine par
Narcissus.  Mais ces lignes sont les seules modifications n√©cessaires √† apporter
au module pour pouvoir commencer l&rsquo;instrumentation.
</p>
</div>

<div id="outline-container-orgheadline122" class="outline-4">
<h4 id="orgheadline122"><span class="section-number-4">8.3.1</span> Ajouter l&rsquo;analyse d&rsquo;√©valuation multi-facettes</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
On a vu dans l&rsquo;√©tude de cas que l&rsquo;impl√©mentation de l&rsquo;√©valuation multi-facettes
sur Narcissus pouvait √™tre r√©partie en trois cat√©gories de changements.  La
premi√®re cat√©gorie √©tait l&rsquo;ajout du <i>program counter</i> par extension de l&rsquo;objet
<code>ExecutionContext</code> et d&rsquo;arguments suppl√©mentaires √† la fonction <code>getValue</code>.  On
peut maintenant effectuer ce changement de l&rsquo;ext√©rieur du module:
</p>

<div class="org-src-container">

<pre class="src src-js"><span id="coderef-ex10-N" class="coderef-off"><span class="linenr"> 1: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">N</span> = Narcissus.interpreter._env</span>
<span class="linenr"> 2: </span>
<span id="coderef-ex10-EC" class="coderef-off"><span class="linenr"> 3: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">EC</span> = N.ExecutionContext</span>
<span class="linenr"> 4: </span><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">ExecutionContext</span>(<span style="font-weight: bold; font-style: italic;">type</span>, <span style="font-weight: bold; font-style: italic;">version</span>) {
<span class="linenr"> 5: </span>  EC.call(<span style="font-weight: bold; text-decoration: underline;">this</span>, type, version)
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  <span style="font-weight: bold; text-decoration: underline;">this</span>.pc = getPC() || <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">ProgramCounter</span>()
<span class="linenr"> 8: </span>}
<span class="linenr"> 9: </span>
<span id="coderef-ex10-ECproto" class="coderef-off"><span class="linenr">10: </span>ExecutionContext.<span style="font-weight: bold; text-decoration: underline;">prototype</span> = Object.create(EC.<span style="font-weight: bold; text-decoration: underline;">prototype</span>)</span>
<span class="linenr">11: </span>
<span class="linenr">12: </span><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">getPC</span>() {
<span class="linenr">13: </span>  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">x</span> = EC.current
<span class="linenr">14: </span>  <span style="font-weight: bold;">return</span> x &amp;&amp; x.pc
<span class="linenr">15: </span>}
<span class="linenr">16: </span>
<span class="linenr">17: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">GV</span> = N.getValue
<span id="coderef-ex10-getV" class="coderef-off"><span class="linenr">18: </span><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">getValue</span>(<span style="font-weight: bold; font-style: italic;">v</span>, <span style="font-weight: bold; font-style: italic;">pc</span>) {</span>
<span class="linenr">19: </span>  pc = pc || getPC()
<span class="linenr">20: </span>
<span class="linenr">21: </span>  <span style="font-weight: bold;">if</span> (v <span style="font-weight: bold;">instanceof</span> <span style="font-weight: bold; text-decoration: underline;">FacetedValue</span>)
<span class="linenr">22: </span>    <span style="font-weight: bold;">return</span> derefFacetedValue(v, pc)
<span class="linenr">23: </span>
<span class="linenr">24: </span>  <span style="font-weight: bold;">return</span> GV(v)
<span class="linenr">25: </span>}
<span class="linenr">26: </span>
<span id="coderef-ex10-instr1" class="coderef-off"><span class="linenr">27: </span>N.ExecutionContext = ExecutionContext</span>
<span id="coderef-ex10-instr2" class="coderef-off"><span class="linenr">28: </span>N.getValue = getValue</span>
</pre>
</div>

<p>
On commence par d√©finir un nom raccourci ligne <a href="#coderef-ex10-N"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex10-N');" onmouseout="CodeHighlightOff(this, 'coderef-ex10-N');">1</a> pour l&rsquo;environnement
export√© par Narcissus.  Puis on modifie le constructeur <code>ExecutionContext</code> apr√®s
avoir sauvegard√© l&rsquo;original ligne <a href="#coderef-ex10-EC"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex10-EC');" onmouseout="CodeHighlightOff(this, 'coderef-ex10-EC');">3</a>, pour pouvoir y faire r√©f√©rence dans
la nouveau constructeur, mais aussi dans <code>getPC</code>.  Le nouveau constructeur
appelle le constructeur original (√©quivalent √† un appel √† <code>super</code> en Java) et
ajoute la valeur courante du <i>program counter</i> comme propri√©t√© <code>pc</code>.  Les autres
propri√©t√©s de l&rsquo;objet <code>ExecutionContext</code> sont h√©rit√©es gr√¢ce √† l&rsquo;idiome
JavaScript ligne <a href="#coderef-ex10-ECproto"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex10-ECproto');" onmouseout="CodeHighlightOff(this, 'coderef-ex10-ECproto');">10</a>.  Ligne <a href="#coderef-ex10-getV"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex10-getV');" onmouseout="CodeHighlightOff(this, 'coderef-ex10-getV');">18</a>, on d√©finit une nouvelle
fonction <code>getValue</code> qui va remplacer et appeler l&rsquo;originale, mais qui r√©cup√®re
le <i>program counter</i> courant soit donn√© en argument, soit par un appel √† <code>getPC</code>
si l&rsquo;argument n&rsquo;est pas renseign√©.  De cette fa√ßon, les appels √† <code>getValue</code> dans
l&rsquo;interpr√©teur ne n√©cessitent pas de modification pour l&rsquo;argument
suppl√©mentaire, mais le code de l&rsquo;instrumentation peut appeler <code>getValue</code> en
passant une valeur pour <code>pc</code>.  Enfin, on installe ces modifications dans
l&rsquo;environnement frontal de l&rsquo;interpr√©teur (lignes <a href="#coderef-ex10-instr1"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex10-instr1');" onmouseout="CodeHighlightOff(this, 'coderef-ex10-instr1');">27</a> et
<a href="#coderef-ex10-instr2"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex10-instr2');" onmouseout="CodeHighlightOff(this, 'coderef-ex10-instr2');">28</a>).
</p>

<p>
La seconde cat√©gorie de changements concernait l&rsquo;extension de la fonction
<code>execute</code> pour chaque n≈ìud de l&rsquo;AST, dans le but de scinder l&rsquo;√©valuation des
valeurs √† facettes en appelant la nouvelle fonction <code>evaluateEach</code> sur chacune
des facettes.  La fonction <code>execute</code> est essentiellement un long <code>switch</code> (600
lignes) avec un <code>case</code> pour chaque type de n≈ìud de l&rsquo;AST.  On red√©finit la
fonction <code>execute</code> en suivant la m√™me structure.
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">29: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">EX</span> = N.execute
<span class="linenr">30: </span><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">execute</span>(<span style="font-weight: bold; font-style: italic;">n</span>.<span style="font-weight: bold; font-style: italic;">x</span>) {
<span class="linenr">31: </span>  <span style="font-weight: bold;">switch</span> (n.type) {
<span class="linenr">32: </span>    <span style="font-weight: bold;">case</span> IF:
<span class="linenr">33: </span>      <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">cond</span> = N.getValue(N.execute(n.condition, x), x.pc)
<span class="linenr">34: </span>      evaluateEach(cond, <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">v</span>, <span style="font-weight: bold; font-style: italic;">x</span>) {
<span class="linenr">35: </span>        <span style="font-weight: bold;">if</span> (v) N.execute(n.thenPart, x)
<span class="linenr">36: </span>        <span style="font-weight: bold;">else</span> <span style="font-weight: bold;">if</span> (n.elsePart) N.execute(n.elsePart, x)
<span class="linenr">37: </span>      }, x)
<span class="linenr">38: </span>    <span style="font-weight: bold;">break</span>
<span class="linenr">39: </span>
<span class="linenr">40: </span>    ... <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">other instrumented cases</span>
<span class="linenr">41: </span>
<span id="coderef-ex11-default" class="coderef-off"><span class="linenr">42: </span>    <span style="font-weight: bold;">default</span>: <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">v</span> = EX(n, x)</span>
<span class="linenr">43: </span>  }
<span class="linenr">44: </span>  <span style="font-weight: bold;">return</span> v
<span class="linenr">45: </span>}
<span class="linenr">46: </span>
<span id="coderef-ex11-redef" class="coderef-off"><span class="linenr">47: </span>N.execute = execute</span>
</pre>
</div>

<p>
L&rsquo;√©valuation multi-facettes ne red√©finit le comportement que pour quelques types
de n≈ìuds de l&rsquo;AST, donc on d√©l√®gue √† la fonction initiale dans le <code>default</code>
ligne <a href="#coderef-ex11-default"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex11-default');" onmouseout="CodeHighlightOff(this, 'coderef-ex11-default');">42</a>.  En d√©clarant un <code>case IF</code>, on red√©finit le traitement des
n≈ìuds de type <code>IF</code> dans l&rsquo;AST.  Notons qu&rsquo;ici on appelle r√©cursivement
<code>N.execute</code>, et que dans le code de la fonction d&rsquo;origine, l&rsquo;appel r√©cursif est
not√© <code>execute</code>, mais apr√®s la ligne <a href="#coderef-ex11-redef"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-ex11-redef');" onmouseout="CodeHighlightOff(this, 'coderef-ex11-redef');">47</a>, les deux noms pointeront vers
la m√™me fonction: celle que l&rsquo;on vient de d√©finir.
</p>

<p>
Enfin, la troisi√®me cat√©gorie de changements regroupait les ajouts de propri√©t√©s
√† l&rsquo;objet <code>globalBase</code>.  Il s&rsquo;agit donc de d√©finir un nouvel objet <code>globalBase</code>
qui h√©rite de l&rsquo;objet original, mais auquel on rajoute les propri√©t√©s
suppl√©mentaires:
</p>

<div class="org-src-container">

<pre class="src src-js"><span class="linenr">48: </span><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">globalBase</span> = Object.create(N.globalBase)
<span class="linenr">49: </span>
<span class="linenr">50: </span>globalBase.isFacetedValue = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">v</span>) {
<span class="linenr">51: </span>  <span style="font-weight: bold;">return</span> (v <span style="font-weight: bold;">instanceof</span> <span style="font-weight: bold; text-decoration: underline;">FacetedValue</span>)
<span class="linenr">52: </span>}
<span class="linenr">53: </span>
<span class="linenr">54: </span>...  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">other properties</span>
<span class="linenr">55: </span>
<span class="linenr">56: </span>N.globalBase = globalBase
</pre>
</div>

<p>
Mais ce n&rsquo;est pas suffisant.  Dans le module de Narcissus, l&rsquo;objet <code>globalBase</code>
est utilis√© juste apr√®s sa cr√©ation pour peupler l&rsquo;objet global du code client.
Ce processus prend place dans le module, avant que les propri√©t√©s export√©es ne
soient retourn√©es.  Hors, la fa√ßon que l&rsquo;on a d&rsquo;√©tendre le module ne nous permet
de modifier que des valeurs apr√®s l&rsquo;export des propri√©t√©s.  Il nous faut donc
modifier le code du module pour pouvoir effectuer ce changement.  Il suffit de
fournir une fonction <code>populateEnvironment</code> qui construit l&rsquo;objet global √† partir
de <code>globalBase</code>, et qui devra √™tre appel√©e apr√®s la construction du module.  √áa
nous laisse maintenant la possibilit√© d&rsquo;√©tendre l&rsquo;objet <code>globalBase</code>.  Cette
modification au module consiste √† d√©placer les 30 instructions qui peuplaient
l&rsquo;objet global dans la fonction <code>populateEnvironment</code>, et √† rajouter cette
nouvelle fonction dans les propri√©t√©s export√©es.
</p>

<p>
Un dernier changement du module a √©t√© n√©cessaire, plus l√©ger cette fois.  Une
fonction cruciale, la fonction qui est utilis√©e par le code client pour
d√©clencher un appel de fonction, √©tait cr√©e de mani√®re <i>anonyme</i> dans le
module.  Vu qu&rsquo;elle n&rsquo;avait pas de nom, il n&rsquo;y avait aucun moyen de la red√©finir
de l&rsquo;ext√©rieur du module; le motif &laquo;&nbsp;module ouvert&nbsp;&raquo; ne peut surcharger que des
identifiants nomm√©s.  Pour pouvoir red√©finir cette fonction, nous lui avons
simplement donn√© un nom.
</p>
</div>
</div>

<div id="outline-container-orgheadline123" class="outline-4">
<h4 id="orgheadline123"><span class="section-number-4">8.3.2</span> Ajouter l&rsquo;analyse de trace</h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
En plus de l&rsquo;√©valuation multi-facettes, on a d√©fini trois autres analyses sur
l&rsquo;interpr√©teur: une analyse de flot d&rsquo;information, FlowR, d√©crite par Pasquier,
Bacon et Shand [<a href="#PBS-14">PBS14</a>], une simple analyse de trace, et une analyse qui extrait
les objets et les environnements allou√©s par l&rsquo;interpr√©teur, afin de recolter
les informations pour dessiner les diagrammes de cette section.
</p>

<p>
L&rsquo;analyse de trace est la plus simple: il suffit d&rsquo;interc√©pter les appels √†
<code>execute</code> pour √©crire sur la sortie standard quel le type du n≈ìud de l&rsquo;AST pass√©
en param√®tre, ce qui nous donne l&rsquo;ordre d&rsquo;√©valuation du programme.  Puisque
<code>execute</code> est appel√©e r√©cursivement, on indente aussi la sortie suivant la
profondeur de la pile d&rsquo;appel.  Le simple code:
</p>

<aside>
<p>
Cette analyse nous a √©t√© particuli√®rement utile pour d√©boguer certains cas
√©pineux d&rsquo;interaction entre les analyses et l&rsquo;interpr√©teur.
</p>
</aside>

<pre class="example">
$ cat tests/function.js
function f(a) { return a }
f(1+1)
</pre>

<p>
g√©n√®re la trace:
</p>

<pre class="example">
$ ./njs -l trace -f tests/function.js
SCRIPT
  FUNCTION f(a)
  SEMICOLON
    CALL f((1 + 1))
      IDENTIFIER f
      LIST
        PLUS
          NUMBER 1
          NUMBER 1
      SCRIPT
        RETURN
          IDENTIFIER a
</pre>

<p>
Ce qui donnes suffisamment d&rsquo;information pour suivre le chemin emprunt√© par
l&rsquo;interpr√©teur lorsqu&rsquo;il √©value ce programme.
</p>

<p>
La nouvelle version de la fonction <code>execute</code> est simple:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">execute</span>(<span style="font-weight: bold; font-style: italic;">proceed</span>, <span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; font-style: italic;">x</span>) {
  printIndentation(indentation);
  print(nodetypesToNames[n.type]);

  indentation += indentationStep;
  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">ret</span> = proceed(n, x);
  indentation -= indentationStep;

  <span style="font-weight: bold;">return</span> ret;
}
</pre>
</div>

<p>
On instrumente aussi la fonction <code>print</code>, qui peut √™tre utilis√©e par le code
client et qui pourrait venir se m√™ler √† la trace, puisque les deux √©crivent sur
la m√™me sortie.  On pourrait red√©finir le <code>print</code> client pour √©crire sur une
autre sortie (ou la trace), mais ici on a choisi de simplement pr√©fixer les
appels clients de <code>print</code>:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">printStdout</span>(...args) {
  printIndentation(indentation);
  putstr(<span style="font-style: italic;">'#output '</span>);
  print(...args);
}
</pre>
</div>

<p>
Il suffit ensuite d&rsquo;ins√©rer ces red√©finitions dans l&rsquo;environnement du module.
Comme l&rsquo;insertion est syst√©matique pour d√©finir une analyse, on a d√©fini une
l√©g√®re interface d&rsquo;instrumentation, qui permet de masquer les d√©tails de
manipulation d&rsquo;environnements et de donner du code plus d√©claratif:
</p>

<div class="org-src-container">

<pre class="src src-js">i13n.pushLayer(_env, {
  execute: i13n.around(_env.execute, execute),
  globalBase: i13n.delegate(_env.globalBase,
                            {print: printStdout}),
});
</pre>
</div>

<aside style="margin-top:-7rem">
<p>
‚Äòi13n&rsquo; est le num√©ronyme d&rsquo;&laquo;&nbsp;instrumentation&nbsp;&raquo;, comme ‚Äòi18n&rsquo; est le num√©ronyme
d&rsquo;&laquo;&nbsp;internationalisation&nbsp;&raquo;; c&rsquo;est aussi la convention d√©j√† suivie par
AspectScript.
</p>
</aside>

<p>
La fonction <code>i13n.pushLayer</code> est un alias de la fonction <code>pushEnv</code> d√©finie dans
la section <a href="#orgheadline119">8.1.3</a>.
</p>

<p>
La fonction <code>i13n.around(fn, a)</code> retourne simplement une nouvelle fonction qui
appelle la fonction <code>a</code> en lui passant <code>fn</code>, la fonction d&rsquo;origine, en premier
argument:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">around</span>(<span style="font-weight: bold; font-style: italic;">fn</span>, <span style="font-weight: bold; font-style: italic;">a</span>) {
  <span style="font-weight: bold;">return</span> <span style="font-weight: bold;">function</span>(...args) {
    <span style="font-weight: bold;">return</span> a(fn, ...args);
  }
}
</pre>
</div>

<aside style="margin-top:-8rem">
<p>
Apr√®s un remplacement de la fonction <code>f</code> par <code>i13n.around(f, g)</code> dans un module,
tous les appels √† <code>f</code> dans le module feront appel √† <code>g</code>.  L&rsquo;effet est √©quivalent
√† la r√©√©criture:
</p>
<div class="org-src-container">

<pre class="src src-js">f(a, b, ...) =&gt; g(f, a, b, ...)
</pre>
</div>
</aside>

<p>
C&rsquo;est proche de la s√©mantique du <i>pointcut</i> d&rsquo;AspectJ du m√™me nom.  Notons
cependant qu&rsquo;ici aucun tissage ne prend place: le code n&rsquo;est pas modifi√©, et en
particulier la fonction <code>a</code> n&rsquo;est pas <i>inlin√©e</i> dans <code>fn</code>.
</p>

<p>
L&rsquo;autre motif r√©current est l&rsquo;extension d&rsquo;un objet d√©fini par l&rsquo;interpr√©teur.
On pourrait directement ajouter notre nouvelle propri√©t√© dans l&rsquo;objet en
question (ici, <code>globalBase</code>), mais le changement serait irr√©versible.  Pour que
ce changement soit d√©sactivable par <code>i13n.removeLayer</code>, il faut mettre dans
notre couche d&rsquo;instrumentation un objet qui contient la nouvelle propri√©t√©, et
qui d√©l√®gue les autres propri√©t√©s √† l&rsquo;objet initial.  C&rsquo;est conceptuellement le
m√™me principe que pour <code>around</code>, mais appliqu√© aux objets.
</p>

<p>
Et en JavaScript, il suffit d&rsquo;utiliser la d√©l√©gation par prototype pour r√©aliser
ce motif d&rsquo;extension:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">delegate</span>(<span style="font-weight: bold; font-style: italic;">o</span>, <span style="font-weight: bold; font-style: italic;">r</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">n</span> = Object.create(o)
  Object.assign(n, r)
  <span style="font-weight: bold;">return</span> n
}
</pre>
</div>

<div style="margin-top:-18rem" class="side-figure">

<figure>
<p><img src="img/dls13.svg" alt="dls13.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;40&nbsp;:</span> <code>delegate(o, r)</code> retourne un nouvel objet (<span class="color c1">‚ñ¨</span>), qui contient les propri√©t√©s de <code>r</code>, et d√©l√®gue les autres √† <code>o</code>. C&rsquo;est ce nouvel objet qu&rsquo;on ins√®re dans l&rsquo;environnement du module.</figcaption>
</figure>

</div>
</div>
</div>

<div id="outline-container-orgheadline124" class="outline-4">
<h4 id="orgheadline124"><span class="section-number-4">8.3.3</span> Ajouter l&rsquo;analyse FlowR</h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
Le principe de l&rsquo;analyse FlowR est d&rsquo;emp√™cher des flots de donn√©es illicites
dans le programme.  Pour cela, on colle des √©tiquettes sur les fonctions, comme
&laquo;&nbsp;priv√©e&nbsp;&raquo; ou &laquo;&nbsp;interne&nbsp;&raquo;, une approche similaire aux <i>principals</i> des valeurs √†
facettes.  Il y a deux cat√©gories d&rsquo;√©tiquettes: les √©tiquettes d&rsquo;<i>envoi</i> et les
√©tiquettes de <i>r√©ception</i>.  Une √©tiquette d&rsquo;envoi est propag√©e aux donn√©es
retourn√©es par la fonction, et une √©tiquette de r√©ception indique quelles
donn√©es peuvent √™tre pass√©es en argument √† la fonction.  L&rsquo;algorithme de FlowR
intercepte chaque appel de fonction, v√©rifie les √©tiquettes de r√©ception pour
s&rsquo;assurer que les arguments re√ßus sont compatibles, puis ex√©cute la fonction, et
propage les √©tiquettes d&rsquo;envoi sur la valeur retourn√©e.
</p>

<aside>
<p>
Cette description est incompl√®te, car il n&rsquo;est pas n√©cessaire de d√©tailler le
fonctionnement de l&rsquo;analyse pour la suite.  Le lecteur int√©ress√© par ces d√©tails
peut se plonger dans [<a href="#PBS-14">PBS14</a>].
</p>
</aside>

<p>
Un exemple, tir√© de [<a href="#PBS-14">PBS14</a>], o√π, apr√®s assignation des √©tiquettes aux objets
<code>Patient</code> et <code>PublicData</code>, le premier appel de m√©thode est ex√©cut√©, mais le
second est interrompu pour cause de flot invalide de donn√©es:
</p>

<pre class="example">
$ cat tests/flowr.js
setTag(Patient, 'receive', 'medical', 1);
setTag(Patient, 'receive', 'default', 0);
// [...] set other tags

var p = new Patient();
var d = new PublicData();

d.add(p.generate_anonymised_record());  // should pass
d.add(p.get_record());                  // should fail
</pre>

<pre class="example">
$ ./njs -l flowr -f tests/flowr.js
Illegal flow: undefined to [object Object]
</pre>

<p>
Pour r√©aliser cette analyse, il suffit donc de permettre au code client
d&rsquo;ajouter des √©tiquettes aux fonctions (via une fonction qu&rsquo;on appellera
<code>setTag</code>), et de capturer chaque appel de fonction afin d&rsquo;appliquer
l&rsquo;algorithme.  Dans Narcissus, l&rsquo;ex√©cution de fonction se fait sur les n≈ìuds de
l&rsquo;AST de type <code>CALL</code>, trait√© dans <code>execute</code>.  Mais en r√©alit√© le vrai travail
est d√©l√©gu√© √† la fonction <code>__call__</code> de l&rsquo;objet <code>FunctionObject</code>.  Pour
intercepter les appels de fonction, on pourrait donc se greffer √† l&rsquo;un ou
l&rsquo;autre endroit.  Nous allons choisir le second, puisqu&rsquo;il nous permet
d&rsquo;illustrer un autre motif d&rsquo;instrumentation.
</p>

<p>
On souhaite remplacer la fonction <code>__call__</code> par notre propre version, qui
ex√©cute l&rsquo;algorithme de FlowR.  Voici notre version:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">flowrCall</span>(<span style="font-weight: bold; font-style: italic;">__call__</span>, <span style="font-weight: bold; font-style: italic;">receiver</span>, <span style="font-weight: bold; font-style: italic;">args</span>, <span style="font-weight: bold; font-style: italic;">caller</span>) {

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[...] check send labels</span>

  <span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">ret</span> = __call__.call(<span style="font-weight: bold; text-decoration: underline;">this</span>, receiver, args, caller);

  <span style="font-weight: bold; font-style: italic;">// </span><span style="font-weight: bold; font-style: italic;">[...] propagate labels to return value</span>

  <span style="font-weight: bold;">return</span> ret;
}
</pre>
</div>

<p>
Il n&rsquo;est pas utile de s&rsquo;attarder sur le code qui applique l&rsquo;algorithme; ce sont
de simples appels √† des fonctions d√©finies dans le m√™me module.  En revanche, on
peut voir que l&rsquo;on fait ici appel √† la fonction <code>__call__</code> d&rsquo;origine, re√ßue
comme premier argument.  Donc notre <code>flowrCall</code> pourra √™tre install√© sur
<code>FunctionObjet</code> en utilisant <code>i13n.around</code> d√©fini plus haut.
</p>

<p>
L&rsquo;objet <code>FunctionObject</code> est l&rsquo;objet √† partir duquel toutes les fonctions du
code client sont instanci√©es‚Äîleur objet <i>prototype</i>.  Lorse l&rsquo;interpr√©teur
ex√©cute un appel de fonction, il d√©l√®gue le travail √† la propri√©t√© <code>__call__</code> de
la fonction en question.  Si on installe notre version <code>flowrCall</code> sur cet
objet, on remplace donc la fonction <code>__call__</code> sur toutes les instances de
fonctions client.  Mais on ne veut pas modifier directement un objet de
l&rsquo;interpr√©teur, car ce serait un changement irr√©versible.
</p>

<p>
Comme pour l&rsquo;analyse de trace, on va cr√©er un nouvel objet qui va contenir notre
nouvelle version <code>flowrCall</code>, et d√©l√©guer le reste des propri√©t√©s √† l&rsquo;objet
<code>FunctionObject</code> d&rsquo;origine.  On ins√®re ensuite ce nouvel objet dans une couche,
avec <code>i13n.pushLayer</code>, ce qui permettra de pouvoir le retirer dynamiquement.  Et
comme pour l&rsquo;analyse de trace, on peut utiliser <code>i13n.delegate</code> pour cela.
</p>

<p>
Mais il y a une l√©g√®re diff√©rence ici: <code>FunctionObjet</code>, contrairement
<code>globalBase</code>, est utilis√© comme <i>constructeur</i> d&rsquo;objet (pour cr√©er les fonctions
client).  Donc il faut aussi cr√©er notre propre constructeur.  Toute cette
machinerie est effectu√©e par la fonction <code>i13n.override</code>, qui utilise simplement
<code>around</code> et <code>delegate</code> apr√®s avoir cr√©er le constructeur:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">function</span> <span style="font-weight: bold;">override</span>(<span style="font-weight: bold; font-style: italic;">base</span>, <span style="font-weight: bold; font-style: italic;">methods</span>) {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">newConstr</span> = <span style="font-weight: bold;">function</span>(...args) {
    <span style="font-weight: bold;">return</span> base.apply(<span style="font-weight: bold; text-decoration: underline;">this</span>, args)
  }

  <span style="font-weight: bold;">for</span> (<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> <span style="font-weight: bold;">in</span> methods)
    methods[m] = around(base.<span style="font-weight: bold; text-decoration: underline;">prototype</span>[m], methods[m])

  newConstr.<span style="font-weight: bold; text-decoration: underline;">prototype</span> = delegate(base.<span style="font-weight: bold; text-decoration: underline;">prototype</span>, methods)

  <span style="font-weight: bold;">return</span> newConstr
}
</pre>
</div>

<p>
Et celle-ci nous permet d&rsquo;installer l&rsquo;analyse FlowR en quatre lignes:
</p>

<div class="org-src-container">

<pre class="src src-js">i13n.pushLayer(_env, {
  FunctionObject: i13n.override(_env.FunctionObject, {
    __call__: flowrCall }),
  globalBase: i13n.delegate(_env.globalBase, {setTag}),
})
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline125" class="outline-4">
<h4 id="orgheadline125"><span class="section-number-4">8.3.4</span> Ajouter l&rsquo;analyse d&rsquo;environnements</h4>
<div class="outline-text-4" id="text-8-3-4">
<p>
Les techniques que l&rsquo;on propose dans ce chapitre sont bas√©es essentiellement sur
la manipulation d&rsquo;environnements.  Pour mieux comprendre ces manipulations, on a
utilis√© des diagrammes qui repr√©sentent les objets et les environnements
cr√©√©s par l&rsquo;interpr√©teur, et leur relations.  Ces diagrammes sont un mod√®le
simplifi√© du fonctionnement de l&rsquo;interpr√©teur, mais sont bas√©s sur les
informations r√©colt√©es par l&rsquo;analyse d&rsquo;environnements.
</p>

<p>
L&rsquo;analyse d&rsquo;environnements est √† la fois le dernier exemple d&rsquo;anayse, mais
aussi un outil qui a servi pour construire les diagrammes de ce chapitre.  On va
donc s&rsquo;int√©resser √† son fonctionnement en plus de la fa√ßon de l&rsquo;impl√©menter sur
l&rsquo;interpr√©teur.
</p>

<p>
L&rsquo;analyse collecte tous les environnements cr√©√©s par l&rsquo;intepr√©teur, et les
inspecte pour r√©colter tous les objets cr√©√©s, en suivant les r√©f√©rences des
propri√©t√©s, les liens de prototype, et les liens d&rsquo;envrionnement parent.
</p>

<p>
Mais tous les objets ne nous int√©ressent pas de la m√™me fa√ßon.  De nombreux
objets font partie de l&rsquo;API standard offerte par le langage, comme <code>Array</code> ou
<code>String</code>.  Ce n&rsquo;est pas n√©cessaire de voir toutes leurs fonctions, toutes leurs
propri√©t√©s, quand on s&rsquo;int√©resse au fonctionnement de <code>with</code>.  On peut donc
param√©trer le collecte d&rsquo;objet par:
</p>

<ul class="org-ul">
<li>une liste noire indique quels objets il n&rsquo;est pas n√©cessaire d&rsquo;inspecter.  Si
l&rsquo;analyse recolte un objet pr√©sent dans la liste noire, ses propri√©t√©s ne sont
pas collect√©es r√©cursivement.  Typiquement, <code>Object.prototype</code> est un bon
candidat pour la liste noire.</li>

<li>une liste blanche permet d&rsquo;inspecter seulement les propri√©t√©s nomm√©es dans un
objet, et d&rsquo;ignorer les autres.  Quand on sait quel objet nous int√©resse,
cette liste permet de r√©duire consid√©rablement le bruit dans le graphe cr√©√©.
Dans l&rsquo;exemple ci dessous, seule la propri√©t√© <code>m</code> de l&rsquo;objet global est
inspect√©e.</li>

<li>la profondeur de recherche est le nombre d&rsquo;appels r√©cursifs maximum quand
l&rsquo;analyse suit les r√©f√©rences d&rsquo;un environnement.  Au del√†, les objets sont
&laquo;&nbsp;opaques&nbsp;&raquo;: leurs propri√©t√©s ne sont pas affich√©es.  La bo√Æte dessin√©e contient
juste un identifiant unique.</li>
</ul>

<p>
Sur cet exemple d&rsquo;utilisation de <code>with</code>, que l&rsquo;on a vu de nombreuses fois dans
ce chapitre:
</p>

<pre class="example">
$ cat tests/with.js
var m = (function() {
  var E = {};
  with (E) {
    var a = 1;
    return {E:E};
  }
}());

m.E.a = 2;

// [...] set up whitelist and blacklist of objects

printScope(2, whitelist, blacklist);
</pre>

<p>
L&rsquo;analyse produit un graphe au format <a href="https://en.wikipedia.org/wiki/DOT_(graph_description_language)">DOT</a> utilis√© par GraphViz.  On peut donc
produire une image en invoquant <code>dot</code>:
</p>

<pre class="example">
$ ./njs -l scope -f tests/with.js | dot -Tsvg
</pre>

<figure>

<figure>
<p><img src="img/env-with.svg" alt="env-with.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;41&nbsp;:</span> Les fl√™ches en pointill√©s indiquent les liens de prototype.  Les fl√™ches solides sont des r√©f√©rences.  On peut remarquer en haut √† gauche les environnements, qui font r√©f√©rence aux objets cr√©√©s par le code de l&rsquo;exemple.</figcaption>
</figure>
</figure>

<p>
Le rendu est un peu brouillon, mais toute l&rsquo;information est l√†.  On peut y
retrouver l&rsquo;objet <code>E</code>, l&rsquo;objet d&rsquo;activation de la FIA, l&rsquo;environnement cr√©√© par
<code>with</code>.  Et en faisant quelques simplifications, et en r√©organisant les bo√Ætes
manuellement, on obtient les diagrammes du chapitre.
</p>

<p>
Pour collecter les environnements, il suffit de se greffer dans la fonction
<code>execute</code> de l&rsquo;interpr√©teur, et de conserver les environnements dans un
ensemble.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">let</span> <span style="font-weight: bold; font-style: italic;">scopeObjects</span> = <span style="font-weight: bold;">new</span> <span style="font-weight: bold; text-decoration: underline;">Set</span>();

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">harvestScopeObject</span>(<span style="font-weight: bold; font-style: italic;">n</span>, <span style="font-weight: bold; font-style: italic;">x</span>) {
  scopeObjects.add(x.scope);
}

i13n.pushLayer(_env, {
  execute: i13n.before(_env.execute, harvestScopeObject),
  globalBase: i13n.delegate(_env.globalBase, {printScope}),
});
</pre>
</div>

<p>
On utilise cette fois <code>i13n.before</code> plut√¥t que <code>around</code>, qui fait aussi √©cho au
<i>pointcut</i> d&rsquo;AspectJ.  La fonction <code>harvestScopeObject</code> sera invoqu√©e avant
chaque appel d&rsquo;<code>execute</code>, et r√©coltera l&rsquo;environnement courant.
</p>

<p>
La fonction <code>printScope</code>, que l&rsquo;on rajoute dans l&rsquo;environnement client, va
d&rsquo;abord construire le graphe en parcourant tous les objets r√©colt√©s, puis
produire le fichier au format au DOT.
</p>
</div>
</div>

<div id="outline-container-orgheadline126" class="outline-4">
<h4 id="orgheadline126"><span class="section-number-4">8.3.5</span> √âvaluation</h4>
<div class="outline-text-4" id="text-8-3-5">
<p>
L&rsquo;instrumentation de Narcissus pour l&rsquo;√©valuation multi-facettes que l&rsquo;on a
r√©alis√© consiste en 440 lignes de code, dans un seul fichier s√©par√© de
l&rsquo;interpr√©teur; l&rsquo;instrumentation faite par Austin et Flanagan comportait 640
lignes m√™l√©es au code de l&rsquo;interpr√©teur.  Notre version factorise quelques
changements, ce qui explique la diff√©rence.  L&rsquo;int√©r√™t d&rsquo;avoir tous les
changements dans un seul fichier √† part c&rsquo;est qu&rsquo;on peut les √©tudier et avoir
une id√©e de comment l&rsquo;√©valuation multi-facettes vient modifier l&rsquo;interpr√©teur.
On peut par exemple comparer le code de l&rsquo;instrumentation avec la s√©mantique de
r√©f√©rence de [<a href="#AF-12">AF12</a>].
</p>

<p>
Pour ajouter l&rsquo;√©valuation multi-facettes, on a ajout√© 19 lignes √† Narcissus pour
ouvrir le module avec <code>with</code>, et chang√© 32 lignes pour ajouter la fonction
<code>populateEnvironment</code> et nommer la fonction anonyme.  En tout 51 lignes sur 1300
sont touch√©es, √† comparer avec les 640 lignes de l&rsquo;instrumentation d&rsquo;Austin et
Flanagan.  Mais m√™me si les changements sont restreints, il est important de
noter qu&rsquo;il √©tait tout de m√™me n√©cessaire de modifier le code de Narcissus.  Les
changements, m√™me mineurs, ont n√©cessit√© d&rsquo;inspecter et de comprendre les
diff√©rentes √©tapes de construction de l&rsquo;interpr√©teur.
</p>

<aside style="margin-top:-4rem">
<p>
Bien s√ªr, on aurait pu √©crire un outil pour modifier automatiquement les lignes
de Narcissus qui nous int√©ressent, et consid√©rer ainsi qu&rsquo;aucune ligne de
Narcissus n&rsquo;a √©t√© modifi√©e directement.  Mais non seulement √ßa ne change pas
fondamentalement la situation (le code doit √™tre modifi√©), ce serait en plus
une transformation fragile car bas√©e sur la syntaxe du code plut√¥t que sur sa
s√©mantique.
</p>
</aside>

<p>
En plus de l&rsquo;√©valuation multi-facettes, on a d√©fini trois autres analyses sur
l&rsquo;interpr√©teur: une analyse de flot d&rsquo;information, une simple analyse de trace,
et une analyse qui extrait les environnements allou√©s par l&rsquo;interpr√©teur.  On a
pu √©crire ces trois analyses ont dans des fichiers s√©par√©s, sans avoir besoin de
modifier le code de l&rsquo;interpr√©teur.  Qui plus est, on a pu extraire des motifs
communs d&rsquo;instrumentation de fonctions (<code>around</code>, <code>before</code>), d&rsquo;objets
(<code>delegate</code>), ou les deux (<code>override</code>).
</p>

<p>
En utilisant la technique de disposition en couches de la section <a href="#orgheadline119">8.1.3</a>, on peut activer plusieurs analyses √†
l&rsquo;ex√©cution avec des options de lancement.  Par exemple:
</p>

<pre class="example">
./njs -l flowr -l trace -f tests/flowr.js
</pre>

<p>
lance l&rsquo;interpr√©teur, active l&rsquo;analyse FlowR, et active aussi la trace avant
d&rsquo;ex√©cuter le code du fichier &laquo;&nbsp;tests/flowr.js&nbsp;&raquo;.  Un extrait de la sortie montre
que les deux analyses fonctionnent en m√™me temps:
</p>

<pre class="example">
    CALL d.add(p.get_record())
      DOT d.add
        IDENTIFIER d
      LIST
        CALL p.get_record()
          DOT p.get_record
            IDENTIFIER p
          LIST
          SCRIPT
Illegal flow: undefined to [object Object]
</pre>

<p>
Le <code>Illegal flow</code> est produit par FlowR, et les autres lignes par la trace.
L&rsquo;union des deux sorties permet de visualiser √† quel moment de l&rsquo;interpr√©tation
les flots non autoris√©s se produisent, sans avoir √† rajouter du code sp√©cifique
√† la trace dans l&rsquo;analyse FlowR.
</p>

<p>
La trace ne modifie qu&rsquo;une seule fonction de l&rsquo;interpr√©teur, et cette
modification est compatible avec les modifications apport√©es par FlowR.
Intuitivement, on voit bien que la trace est orthogonale au contr√¥le d&rsquo;acc√®s
effectu√© par FlowR.  C&rsquo;est pourquoi les deux analyses peuvent √™tre activ√©es en
m√™me temps sans que l&rsquo;on ait besoin de rajouter du code sp√©cifique √†
l&rsquo;int√©gration de deux.  Ce n&rsquo;est pas le cas pour l&rsquo;√©valuation multi-facettes et
FlowR.  L&rsquo;√©valuation multi-facettes modifie les <i>valeurs</i> manipul√©es par
l&rsquo;interpr√©teur, et FlowR rajoute des <i>labels</i> sur ces valeurs.  Du coup, les
deux analyses touchent √† la repr√©sentation des valeurs dans l&rsquo;interpr√©teur.  En
regardant leur sp√©cification, on ne peut pas dire clairement comment les deux
analyses doivent se combiner, ni ce que le r√©sultat d&rsquo;une √©valuation devrait
produire.  Il faut donc retenir que la disposition en couches permet de
facilement activer plusieurs modifications de l&rsquo;interpr√©teur en m√™me temps, mais
que le r√©sultat n&rsquo;a de sens que si ces modifications n&rsquo;interf√®rent pas entre
elles.
</p>

<aside style="margin-top:-4rem">
<p>
Comment d√©tecter et r√©soudre ces interf√©rences reste un probl√®me ouvert.
</p>
</aside>

<p>
Pour s&rsquo;assurer qu&rsquo;appliquer <code>with</code> pour ouvrir Narcissus n&rsquo;a pas chang√© son
fonctionnement, nous avons compar√© le comportement de la version d&rsquo;origine et la
version avec <code>with</code> sur la suite de tests <code>test262</code>.  Cette suite contient plus
de 11000 tests de conformit√© de la sp√©cification ECMAScript 5.1.  Nous avons
utilis√© un sous-ensemble de cette suite, utilis√© pour tester le moteur
JavaScript SpiderMonkey de Mozilla.  Sur environ 3300 tests valid√©s par
SpiderMonkey, Narcissus en passe 2600.  Nous avons donc lanc√© la version
originale de Narcissus et la version avec <code>with</code> sur ces 3300 tests.  Pour la
version avec <code>with</code>, aucune analyse n&rsquo;√©tait activ√©e: l‚Äòobjet de liaison restait
donc vide.  Pour chaque test, notre script comparait la sortie des deux
versions; si la sortie √©tait identique, le test √©tait pass√©, sinon, le test
√©tait √©chou√© et le script enregistrait le test qui avait √©chou√©.  Au final, les
deux versions ont un comportement strictement identique sur ce jeu de tests.
</p>

<p>
Nous avons aussi pu comparer Narcissus avec et sans l&rsquo;√©valuation multi-facettes
sur ce m√™me jeu de tests.  Lorsque le <i>program counter</i> de l&rsquo;√©valuation
multi-facettes est vide, l&rsquo;interpr√©teur se comporte de fa√ßon identique sur les
tests consid√©r√©s.  Un r√©sultat d√©montr√© par Austin et Flanagan sur la s√©mantique
de l&rsquo;√©valuation, bas√©e sur un lambda-calcul, mais pas sur l&rsquo;impl√©mentation qui
concerne le langage JavaScript dans toute sa largeur.
</p>

<p>
En ex√©cutant les tests, nous avons aussi mesur√© le temps d&rsquo;ex√©cution de chaque
version.  Pour chaque version, le jeu de test a √©t√© lanc√© dix fois, sur un seul
thread, toujours sur la m√™me machine.  Le tableau donne la moyenne arithm√©tique
du temps pour une ex√©cution compl√®te sur ces dix lancers.
</p>

<aside>
<p>
Les tests ont √©t√© effectu√© sur un PC portable contenant un Intel i5-3320M
2.60GHz et 4Gb de RAM.  Narcissus a √©t√© lanc√© √† travers une <a href="https://ftp.mozilla.org/pub/firefox/nightly/latest-mozilla-central/jsshell-linux-x86_64.zip">version de
d√©veloppement</a> de SpiderMonkey (version JavaScript-C36.0a1).  Les tests
proviennent de la version de d√©veloppement de <a href="https://mxr.mozilla.org/mozilla-central/source/js/src/tests/">mozilla-central</a> et ont √©t√©
ex√©cut√©s par le script <code>jstests.py</code> d√©velopp√© par Mozilla.
</p>
</aside>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Interpr√©teur</th>
<th scope="col" class="org-left">Temps moyen (secondes)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SpiderMonkey</td>
<td class="org-left">89 (¬± 1)</td>
</tr>

<tr>
<td class="org-left">Narcissus original</td>
<td class="org-left">1040 (¬± 1)</td>
</tr>

<tr>
<td class="org-left">Narcissus avec <code>with</code></td>
<td class="org-left">1218 (¬± 10)</td>
</tr>

<tr>
<td class="org-left">Narcissus et multi-facettes (Austin et Flanagan)</td>
<td class="org-left">1215 (¬± 2)</td>
</tr>

<tr>
<td class="org-left">Narcissus et multi-facettes avec <code>with</code></td>
<td class="org-left">1301 (¬± 1)</td>
</tr>
</tbody>
</table>

<aside>
<p>
En moyenne, un test prend donc environ 0.5 seconde √† s&rsquo;ex√©cuter.  Comme
l&rsquo;interpr√©teur est relanc√© pour chaque test, et que, dans le cas de Narcissus, il
faut <i>√©valuer</i> tout l&rsquo;intepr√©teur avant de pouvoir ex√©cuter le test, ce temps de
lancement se rajoute √† chaque test.  Sur la m√™me machine, lancer Narcissus sur
un fichier vide prend 0.07 seconde en moyenne.  Activer les diff√©rentes analyses
ne change pas cette mesure.
</p>
</aside>

<p>
L&rsquo;√©cart type est √† moins de 1% pour toutes les versions de Narcissus, donc les
temps moyens sont repr√©sentatifs.  Si on compare l&rsquo;interpr√©teur non instrument√©
avec la version o√π on ajoute juste <code>with</code> autour du code du module, la seconde
version prend 17% de temps suppl√©mentaire pour ex√©cuter le jeu de tests.  Ce
surco√ªt est probablement d√ª √† l&rsquo;utilisation de <code>with</code>, qui rajoute un
environnement dans la cha√Æne de r√©solution des noms.  Non seulement √ßa fait un
objet de plus √† parcourir lors de la r√©solution de <i>n&rsquo;importe quel nom</i> du
module, mais en plus les fonctions qui ont des variables libres ne peuvent pas
√™tre optimis√©es par le compilateur.  L√† o√π, sans <code>with</code>, un acc√®s √† une variable
libre peut √™tre r√©solu statiquement en regardant dans l&rsquo;environnement lexical de
la fonction, avec <code>with</code> la variable peut changer dynamiquement, donc le moteur
d&rsquo;ex√©cution doit toujours r√©soudre le nom dynamiquement; aucun raccourci n&rsquo;est
possible.
</p>

<aside>
<p>
Et il faut aussi comprendre que <code>with</code> est un mot-cl√© du langage qui
est rarement utilis√©, c&rsquo;est donc raisonnable si les d√©veloppeurs de moteurs
d&rsquo;ex√©cution ne cherchent pas √† l&rsquo;optimiser davantage.
</p>
</aside>

<p>
Si on compare l&rsquo;interpr√©teur instrument√© par Austin et Flanagan pour
l&rsquo;√©valuation multi-facettes, le surco√ªt de temps n&rsquo;est plus que 7%.  Notons
cependant que notre impl√©mentation de l&rsquo;√©valuation multi-facettes factorise
quelques changements par rapport √† l&rsquo;impl√©mentation de base, on ne mesure pas
seulement l&rsquo;utilisation de <code>with</code>.
</p>

<p>
De toutes fa√ßons, comme l&rsquo;indique le tableau, ex√©cuter n&rsquo;importe quel exemple
avec Narcissus est d&rsquo;un ordre de grandeur plus lent qu&rsquo;avec SpiderMonkey
directement.  C&rsquo;est √©videmment d√ª au fait que Narcissus est √©crit en JavaScript.
Mais pour nos besoins, les plus gros exemples qu&rsquo;on a voulu ex√©cuter avec les
diff√©rentes analyses qu&rsquo;on a ajout√© √† Narcissus n&rsquo;ont pris que quelques
secondes.  √Ä cette √©chelle, une diff√©rence de 17% est insignifiante.
</p>

<p>
Le gain de temps en √©criture de code et en clart√© de l&rsquo;instrumentation est,
quant √† lui, tangible.  Avant de pouvoir ex√©cuter la suite <code>test262</code> avec
Narcissus, il a fallu corriger quelques erreurs dans son interpr√©tation du code
JavaScript et compl√©ter sa couverture du standard.  En corrigeant ces erreurs
dans l&rsquo;interpr√©teur d&rsquo;origine, il a fallu dupliquer les correctifs dans la
version instrument√©e par Austin et Flanagan, mais pas dans notre
instrumentation.  Notre version de l&rsquo;√©valuation multi-facettes ne duplique pas
le code de l&rsquo;interpr√©teur, donc une fois le correctif appliqu√© √† l&rsquo;interpr√©teur
de base, l&rsquo;√©valuation multi-facettes b√©n√©ficiait du correctif automatiquement.
Cette anecdote illustre l&rsquo;int√©r√™t d&rsquo;une d√©composition qui cherche √† minimiser la
duplication de code.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline133" class="outline-3">
<h3 id="orgheadline133"><span class="section-number-3">8.4</span> Discussion</h3>
<div class="outline-text-3" id="text-8-4">
<p>
L&rsquo;id√©e principale de ce chapitre est que la manipulation de la port√©e des
variables d&rsquo;un module est suffisante pour changer totalement le comportement de
ce module.  Et si on peut changer int√©gralement le comportement du module, on
peut n√©cessairement en changer une partie; c&rsquo;est ce qui nous a permis de
modifier Narcissus pour accepter plusieurs analyses dynamiquement.
</p>
</div>

<div id="outline-container-orgheadline128" class="outline-4">
<h4 id="orgheadline128"><span class="section-number-4">8.4.1</span> La tension entre flexibilit√© et s√ªret√©</h4>
<div class="outline-text-4" id="text-8-4-1">
<p>
On peut voir la propri√©t√© <code>E</code> qui expose l&rsquo;environnement manipulable du module
comme une interface sp√©ciale, une interface d&rsquo;instrumentation, qu&rsquo;on peut
rapprocher du concept d&rsquo;&laquo;&nbsp;impl√©mentation ouverte&nbsp;&raquo; de [<a href="#Kic-96">Kic96</a>].  Cette interface
sp√©ciale expose <i>tous</i> les noms de l&rsquo;interpr√©teur, et conf√®re donc aux
programmeurs non seulement le pouvoir de modifier le code du module, mais
√©galement de casser ce code en cr√©ant des situations non anticip√©es par le
cr√©ateur du module.  Comme on a pu changer la fonction <code>execute</code> pour √©tendre sa
fonctionnalit√©, on aurait pu tout aussi bien fournir une version qui lance une
exception.  Pas tr√®s utile dans notre cas, mais √ßa montre qu&rsquo;il est tr√®s facile
de rompre la fonctionnalit√© offerte par le module d√®s lors que cette interface
sp√©ciale est offerte.
</p>

<p>
On a alors une situation quelque peu paradoxale o√π le programmeur soucieux de
l&rsquo;int√©grit√© de son code le ficelle dans un module, mais ce faisant emp√™che tout
autre programmeur d&rsquo;√©tendre son code dynamiquement.  Le code a beau utiliser un
module, il ne peut √™tre √©tendu; il n&rsquo;est donc pas <i>modulaire</i> par rapport aux
changements que l&rsquo;on souhaite y apporter, car il faut modifier le code source √†
l&rsquo;int√©rieur du module pour effectuer ces changements.  Et √† l&rsquo;inverse, la
solution propos√©e ici casse la protection offerte par le module, mais ce faisant
permet d&rsquo;√©tendre le code en √©crivant les changements et fonctionnalit√©s
suppl√©mentaires dans des fichiers distincts; une situation que l&rsquo;on peut
qualifier de <i>modulaire</i>.
</p>

<p>
La version originale du module, et notre version modifiable dynamiquement sont
deux points oppos√©s sur un m√™me axe.  D&rsquo;un c√¥t√©, un programme pr√©visible, sur
lequel il est facile de raisonner statiquement, car son comportement ne peut
√™tre modifi√© dynamiquement; et de l&rsquo;autre, un programme ouvert, dont le
comportement peut changer √† tout moment de l&rsquo;ex√©cution, mais qui offre une
grande flexibilit√©.  Les propri√©t√©s offertes par l&rsquo;un et l&rsquo;autre sont toutes
d√©sirables: a priori, on pr√©f√©rerait avoir un programme pr√©visible et
reconfigurable √† souhait.  Mais il est facile de voir que les deux buts sont
antagonistes.
</p>

<p>
Prenons une simple fermeture:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>() { <span style="font-weight: bold;">return</span> a }
</pre>
</div>

<p>
√Ä voir le code, on peut d√©clarer que lorsqu&rsquo;on appelle <code>f</code>, elle renvoie
toujours 1.  C&rsquo;est une fermeture sur <code>a</code>, et la valeur de <code>a</code> ne peut pas √™tre
modifi√©e car <code>a</code> est constante.  &laquo;&nbsp;<code>f</code> renvoie 1&nbsp;&raquo; est donc un invariant qui est
utile pour le programmeur, une garantie du code qui permet de mieux comprendre
les comportement des sites d&rsquo;appels de <code>f</code>.
</p>

<p>
Mais en m√™me temps, cette garantie rend la fonction inflexible.  On ne peut pas
changer le comportement de <code>f</code> sans violer cette garantie.  Si on applique la
technique de ce chapitre pour ouvrir la fonction avec <code>with</code>:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">E</span> = {}
<span style="font-weight: bold;">with</span> (E) {
  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>() { <span style="font-weight: bold;">return</span> a }
}

f() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>

E.a = 2
f() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
</pre>
</div>

<p>
alors maintenant on peut modifier la valeur de retour de <code>f</code>, car on peut
modifier <code>a</code>.  C&rsquo;est donc que la garantie ne tient plus.  Tout ce qu&rsquo;on peut
dire de <code>f</code> c&rsquo;est quelle retourne la valeur de <code>a</code> contenue dans <code>E</code>, si elle
existe, et 1 sinon.  Mais comme on ne sait rien de la valeur de <code>a</code> contenue
dans <code>E</code>, autant dire que <code>f</code> renvoie n&rsquo;importe quoi.  On n&rsquo;a plus aucune
garantie sur <code>f</code>, mais une flexibilit√© compl√®te pour la modifier.
</p>

<p>
On pourrait retrouver certaines garanties.  Par exemple, si on veut que <code>a</code> soit
toujours un nombre plus petit que 10, on peut prot√©ger l&rsquo;objet <code>E</code> et renvoyer
un proxy:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">const</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1

<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>() {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">E</span> = {}
  <span style="font-weight: bold;">with</span> (E) { <span style="font-weight: bold;">function</span> f() { <span style="font-weight: bold;">return</span> a } }

  <span style="font-weight: bold;">return</span> {f,
    E: {
      set a(v) {
        <span style="font-weight: bold;">if</span> (<span style="font-weight: bold;">typeof</span> v === <span style="font-style: italic;">'number'</span> &amp;&amp; v &lt; 10)
          E.a = v
      }
  }}
}())

m.f() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>

m.E.a = 2
m.f() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>

m.E.a = <span style="font-style: italic;">"44"</span>
m.f() <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
</pre>
</div>

<p>
De cette fa√ßon, on retrouve une garantie: <code>m.f</code> renverra toujours un nombre plus
petit que 10.  Mais en √©change, on perd en flexibilit√©, puisque <code>a</code> doit ob√©ir √†
cette contrainte.  D√®s lors qu&rsquo;on ajoute une contrainte, comme <code>a &lt; 10</code>, la
n√©gation de cette contrainte n&rsquo;est plus un cas possible pour le programme.
Chaque contrainte restreint le programme, et assure ainsi des garanties
suppl√©mentaires, mais chaque contrainte exclut √©galement des possibilit√©s.
</p>

<div style="margin-top:-10rem" class="side-figure">

<figure>
<p><img src="img/dls14.svg" alt="dls14.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;42&nbsp;:</span> Imposer une contrainte sur une variable, ce n&rsquo;est pas seulement d√©finir l&rsquo;ensemble de ses valeurs <i>possibles</i>, c&rsquo;est aussi d√©finir l&rsquo;ensemble des valeurs <i>exclues</i>.</figcaption>
</figure>

</div>

<p>
Si on ne peut pas compl√®tement r√©concilier la flexibilit√© dynamique et la
garantie statique, on peut <i>choisir</i> le compromis entre ces deux extr√™mes.  Il y
a toute une dimension entre le motif module, qui fixe les d√©finitions, et
l&rsquo;utilisation de <code>with</code> dans le module, qui permet de les changer.  C&rsquo;est au
programmeur de choisir le compromis le mieux adapt√© au probl√®me.
</p>
</div>
</div>

<div id="outline-container-orgheadline129" class="outline-4">
<h4 id="orgheadline129"><span class="section-number-4">8.4.2</span> D&rsquo;autres fa√ßons d&rsquo;√©tendre l&rsquo;interpr√©teur</h4>
<div class="outline-text-4" id="text-8-4-2">
<p>
Il y a d&rsquo;autres fa√ßons, plus √©videntes, d&rsquo;ouvrir le module.  Pour commencer,
puisqu&rsquo;on cherche √† briser la protection offerte par la fonction anonyme,
pourquoi ne pas l&rsquo;enlever?  Et d√©finir nos fonctions directement √† la racine:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x) }

g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>
</pre>
</div>

<p>
Ainsi, on peut red√©finir les fonctions et les valeurs comme on le souhaite, et
m√™me dans des fichiers s√©par√©s, puisque toutes les d√©finitions r√©sident dans le
m√™me environnement.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a }
<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x) }

g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>

<span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> 2 }
g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
</pre>
</div>

<p>
Mais utiliser <code>with</code> pour ouvrir le module n&rsquo;an√©antit pas toutes les protections
offertes par la FIA.  Avec <code>with</code>, on b√©n√©ficie encore de l&rsquo;espace de nommage
fourni par la fonction: toutes les d√©finitions sont export√©es dans un objet <code>m</code>,
ou <code>Narcissus.interpreter</code>, ce qui r√©duit les chances d&rsquo;une red√©finition
accidentelle.  Si on met toutes les d√©finitions √† la racine, alors on perd cet
avantage.
</p>

<p>
On peut utiliser un objet pour prot√©ger les d√©finitions mais garder la
possibilit√© de les modifier:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = {
  a: 1,
  f(x) { <span style="font-weight: bold;">return</span> x + m.a },
  g(x) { <span style="font-weight: bold;">return</span> m.f(x) },
}

m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 1</span>

m.f = <span style="font-weight: bold;">function</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> 2 }
m.g(0) <span style="font-weight: bold; font-style: italic;">//</span><span style="font-weight: bold; font-style: italic;">: 2</span>
</pre>
</div>

<p>
√áa demande de toujours pr√©fixer les r√©f√©rences aux d√©finitions du module par
l&rsquo;identifiant de l&rsquo;objet (ici, <code>m</code>).  Pour cet exemple, √ßa ne fait que deux
caract√®res en plus.  Mais pour modifier un module existant, comme Narcissus, il
faudrait pr√©fixer des centaines de r√©f√©rences.  Et cette t√¢che ne peut pas √™tre
automatis√©e √† tout coup, puisque le langage nous permet d&rsquo;acc√©der √† des
r√©f√©rences indirectement (<code>m["f"]</code>).  C&rsquo;est donc une solution moins pratique que
de juste ajouter <code>with</code> autour du code.
</p>

<p>
Une autre solution, plus classique, serait de commencer par √©tablir les points
d&rsquo;extension n√©cessaires pour les diff√©rentes analyses qu&rsquo;on envisage d&rsquo;utiliser
(la fonction <code>execute</code>, par exemple), puis de rajouter un m√©canismes explicite
d&rsquo;appel aux analyses quand l&rsquo;interpr√©teur entre dans ces points.  On pourrait
utiliser des <i>hooks</i>, ou le patron Observateur, ou encore accepter un Visiteur;
les trois m√©thodes permettent d&rsquo;appeler du code ext√©rieur au module √† un moment
pr√©cis du flot d&rsquo;ex√©cution.
</p>

<div class="side-figure">

<figure>
<p><img src="img/dls15.svg" alt="dls15.svg">
</p>
<figcaption><span class="figure-number">Figure&nbsp;43&nbsp;:</span> Un <i>hook</i> est juste un appel explicite √† une liste de fonctions. C&rsquo;est le code ext√©rieur au module qui s&rsquo;ajoute dans cette liste.</figcaption>
</figure>

</div>

<p>
Avec des <i>hooks</i>, ou un Observateur, il faut rajouter du code √† l&rsquo;int√©rieur du
module, √† tous les endroits o√π du code externe voudrait s&rsquo;ins√©rer, pour appeler
<i>explicitement</i> soit une liste de fonctions, soit une liste d&rsquo;observateurs.  Le
code externe doit √† son tour d√©clarer quelles fonctions ou quel observateur il
souhaite ajouter dans l&rsquo;interpr√©teur.  Le transfert de contr√¥le est explicite:
il suffit de suivre le code dans l&rsquo;interpr√©teur pour voir les appels √† des
<i>hooks</i>, ou une lev√©e d&rsquo;√©v√©nements pour des observateurs.  L&rsquo;inconv√©nient est
d&rsquo;avoir √† identifier les endroits qui peuvent int√©resser du code externe, et
d&rsquo;ajouter des <i>hooks</i> explicitement dans le code pour chacun d&rsquo;eux.
</p>

<p>
On utilise g√©n√©ralement ces techniques pour appeler du code qui <i>ne change pas</i>
le flot de contr√¥le du module.  Une fonction appel√©e par un <i>hook</i> n&rsquo;effectue
que des effets de bord (affichage sur la sortie standard), ou modifie des
valeurs de son propre module; le processus de l&rsquo;interpr√©teur n&rsquo;est pas impact√©.
Ce serait donc une technique suffisante pour impl√©menter l&rsquo;analyse de trace ou
d&rsquo;environnement, qui ne font qu&rsquo;observer la descente r√©cursive de
l&rsquo;interpr√©teur, mais l&rsquo;analyse multi-facettes et l&rsquo;analyse de flot requi√®rent de
changer le r√©sultat.
</p>

<p>
Le patron Visiteur permettrait de changer le r√©sultat de l&rsquo;interpr√©teur.  Si on
suit ce patron, il faut r√©√©crire l&rsquo;interpr√©teur pour appeler, pour chaque n≈ìud
de l&rsquo;AST, la m√©thode correspondante sur objet <i>visiteur</i>.  Cet objet est pass√© √†
l&rsquo;interpr√©teur avant l&rsquo;√©valuation de code, et c&rsquo;est ce visiteur qui contient la
logique d&rsquo;√©valuation.  L&rsquo;√©valuation du code JavaScript standard devrait donc
√™tre mise dans un tel objet, pour ob√©ir √† l&rsquo;interface du visiteur.  Et les
analyses pourraient alors √©galement ob√©ir √† cette interface, et r√©utiliser le
code de l&rsquo;√©valuation standard par simple d√©l√©gation.
</p>

<p>
Ici encore, le flot de contr√¥le est explicite: toute la logique est d√©l√©gu√©e au
visiteur.  L&rsquo;inconv√©nient majeur est qu&rsquo;il faut d&rsquo;abord √©tablir une interface de
visiteur qui convient √† tous les besoins des diff√©rentes analyses, puis
compl√®tement r√©√©crire l&rsquo;interpr√©teur pour se conformer √† cette interface.
</p>

<p>
Toutes ces techniques demandent donc de modifier l&rsquo;interpr√©teur en profondeur,
alors qu&rsquo;on a vu que <code>with</code> suffisait pour red√©finir n&rsquo;importe quelle fonction
de l&rsquo;interpr√©teur, sans avoir √† d√©finir d&rsquo;interface au pr√©alable, et en
n&rsquo;ajoutant que quelques lignes.
</p>

<p>
Une diff√©rence majeure n√©anmoins est que si le module utilise un hook, un
observateur, ou un visiteur, alors les extensions de ce module (les analyses
dans le cas de l&rsquo;interpr√©teur) doivent n√©cessairement passer par l&rsquo;interface
d&rsquo;extension d√©finies par l&rsquo;interpr√©teur.  Avec <code>with</code>, ce sont les extensions
elles-m√™mes qui peuvent red√©finir n&rsquo;importe quelle fonction du module; comme si
l&rsquo;interface d&rsquo;extension √©tait totale, mais sans avoir √† le d√©clarer
explicitement.  Avec <code>with</code>, le programmeur des extensions a la responsabilit√©
de maintenir le lien qui lui permet d&rsquo;inclure son code dans le processus de
l&rsquo;interpr√©teur (les appels √† <code>around</code>, <code>override</code>, <code>delegate</code>, &#x2026;); le
programmeur de l&rsquo;interpr√©teur ne peut pas savoir o√π les extensions vont se
greffer, il n&rsquo;a pas √† s&rsquo;en soucier, d&rsquo;o√π moins de code √† maintenir.  C&rsquo;est
l&rsquo;inverse pour les techniques explicites.
</p>
</div>
</div>

<div id="outline-container-orgheadline130" class="outline-4">
<h4 id="orgheadline130"><span class="section-number-4">8.4.3</span> Pourquoi ne pas utiliser la programmation par aspects?</h4>
<div class="outline-text-4" id="text-8-4-3">
<p>
√âtendre un module par du code ext√©rieur sans que le code du module n&rsquo;expose
d&rsquo;interface pour, activer et d√©sactiver les extensions dynamiquement, les
combiner &#x2026; ces objectifs rappellent fortement la programmation par aspects.
</p>

<p>
Comme on l&rsquo;a vu dans les diff√©rentes analyses ajout√©es √† Narcissus, on utilise le
vocabulaire d&rsquo;AspectJ: <code>around</code>, <code>before</code>, <code>proceed</code>.  Donc pourquoi ne pas
utiliser directement la programmation par aspects, qui est un paradigme g√©n√©ral,
plut√¥t que de passer par <code>with</code> et les prototypes, qui sont des m√©canismes
propres √† JavaScript?
</p>

<p>
En utilisant une biblioth√®que d&rsquo;aspect pour JavaScript, on pourrait d√©finir
chaque analyse dans son propre fichier, puis l&rsquo;int√©grer dynamiquement √†
l&rsquo;ex√©cution de l&rsquo;interpr√©teur avec des <i>advice</i> qui ciblent les <i>joinpoint</i>
ad√©quats (l&rsquo;appel de <code>execute</code>).  On pourrait activer et d√©sactiver les <i>advice</i>
pour activer ou d√©sactiver dynamiquement les analyses.  On aurait effectivement
le m√™me r√©sultat, mais exprim√© en terme d&rsquo;aspects; une technique qui pourrait
plus facilement se transporter √† tout langage disposant d&rsquo;une biblioth√®que de
programmation par aspects.
</p>

<p>
Id√©alement.
</p>

<p>
On a initialement cherch√© √† utiliser une biblioth√®que d&rsquo;aspects pour
instrumenter Narcissus: AspectScript est la plus compl√®te [<a href="#TLT-10">TL√T10</a>].  Il y a deux
raisons majeures de pr√©f√©rer l&rsquo;approche de ce chapitre √† AspectScript pour
l&rsquo;instrumentation de Narcissus: la compatibilit√© et la performance.
</p>

<p>
AspectScript est une biblioth√®que d&rsquo;aspect qui r√©ifie <i>tout le code</i> qui doit
√™tre instrument√©.  Pour qu&rsquo;un module puisse √©mettre des <i>joinpoint</i>, il faut
l&rsquo;envoyer √† AspectScript, qui va le parser, et √©mettre du code qui r√©ifie les
d√©clarations, les appels de fonction, les affectations de variable, toutes les
constructions du langage en appels explicites √† AspectScript.  C&rsquo;est comme √ßa
qu&rsquo;AspectScript peut capturer n&rsquo;importe quel √©v√®nement du module.
</p>

<p>
AspectScript transforme ce module:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = (<span style="font-weight: bold;">function</span>() {
  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = 1;
  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">f</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> x + a; }
  <span style="font-weight: bold;">function</span> <span style="font-weight: bold;">g</span>(<span style="font-weight: bold; font-style: italic;">x</span>) { <span style="font-weight: bold;">return</span> f(x); }
  <span style="font-weight: bold;">return</span> {g: g, f: f};
}());
</pre>
</div>

<p>
en ce code:
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">m</span> = AS.i13n.propWrite(
  AS.globalObject, <span style="font-style: italic;">"m"</span>,
  (AS.i13n.call(
    AS.globalObject,
    AS.i13n.wrap(<span style="font-weight: bold;">function</span>(){<span style="font-weight: bold;">return</span> (<span style="font-weight: bold;">function</span> (){
      {<span style="font-weight: bold; text-decoration: underline;">arguments</span>.callee = <span style="font-weight: bold; text-decoration: underline;">arguments</span>.callee.wrapper;
       <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">f</span> = AS.i13n.varWrite(
         <span style="font-style: italic;">"f"</span>,
         AS.i13n.wrap(<span style="font-weight: bold;">function</span>(){<span style="font-weight: bold;">return</span> (<span style="font-weight: bold;">function</span> f(<span style="font-weight: bold; font-style: italic;">x</span>){
           {<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">f</span> = <span style="font-weight: bold; text-decoration: underline;">arguments</span>.callee
                  = <span style="font-weight: bold; text-decoration: underline;">arguments</span>.callee.wrapper;
            <span style="font-weight: bold;">return</span> (AS.i13n.varRead(<span style="font-style: italic;">"x"</span>,x))
                   + (AS.i13n.varRead(<span style="font-style: italic;">"a"</span>,a));
           }})}),<span style="font-weight: bold; text-decoration: underline;">undefined</span>);
       <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">g</span> = AS.i13n.varWrite(
         <span style="font-style: italic;">"g"</span>,
         AS.i13n.wrap(<span style="font-weight: bold;">function</span>(){<span style="font-weight: bold;">return</span> (<span style="font-weight: bold;">function</span> g(<span style="font-weight: bold; font-style: italic;">x</span>){
           {<span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">g</span> = <span style="font-weight: bold; text-decoration: underline;">arguments</span>.callee
                  = <span style="font-weight: bold; text-decoration: underline;">arguments</span>.callee.wrapper;
            <span style="font-weight: bold;">return</span> AS.i13n.call(
              AS.globalObject,
              (AS.i13n.varRead(<span style="font-style: italic;">"f"</span>,f)),
              [(AS.i13n.varRead(<span style="font-style: italic;">"x"</span>,x))],<span style="font-weight: bold; text-decoration: underline;">this</span>);
           }})}),<span style="font-weight: bold; text-decoration: underline;">undefined</span>);
       <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">a</span> = (AS.i13n.varWrite(<span style="font-style: italic;">"a"</span>, 1, <span style="font-weight: bold; text-decoration: underline;">undefined</span>));
       <span style="font-weight: bold;">return</span> AS.i13n.creation2(
         <span style="font-weight: bold;">function</span>(){
           <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">$__this__</span>=<span style="font-weight: bold; text-decoration: underline;">arguments</span>[0];
           <span style="font-weight: bold; text-decoration: underline;">arguments</span>=<span style="font-weight: bold; text-decoration: underline;">arguments</span>[1];
           AS.i13n.propWrite($__this__, <span style="font-style: italic;">"g"</span>,
                             (AS.i13n.varRead(<span style="font-style: italic;">"g"</span>,g)));
           AS.i13n.propWrite($__this__, <span style="font-style: italic;">"f"</span>,
                             (AS.i13n.varRead(<span style="font-style: italic;">"f"</span>,f)));
         },<span style="font-weight: bold; text-decoration: underline;">this</span>,<span style="font-weight: bold; text-decoration: underline;">arguments</span>);
      }})}),[],<span style="font-weight: bold; text-decoration: underline;">this</span>)));
</pre>
</div>

<p>
En somme, AspectScript <i>interpr√®te</i> le code du module, d√©l√®gue l&rsquo;√©valuation au
moteur d&rsquo;ex√©cution sous-jacent.  Au passage, il √©met des <i>joinpoint</i> pour chaque
construction, teste les <i>pointcut</i> pour tous les <i>advice</i> enregistr√©s, et
ex√©cute le code si le <i>pointcut</i> correspond.
</p>

<p>
Ce mode de fonctionnement a deux inconv√©nients.  D&rsquo;abord, AspectScript duplique
√©videmment le travail du moteur d&rsquo;ex√©cution de JavaScript, ce qui est
inefficace, mais surtout qui peut changer la s√©mantique du programme
instrument√©.  Puisqu&rsquo;AspectScript interpr√®te le code du module cibl√©, et d√©l√®gue
l&rsquo;√©valuation au moteur d&rsquo;ex√©cution, on n&rsquo;a aucune garantie qu&rsquo;un appel de
fonction captur√© par AspectScript ob√©it aux m√™mes invariants qu&rsquo;un appel de
fonction standard.  Quand on instrumente un module aussi large que Narcissus, on
cherche √† √©viter d&rsquo;introduire des erreurs subtiles dans du code qu&rsquo;on ne
ma√Ætrise pas.  Mais comme AspectScript ajoute une √©tape d&rsquo;interpr√©tation
suppl√©mentaire, si on cherche √† comprendre un bogue de Narcissus il faut aussi
prendre en compte l&rsquo;impl√©mentation d&rsquo;AspectScript.
</p>

<aside style="margin-top:-6rem">
<p>
Exemple de d√©viation de l&rsquo;√©valuation standard de JavaScript: AspectScript ne
peut pas instrumenter du code qui contient <code>with</code>.
</p>
</aside>

<div class="org-src-container">
<label class="org-src-name">Le code invoqu√© dans AspectScript pour un appel r√©ifi√© de fonction.</label>
<pre class="src src-js"><span style="font-weight: bold;">call</span>: <span style="font-weight: bold;">function</span> (<span style="font-weight: bold; font-style: italic;">obj</span>, <span style="font-weight: bold; font-style: italic;">fun</span>, <span style="font-weight: bold; font-style: italic;">args</span>, <span style="font-weight: bold; font-style: italic;">context</span>){
  acChecker.checkCall(obj, fun);

  <span style="font-weight: bold;">if</span>(!weavingNeeded()){
    <span style="font-weight: bold;">return</span> fun.apply(obj, args);
  }

  <span style="font-weight: bold;">var</span> <span style="font-weight: bold; font-style: italic;">call</span> = jpPool.get(JP_CALL, obj, fun, args,
                        context, currentJoinPoint);
  <span style="font-weight: bold;">if</span>(systemObjects.indexOf(obj) &gt;= 0){
    <span style="font-weight: bold;">try</span>{
      <span style="font-weight: bold;">return</span> call._proceed();
    }
    <span style="font-weight: bold;">finally</span>{
      jpPool.release(call);
    }
  }

  <span style="font-weight: bold;">return</span> weave(call);
},
</pre>
</div>

<p>
Le second inconv√©nient est que pour parser le code, AspectScript utilise son
propre parser, ce qui encore une fois peut introduire des d√©viations par rapport
au parser du moteur d&rsquo;ex√©cution.  JavaScript est un langage en √©volution, et le
parser d&rsquo;AspectScript ne suit pas cette √©volution.  Du code qui utilise des
extensions de syntaxe des derni√®res versions de JavaScript s&rsquo;ex√©cutera
correctement sur le navigateur, mais pas s&rsquo;il est instrument√© par AspectScript.
</p>

<p>
Parce qu&rsquo;AspectScript re-interpr√®te le code, et utilise son propre parser, il
pose des probl√®mes de compatibilit√©.  Mais ces m√©canismes ont √©galement un co√ªt
important en temps d&rsquo;ex√©cution et espace m√©moire.  AspectScript est 5 √† 15 fois
plus lent qu&rsquo;un moteur d&rsquo;ex√©cution de JavaScript.  Sachant qu&rsquo;on cherche ici √†
instrumenter un interpr√©teur de JavaScript, et qu&rsquo;on perd d√©j√† un ordre de
grandeur de performance en utilisant un interpr√©teur meta-circulaire, rajouter
une la couche d&rsquo;interpr√©tation d&rsquo;AspectScript n&rsquo;est pas id√©al, surtout s&rsquo;il y a
une alternative qui nous permet d&rsquo;√©tendre l&rsquo;interpr√©teur avec la m√™me
flexibilit√© √† un co√ªt de performance moindre.
</p>

<p>
La programmation par aspect est donc un bon candidat pour le sc√©nario
d&rsquo;instrumentation de Narcissus, mais l&rsquo;impl√©mentation d&rsquo;AspectScript n&rsquo;est pas
une solution ad√©quate pour des raisons techniques.  Une autre impl√©mentation
d&rsquo;aspects pour JavaScript existe dans la litt√©rature [<a href="#LVG-10">LVG</a>], mais elle ne
cible qu&rsquo;une version interne modifi√©e du navigateur Internet Explorer.
</p>
</div>
</div>

<div id="outline-container-orgheadline131" class="outline-4">
<h4 id="orgheadline131"><span class="section-number-4">8.4.4</span> Appliquer la manipulation de port√©e √† d&rsquo;autres langages</h4>
<div class="outline-text-4" id="text-8-4-4">
<p>
On n&rsquo;a pas utilis√© une biblioth√®que d&rsquo;aspect, mais l&rsquo;approche de ce chapitre est
certainement ancr√©e dans le paradigme de la programmation par aspects.  Et c&rsquo;est
justement int√©ressant de voir que la simple manipulation de la port√©e des
variables <i>suffit</i> pour obtenir la flexibilit√© souhait√©e pour ajouter des
analyses √† l&rsquo;interpr√©teur.
</p>

<p>
AspectJ fournit des <i>pointcut</i> bien plus riches que ceux qu&rsquo;on a utilis√© ici.
On n&rsquo;a pas eu besoin d&rsquo;intercepter des appels de fonction en testant les
param√®tres (le pointcut <code>args</code>), ni de conna√Ætre l&rsquo;√©tat de la pile d&rsquo;appels
(<code>cflow</code>).  Les fonctions que l&rsquo;on a emprunt√© √† AspectJ, <code>around</code>, <code>before</code>,
sont triviales, d√©finies en 3 lignes.
</p>

<p>
Le seul m√©canisme dont on a eu besoin existait d√©j√† en JavaScript: la
possibilit√© d&rsquo;intercepter la r√©solution d&rsquo;un nom (de variable ou de fonction)
via <code>with</code>.  Autrement dit, la manipulation de la port√©e des variables suffit
pour instrumenter Narcissus de fa√ßon modulaire.
</p>

<p>
Et la port√©e est un concept qui se retrouve dans de nombreux langages de
programmation, pas seulement en JavaScript.  Ce qui veut dire que la
manipulation de port√©e effectu√©e dans ce chapitre, et illustr√©e par les
diagrammes, est applicable √† d&rsquo;autres langages, m√™me s&rsquo;ils ne disposent pas
d&rsquo;une construction analogue √† <code>with</code>.   Il suffit de permettre au code client de
manipuler directement la r√©solution de port√©e, par un m√©canisme r√©flexif par
exemple.
</p>
</div>
</div>

<div id="outline-container-orgheadline132" class="outline-4">
<h4 id="orgheadline132"><span class="section-number-4">8.4.5</span> Inconv√©nients de la manipulation de port√©e avec <code>with</code></h4>
<div class="outline-text-4" id="text-8-4-5">
<p>
L&rsquo;utilisation de <code>with</code> vient d&rsquo;ailleurs avec son lot d&rsquo;inconv√©nients.  On
utilise <code>with</code> ici juste parce que c&rsquo;est le seul moyen qu&rsquo;on a de manipuler la
port√©e des variables du code du module en JavaScript standard.  √áa nous √©vite
d&rsquo;avoir √† modifier le moteur d&rsquo;ex√©cution pour exposer le m√©canisme de r√©solution
de port√©e, ce qui permet √† notre solution de fonctionner sur n&rsquo;importe quel
interpr√©teur JavaScript.
</p>

<p>
Mais <code>with</code> est une construction d√©pr√©ci√©e du langage, et notamment interdite
dans le &laquo;&nbsp;mode strict&nbsp;&raquo; du standard ECMASCript 5.1.  Concr√®tement, √ßa veut dire
qu&rsquo;un module √©crit dans ce mode strict ne peut pas √™tre √©tendu avec <code>with</code>.
C&rsquo;est une nouvelle manifestation du compromis entre flexibilit√© et s√ªret√© du
code; le mode stricte offre davantage de garanties pour le programmeur (en
particulier, l&rsquo;absence de <code>with</code>), et en √©change il perd la possibilit√©
d&rsquo;appliquer la technique de ce chapitre.
</p>

<p>
L&rsquo;environnement cr√©√© par <code>with</code> ne capture pas les d√©clarations de fonctions qui
ne sont pas √©crites √† la racine du module.  Une fonction interne ne peut donc
pas √™tre instrument√©e.  Les alias de fonctions ne sont pas instrument√©s
automatiquement non plus: si <code>m.a</code> et <code>m.b</code> sont deux r√©f√©rences au m√™me objet
dans le module, alors red√©finir <code>m.a</code> ne change pas <code>m.b</code>, puisqu&rsquo;on ne souhaite
pas modifier les objets du module, seulement changer les r√©f√©rences pour pointer
vers de nouvelles variantes.  Les fonctions anonymes, n&rsquo;ayant de nom pour
pouvoir les r√©f√©rences, ne peuvent pas √™tre instrument√©es non plus.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgheadline137" class="outline-2">
<h2 id="orgheadline137"><span class="section-number-2">9</span> <span class="todo BARE">BARE</span> Synth√®se</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-orgheadline135" class="outline-3">
<h3 id="orgheadline135"><span class="section-number-3">9.1</span> <span class="todo BARE">BARE</span> S√©paration des pr√©occupations: pourquoi?</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>S√©paration difficile √† obtenir</li>
<li>Difficile de d√©finir les fronti√®res
<ul class="org-ul">
<li>une pr√©occupation est rarement isol√©e du reste du programme</li>
</ul></li>
<li>Cause d&rsquo;autres probl√®mes
<ul class="org-ul">
<li>appels implicites, perte de compr√©hension du flot de contr√¥le</li>
</ul></li>
<li>Pointcut ~ dynamic scoping ~ COMEFROM
<ul class="org-ul">
<li>m√©canismes puissants mais peu connus</li>
<li>usage difficile √† justifier hors cas vraiment sp√©cifiques</li>
</ul></li>
<li>Mauvais sens des priorit√©s
<ul class="org-ul">
<li>Un programme doit d&rsquo;abord √™tre correct.</li>
<li>Puis il doit √™tre maintenable -&gt; bonne documentation des choix de structure</li>
<li>S√©paration des pr√©occupations = cerise sur le g√¢teau.  Mais o√π est le g√¢teau?</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline136" class="outline-3">
<h3 id="orgheadline136"><span class="section-number-3">9.2</span> Locality of concerns and locality of execution are irreconciable in the source text</h3>
<div class="outline-text-3" id="text-9-2">
<p>
Is AOP useful for the instrumentation problem?  First, the initial use case of
AOP, like open implementation, is tangential concerns: algorithmic complexity,
choice of data representation, optimizations, etc.  Post-hoc extension is not
exactly a tangential concern: changing the behavior of the interpreter is a
primary concern.
</p>

<p>
Second, we have to consider separately the usefulness of the AOP methodology,
and of the AOP mechanisms.
</p>

<p>
The methodology of separating components from aspects is applicable if our
analyses are tangential.  They are not.  The problem we deal with is that
extensibility was not considered when designing the interpreter, and solutions
must be built on the implementation.
</p>

<p>
Preserving locality is a guiding tenet of the AOP methodology (avoiding
tangling).  It is also a motivation for writing modular analyses: we want the
analysis code to be in one place.  However, by regrouping the analysis code, we
are sacrificing locality of code execution: statements executed at runtime are
not next to each other in the source code.  Satisfying both notions of locality
would lead to duplication in the code, which is a worse state of affairs.
Solutions to this duplication must come from the tools used to write and browse
code, since the textual format we use offer none.  An editor can maintain two
views of the same unit of code: changes in one view will affect both places.
That way, both notions of locality can coexist.
</p>

<p>
The second notion of locality, the one from [<a href="#FF-04">FF04</a>], is one manifestation of the
more general need of a match between runtime behavior and static program
description.  The program source should tell readers what it does, and
navigating through dynamically-bound method calls and oblivious advices hinders
the reading.
</p>

<p>
Organization of the code should reflect the design decisions: what is primary is
explained first, then exceptions or tangential concerns are relegated to
appendices.  Literate programming [<a href="#Knu-84">Knu84</a>] can help organize the code in a such
way.
</p>

<p>
The mechanisms of AOP may serve to extend the interpreter with analyses, without
necessarily obeying the component/aspect decomposition.  Though without editor
support, using AOP mechanisms will only satisfy one notion of locality.
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline138" class="outline-2">
<h2 id="orgheadline138">R√©f√©rences</h2>
<div class="outline-text-2" id="text-orgheadline138">
<div id="bibliography">

<table>

<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="ABK+13">ABKS13</a>]
</td>
<td class="bibtexitem">
Sven Apel, Don&nbsp;S. Batory, Christian K√§stner, and Gunter Saake.
 <em>Feature-Oriented Software Product Lines - Concepts and
  Implementation</em>.
 Springer, 2013.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="ADF-11">ADF11</a>]
</td>
<td class="bibtexitem">
Thomas&nbsp;H. Austin, Tim Disney, and Cormac Flanagan.
 Virtual values for language extension.
 In <em>Proceedings of the 26th Annual ACM SIGPLAN Conference on
  Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
  2011, part of SPLASH 2011, Portland, OR, USA, October 22 - 27, 2011</em>, pages
  921--938, 2011.
[&nbsp;<a href="http://dx.doi.org/10.1145/2048066.2048136">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="AF-12">AF12</a>]
</td>
<td class="bibtexitem">
Thomas&nbsp;H. Austin and Cormac Flanagan.
 Multiple facets for dynamic information flow.
 In <em>POPL</em>, pages 165--178, 2012.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="AGM+06">AGMO06</a>]
</td>
<td class="bibtexitem">
Ivica Aracic, Vaidas Gasiunas, Mira Mezini, and Klaus Ostermann.
 An overview of caesarj.
 <em>Transactions on Aspect-Oriented Software Development</em>, pages
  135--173, 2006.
[&nbsp;<a href="http://dx.doi.org/10.1007/11687061_5">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="AK-09">AK09</a>]
</td>
<td class="bibtexitem">
Sven Apel and Christian K√§stner.
 Virtual separation of concerns - A second chance for preprocessors.
 <em>Journal of Object Technology</em>, 8(6):59--78, 2009.
[&nbsp;<a href="http://dx.doi.org/10.5381/jot.2009.8.6.c5">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="AKL-13">AKL13</a>]
</td>
<td class="bibtexitem">
Sven Apel, Christian K√§stner, and Christian Lengauer.
 Language-independent and automated software composition: The
  featurehouse experience.
 <em>IEEE Trans. Software Eng.</em>, 39(1):63--79, 2013.
[&nbsp;<a href="http://dx.doi.org/10.1109/TSE.2011.120">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Ari-35">AriBC</a>]
</td>
<td class="bibtexitem">
Aristotle.
 <em>Categories</em>.
 Internet Classics Archive, 350 B.C.
[&nbsp;<a href="http://classics.mit.edu/Aristotle/categories.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Asp-03">Asp03</a>]
</td>
<td class="bibtexitem">
AspectJ Team.
 The AspectJ programming guide.
 October 2003.
[&nbsp;<a href="https://eclipse.org/aspectj/doc/released/progguide/index.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Bla-82">Bla82</a>]
</td>
<td class="bibtexitem">
Andrew&nbsp;P. Black.
 <em>Exception Handling: The Case Against</em>.
 PhD thesis, University of Oxford, January 1982.
[&nbsp;<a href="http://web.cecs.pdx.edu/~black/publications/Black D. Phil
                  Thesis.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Bla-91">Bla91</a>]
</td>
<td class="bibtexitem">
G√ºnther Blaschek.
 Type-safe object-oriented programming with prototypes - the concepts
  of omega.
 <em>Structured Programming</em>, 12(4):217--226, 1991.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Bla-94">Bla94</a>]
</td>
<td class="bibtexitem">
G√ºnther Blaschek.
 <em>Object-oriented programming - with prototypes</em>.
 Springer, 1994.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Bol-03">Bol03</a>]
</td>
<td class="bibtexitem">
Azad Bolour.
 Notes on the eclipse plugin-in architecture, 2003.
[&nbsp;<a href="http://www.eclipse.org/articles/Article-Plug-in-architecture/plugin_architecture.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Bor-86">Bor86</a>]
</td>
<td class="bibtexitem">
Alan Borning.
 Classes versus prototypes in object-oriented languages.
 In <em>Proceedings of the Fall Joint Computer Conference, November
  2-6, 1986, Dallas, Texas, USA</em>, pages 36--40, 1986.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="BRG+14">BRGH14</a>]
</td>
<td class="bibtexitem">
Abhishek Bichhawat, Vineet Rajani, Deepak Garg, and Christian Hammer.
 Information flow control in webkit's javascript bytecode.
 In <em>Principles of Security and Trust - Third International
  Conference, POST 2014, Held as Part of the European Joint Conferences on
  Theory and Practice of Software, ETAPS 2014, Grenoble, France, April 5-13,
  2014, Proceedings</em>, pages 159--178, 2014.
[&nbsp;<a href="http://dx.doi.org/10.1007/978-3-642-54792-8_9">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="BSR-04">BSR04</a>]
</td>
<td class="bibtexitem">
Don&nbsp;S. Batory, Jacob&nbsp;Neal Sarvela, and Axel Rauschmayer.
 Scaling step-wise refinement.
 <em>IEEE Trans. Software Eng.</em>, 30(6):355--371, 2004.
[&nbsp;<a href="http://dx.doi.org/10.1109/TSE.2004.23">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Cla-73">Cla73</a>]
</td>
<td class="bibtexitem">
R.&nbsp;Lawrence Clark.
 We don't know where to goto if we don't know where we've come from.
 <em>Datamation</em>, 1973.
[&nbsp;<a href="http://www.fortran.com/fortran/come_from.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DBB+03">DBB<sup>+</sup>03</a>]
</td>
<td class="bibtexitem">
Premkumar&nbsp;T. Devanbu, Robert Balzer, Don&nbsp;S. Batory, Gregor Kiczales, John
  Launchbury, David&nbsp;Lorge Parnas, and Peri&nbsp;L. Tarr.
 Modularity in the new millenium: A panel summary.
 In <em>Proceedings of the 25th International Conference on Software
  Engineering, May 3-10, 2003, Portland, Oregon, USA</em>, pages 723--725, 2003.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Dij-68">Dij68</a>]
</td>
<td class="bibtexitem">
Edsger&nbsp;W. Dijkstra.
 Letters to the editor: go to statement considered harmful.
 <em>Communications of the ACM</em>, 11(3):147--148, 1968.
[&nbsp;<a href="http://dx.doi.org/10.1145/362929.362947">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DMB-98a">DMB98a</a>]
</td>
<td class="bibtexitem">
Christophe Dony, Jacques Malenfant, and Daniel Bardou.
 <em>Classifying Prototype-based Programming languages</em>.
 1998.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DMB-98">DMB98b</a>]
</td>
<td class="bibtexitem">
Christophe Dony, Jacques Malenfant, and Daniel Bardou.
 Les langages √† prototypes.
 In Roland Ducournau, J√©r√¥me Euzenat, G√©rald Masini, and Amedeo
  Napoli, editors, <em>Langages et mod√®les √† objets</em>, volume&nbsp;19 of <em>
  Collection Didactique</em>, chapter&nbsp;8, pages 227--256. INRIA, July 1998.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DS-01">DS01</a>]
</td>
<td class="bibtexitem">
R√©mi Douence and Mario S√ºdholt.
 A generic reification technique for object-oriented reflective
  languages.
 <em>Higher-Order and Symbolic Computation</em>, 14(1):7--34, 2001.
[&nbsp;<a href="http://dx.doi.org/10.1023/A:1011549115358">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DSC+99">DSC<sup>+</sup>99</a>]
</td>
<td class="bibtexitem">
Jim Dowling, Tilman Sch√§fer, Vinny Cahill, Peter Haraszti, and Barry Redmond.
 Using reflection to support dynamic adaptation of system software:
  A case study driven evaluation.
 In <em>Reflection and Software Engineering, Papers from OORaSE 1999,
  1st OOPSLA Workshop on Reflection and Software Engineering, Denver, CO,
  USA, November 1999</em>, pages 169--188, 1999.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-45046-7_10">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="OC-12">dSOC12</a>]
</td>
<td class="bibtexitem">
Bruno&nbsp;C. d.&nbsp;S.&nbsp;Oliveira and William&nbsp;R. Cook.
 Extensibility for the masses - practical extensibility with object
  algebras.
 In <em>ECOOP 2012 - Object-Oriented Programming - 26th European
  Conference, Beijing, China, June 11-16, 2012. Proceedings</em>, pages 2--27,
  2012.
[&nbsp;<a href="http://dx.doi.org/10.1007/978-3-642-31057-7_2">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="ECM-99">ECM99</a>]
</td>
<td class="bibtexitem">
ECMA.
 <em>ECMA-262: ECMAScript Language Specification</em>.
 ECMA (European Association for Standardizing Information and
  Communication Systems), third edition, December 1999.
[&nbsp;<a href="http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="EE-68">EE68</a>]
</td>
<td class="bibtexitem">
Douglas&nbsp;C. Engelbart and William&nbsp;K. English.
 A research center for augmenting human intellect.
 In <em>American Federation of Information Processing Societies:
  Proceedings of the AFIPS '68 Fall Joint Computer Conference, December 9-11,
  1968, San Francisco, California, USA - Part I</em>, pages 395--410, 1968.
[&nbsp;<a href="http://dx.doi.org/10.1145/1476589.1476645">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Esolang">Eso</a>]
</td>
<td class="bibtexitem">
The esoteric programming languages wiki.
[&nbsp;<a href="http://esolangs.org/wiki/Main_Page">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="FF-04">FF04</a>]
</td>
<td class="bibtexitem">
Robert&nbsp;E. Filman and Daniel&nbsp;P. Friedman.
 Aspect-oriented programming is quantification and obliviousness.
 In Mehmet Ak≈üit, Siobhan Clarke, Tzilla Elrad, and Robert&nbsp;E. Filman,
  editors, <em>Aspect-Oriented Software Development</em>. Addison-Wesley, 2004.
 Revision of [?].

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="GBO+98">GBO<sup>+</sup>98</a>]
</td>
<td class="bibtexitem">
Thomas R.&nbsp;G. Green, Alan Borning, Tim O'Shea, Moina Minoughan, and Randall&nbsp;B.
  Smith.
 <em>The Stripetalk Papers: Understandability as a Language Design
  Issue in Object-Oriented Programming Systems</em>.
 1998.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="GHJ+94">GHJV94</a>]
</td>
<td class="bibtexitem">
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides.
 <em>Design Patterns</em>.
 Addison-Wesley, 1994.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Gre-80">Gre80</a>]
</td>
<td class="bibtexitem">
Bernard&nbsp;S. Greenberg.
 Prose and CONS.
 In <em>Proceedings of the 1980 ACM Conference on LISP and
  Functional Programming</em>, pages 6--12, 1980.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Gri-01">Gri01</a>]
</td>
<td class="bibtexitem">
William&nbsp;G. Griswold.
 Coping with crosscutting software changes using information
  transparency.
 In <em>Metalevel Architectures and Separation of Crosscutting
  Concerns, Third International Conference, REFLECTION 2001, Kyoto, Japan,
  September 25-28, 2001, Proceedings</em>, pages 250--265, 2001.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-45429-2_17">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Hal-88">Hal88</a>]
</td>
<td class="bibtexitem">
Heikki Halme.
 GNU emacs as a dynamically extensible programming environment.
 <em>Softw., Pract. Exper.</em>, 18(10):999--1009, 1988.
[&nbsp;<a href="http://dx.doi.org/10.1002/spe.4380181006">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="HBI-98">HBI98</a>]
</td>
<td class="bibtexitem">
Anna Hester, Renato Borges, and Roberto Ierusalimschy.
 Building flexible and extensible web applications with lua.
 <em>Journal of Universal Computer Science</em>, 4(9):748--762, 1998.
[&nbsp;<a href="http://dx.doi.org/10.3217/jucs-004-09-0748">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="HO-07">HO07</a>]
</td>
<td class="bibtexitem">
Christian Hofer and Klaus Ostermann.
 On the relation of aspects and monads.
 In <em>Proceedings of the 6th Workshop on Foundations of
  Aspect-Oriented Languages, FOAL 2007, Vancouver, British Columbia, Canada,
  March 13, 2007</em>, pages 27--33, 2007.
[&nbsp;<a href="http://dx.doi.org/10.1145/1233833.1233838">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="IFF-96">IdFF96</a>]
</td>
<td class="bibtexitem">
Roberto Ierusalimschy, Luiz&nbsp;Henrique de&nbsp;Figueiredo, and Waldemar&nbsp;Celes Filho.
 Lua-an extensible extension language.
 <em>Software: Practice and Experence</em>, 26(6):635--652, 1996.
[&nbsp;<a href="http://dx.doi.org/10.1002/(SICI)1097-024X(199606)26:6<635::AID-SPE26>3.0.CO;2-P">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="IFF-07">IdFF07</a>]
</td>
<td class="bibtexitem">
Roberto Ierusalimschy, Luiz&nbsp;Henrique de&nbsp;Figueiredo, and Waldemar&nbsp;Celes Filho.
 The evolution of lua.
 In Barbara&nbsp;G. Ryder and Brent Hailpern, editors, <em>Proceedings of
  the Third ACM SIGPLAN History of Programming Languages Conference
  (HOPL-III), San Diego, California, USA, 9-10 June 2007</em>, pages 1--26. ACM,
  2007.
[&nbsp;<a href="http://dx.doi.org/10.1145/1238844.1238846">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Ing-78">Ing78</a>]
</td>
<td class="bibtexitem">
Daniel H.&nbsp;H. Ingalls.
 The Smalltalk-76 Programming System.
 In <em>Conference Record of the Fifth Annual ACM Symposium on
  Principles of Programming Languages, Tucson, Arizona, USA, January 1978</em>,
  pages 9--16, 1978.
[&nbsp;<a href="http://dx.doi.org/10.1145/512760.512762">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="IOCCC">IOC</a>]
</td>
<td class="bibtexitem">
The international obfuscated c code contest.
[&nbsp;<a href="http://www.ioccc.org/index.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="JH-07">JH07</a>]
</td>
<td class="bibtexitem">
Neil&nbsp;D. Jones and Ren√©&nbsp;Rydhof Hansen.
 The semantics of "semantic patches" in coccinelle: Program
  transformation for the working programmer.
 In <em>Programming Languages and Systems, 5th Asian Symposium,
  APLAS 2007, Singapore, November 29-December 1, 2007, Proceedings</em>, pages
  303--318, 2007.
[&nbsp;<a href="http://dx.doi.org/10.1007/978-3-540-76637-7_21">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Kay-93">Kay93</a>]
</td>
<td class="bibtexitem">
Alan&nbsp;C. Kay.
 The early history of smalltalk.
 In John A.&nbsp;N. Lee and Jean&nbsp;E. Sammet, editors, <em>History of
  Programming Languages Conference (HOPL-II)</em>, pages 69--95. ACM, 1993.
[&nbsp;<a href="http://dx.doi.org/10.1145/154766.155364">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="KHH+01">KHH<sup>+</sup>01</a>]
</td>
<td class="bibtexitem">
Gregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, Jeffrey Palm, and
  William&nbsp;G. Griswold.
 An overview of aspectj.
 In <em>ECOOP 2001 - Object-Oriented Programming, 15th European
  Conference, Budapest, Hungary, June 18-22, 2001, Proceedings</em>, pages
  327--353, 2001.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-45337-7_18">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Kic-96">Kic96</a>]
</td>
<td class="bibtexitem">
Gregor Kiczales.
 Beyond the black box: Open implementation.
 <em>IEEE Software</em>, 13(1):8--11, 1996.
[&nbsp;<a href="http://dx.doi.org/10.1109/52.476280">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="KLL+97">KLL<sup>+</sup>97</a>]
</td>
<td class="bibtexitem">
Gregor Kiczales, John Lamping, Cristina&nbsp;Videira Lopes, Chris Maeda, Anurag
  Mendhekar, and Gail&nbsp;C. Murphy.
 Open implementation design guidelines.
 In <em>Pulling Together, Proceedings of the 19th International
  Conference on Software Engineering, Boston, Massachusetts, USA, May 17-23,
  1997.</em>, pages 481--490, 1997.
[&nbsp;<a href="http://dx.doi.org/10.1145/253228.253431">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="KLM+97">KLM<sup>+</sup>97</a>]
</td>
<td class="bibtexitem">
Gregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Cristina&nbsp;Videira
  Lopes, Jean-Marc Loingtier, and John Irwin.
 Aspect-oriented programming.
 In <em>ECOOP</em>, pages 220--242, 1997.
[&nbsp;<a href="http://dx.doi.org/10.1007/BFb0053381">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Knu-74">Knu74</a>]
</td>
<td class="bibtexitem">
Donald&nbsp;E. Knuth.
 Structured programming with GO TO statements.
 <em>ACM Comput. Surv.</em>, 6(4):261--301, 1974.
[&nbsp;<a href="http://dx.doi.org/10.1145/356635.356640">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Knu-84">Knu84</a>]
</td>
<td class="bibtexitem">
Donald&nbsp;E. Knuth.
 Literate programming.
 <em>The Computer Journal</em>, 27(2):97--111, 1984.
[&nbsp;<a href="http://dx.doi.org/10.1093/comjnl/27.2.97">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="KT-13">KT13</a>]
</td>
<td class="bibtexitem">
Matthias Keil and Peter Thiemann.
 Efficient dynamic access analysis using javascript proxies.
 In <em>DLS'13, Proceedings of the 9th Symposium on Dynamic
  Languages, part of SPLASH 2013, Indianapolis, IN, USA, October 26-31,
  2013</em>, pages 49--60, 2013.
[&nbsp;<a href="http://dx.doi.org/10.1145/2508168.2508176">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Ler-11">Ler11</a>]
</td>
<td class="bibtexitem">
Benjamin&nbsp;S. Lerner.
 <em>Designing for Extensibility and Planning for Conflict:
  Experiments in Web-Browser Design</em>.
 PhD thesis, University of Washington Computer Science &amp; Engineering,
  August 2011.
[&nbsp;<a href="http://www.cs.brown.edu/~blerner/papers/thesis.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Lie-86">Lie86</a>]
</td>
<td class="bibtexitem">
Henry Lieberman.
 Using prototypical objects to implement shared behavior in object
  oriented systems.
 In <em>Conference on Object-Oriented Programming Systems, Languages,
  and Applications (OOPSLA'86), Portland, Oregon, Proceedings.</em>, pages
  214--223, 1986.
[&nbsp;<a href="http://dx.doi.org/10.1145/28697.28718">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="LLM+00">LLMS00</a>]
</td>
<td class="bibtexitem">
Jeffrey&nbsp;R. Lewis, John Launchbury, Erik Meijer, and Mark Shields.
 Implicit parameters: Dynamic scoping with static types.
 In <em>POPL 2000, Proceedings of the 27th ACM SIGPLAN-SIGACT
  Symposium on Principles of Programming Languages, Boston, Massachusetts, USA,
  January 19-21, 2000</em>, pages 108--118, 2000.
[&nbsp;<a href="http://dx.doi.org/10.1145/325694.325708">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="LVG-10">LVG</a>]
</td>
<td class="bibtexitem">
Benjamin&nbsp;S. Lerner, Herman Venter, and Dan Grossman.
 Supporting dynamic, third-party code customizations in javascript
  using aspects.
 pages 361--376.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Mac-87">Mac87</a>]
</td>
<td class="bibtexitem">
Bruce&nbsp;J. MacLennan.
 <em>Principles of programming languages - design, evaluation, and
  implementation</em>.
 Holt, Rinehart and Winston, 1987.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="McC-60">McC60</a>]
</td>
<td class="bibtexitem">
John McCarthy.
 Recursive functions of symbolic expressions and their computation by
  machine, part I.
 <em>Communications of the ACM</em>, 3(4):184--195, 1960.
[&nbsp;<a href="http://dx.doi.org/10.1145/367177.367199">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="KNS-15b">MdKNS15a</a>]
</td>
<td class="bibtexitem">
Florent Marchand&nbsp;de Kerchove, Jacques Noy√©, and Mario S√ºdholt.
 Open Scope: A Pragmatic JavaScript Pattern for Modular
  Instrumentation.
 working paper or preprint, June 2015.
[&nbsp;<a href="https://hal.archives-ouvertes.fr/hal-01181143">http</a>&nbsp;| 
<a href="https://hal.archives-ouvertes.fr/hal-01181143/file/main.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="KNS-15">MdKNS15b</a>]
</td>
<td class="bibtexitem">
Florent Marchand&nbsp;de Kerchove, Jacques Noy√©, and Mario S√ºdholt.
 Towards modular instrumentation of interpreters in javascript.
 In <em>Companion Proceedings of the 14th International Conference on
  Modularity, MODULARITY 2015, Fort Collins, CO, USA, March 16 - 19, 2015</em>,
  pages 64--69, 2015.
[&nbsp;<a href="http://dx.doi.org/10.1145/2735386.2736753">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Meu-97">Meu97</a>]
</td>
<td class="bibtexitem">
Wolfgang&nbsp;De Meuter.
 Monads as a theoretical foundation for aop.
 In <em>International Workshop on Aspect-Oriented Programming at
  ECOOP</em>, 1997.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="DeM-98">Meu98</a>]
</td>
<td class="bibtexitem">
Wolfgang&nbsp;De Meuter.
 <em>Agora: The Story of the Simplest MOP in the World -or- The
  Scheme of Object-Orientation</em>.
 1998.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="MJD-96">MJD96</a>]
</td>
<td class="bibtexitem">
Jacques Malenfant, M.&nbsp;Jacques, and F.-N. Demers.
 A tutorial on behavioral reflection and its implementation.
 In <em>Proceedings of the 1st International Conference on Metalevel
  Architectures and Reflection (Reflection 96), San Francisco, CA, USA, April
  1996</em>, 1996.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="MKL-97">MKL97</a>]
</td>
<td class="bibtexitem">
Anurag Mendhekar, Gregor Kiczales, and John Lamping.
 RG: A case-study for aspect-oriented programming.
 Technical Report SPL-97-009, Palo Alto Research Center, 1997.
[&nbsp;<a href="ftp://nic.funet.fi/ftp/pub/sci/audio/tmp/forweb.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="MLM+97">MLMK97</a>]
</td>
<td class="bibtexitem">
Chris Maeda, Arthur Lee, Gail&nbsp;C. Murphy, and Gregor Kiczales.
 Open Implementation Analysis and Design.
 In <em>SSR</em>, pages 44--52, 1997.
[&nbsp;<a href="http://dx.doi.org/10.1145/258366.258383">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="MMM+98">MMM<sup>+</sup>98</a>]
</td>
<td class="bibtexitem">
Brad&nbsp;A. Myers, Rich McDaniel, Rob Miller, Brad&nbsp;Vander Zanden, Dario Giuse,
  David Kosbie, and Andrew Mickish.
 <em>The Prototype-Instance Object Systems in Amulet and Garnet</em>.
 1998.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="MO-02">MO02</a>]
</td>
<td class="bibtexitem">
Mira Mezini and Klaus Ostermann.
 Integrating independent components with on-demand remodularization.
 In <em>Proceedings of the 2002 ACM SIGPLAN Conference on
  Object-Oriented Programming Systems, Languages and Applications, OOPSLA
  2002, Seattle, Washington, USA, November 4-8, 2002.</em>, pages 52--67, 2002.
[&nbsp;<a href="http://dx.doi.org/10.1145/582419.582426">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="MO-04">MO04</a>]
</td>
<td class="bibtexitem">
Mira Mezini and Klaus Ostermann.
 Variability management with feature-oriented programming and aspects.
 In <em>Proceedings of the 12th ACM SIGSOFT International
  Symposium on Foundations of Software Engineering, 2004, Newport Beach, CA,
  USA, October 31 - November 6, 2004</em>, pages 127--136, 2004.
[&nbsp;<a href="http://dx.doi.org/10.1145/1029894.1029915">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Moo-96">Moo96</a>]
</td>
<td class="bibtexitem">
Ivan Moore.
 Automatic inheritance hierarchy restructuring and method refactoring.
 In <em>Proceedings of the 1996 ACM SIGPLAN Conference on
  Object-Oriented Programming Systems, Languages &amp; Applications (OOPSLA
  '96), San Jose, California, October 6-10, 1996.</em>, pages 235--250, 1996.
[&nbsp;<a href="http://dx.doi.org/10.1145/236337.236361">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Mor-98">Mor98</a>]
</td>
<td class="bibtexitem">
Luc Moreau.
 A Syntactic Theory of Dynamic Binding.
 <em>Higher-Order and Symbolic Computation</em>, 11(3):233--279, 1998.
[&nbsp;<a href="http://dx.doi.org/10.1023/A:1010087314987">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Mul-15">MP15</a>]
</td>
<td class="bibtexitem">
Matthias M√ºller-Prove.
 Vision and reality of hypertext and graphical user interfaces, 2015.
[&nbsp;<a href="http://www.mprove.de/diplom/text/contents.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Narcissus">Nar</a>]
</td>
<td class="bibtexitem">
The narcissus meta-circular javascript interpreter.
[&nbsp;<a href="https://github.com/mozilla/narcissus">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Nau-85">Nau85</a>]
</td>
<td class="bibtexitem">
Peter Naur.
 Programming as theory building.
 <em>Microprocessing and Microprogramming</em>, 15(5):253--261, 1985.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Nob-01">Nob01</a>]
</td>
<td class="bibtexitem">
James Noble.
 Visualising objects: Abstraction, encapsulation, aliasing, and
  ownership.
 In <em>Software Visualization, International Seminar Dagstuhl
  Castle, Germany, May 20-25, 2001, Revised Lectures</em>, pages 58--72, 2001.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-45875-1_5">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="NS-01">NS01</a>]
</td>
<td class="bibtexitem">
Matthias Neubauer and Michael Sperber.
 Down with emacs lisp: Dynamic scope analysis.
 In <em>Proceedings of the Sixth ACM SIGPLAN International
  Conference on Functional Programming (ICFP '01), Firenze (Florence), Italy,
  September 3-5, 2001.</em>, pages 38--49, 2001.
[&nbsp;<a href="http://dx.doi.org/10.1145/507635.507642">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="OGK+11">OGKR11</a>]
</td>
<td class="bibtexitem">
Klaus Ostermann, Paolo&nbsp;G. Giarrusso, Christian K√§stner, and Tillmann Rendel.
 Revisiting information hiding: Reflections on classical and
  nonclassical modularity.
 In <em>ECOOP 2011 - Object-Oriented Programming - 25th European
  Conference, Lancaster, UK, July 25-29, 2011 Proceedings</em>, pages 155--178,
  2011.
[&nbsp;<a href="http://dx.doi.org/10.1007/978-3-642-22655-7_8">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="OZ-05">OZ05</a>]
</td>
<td class="bibtexitem">
Martin Odersky and Matthias Zenger.
 Independently extensible solutions to the expression problem.
 In <em>Proceedings of the 12th International Workshop on Foundations
  of Object-Oriented Languages (FOOL'05)</em>, January 2005.
[&nbsp;<a href="http://homepages.inf.ed.ac.uk/wadler/fool/program/10.html">.html</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Par-72">Par72</a>]
</td>
<td class="bibtexitem">
David&nbsp;Lorge Parnas.
 On the criteria to be used in decomposing systems into modules.
 <em>Communications of the ACM</em>, 15(12):1053--1058, 1972.
[&nbsp;<a href="http://dx.doi.org/10.1145/361598.361623">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Par-74">Par74</a>]
</td>
<td class="bibtexitem">
David&nbsp;Lorge Parnas.
 Software engineering or methods for the multi - person construction
  of multi - version programs.
 In <em>Programming Methodology, 4th Informatik Symposium, IBM
  Germany, Wildbad, September 25-27, 1974</em>, pages 225--235, 1974.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-07131-8_28">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Par-96">Par96</a>]
</td>
<td class="bibtexitem">
David&nbsp;Lorge Parnas.
 Why software jewels are rare.
 <em>IEEE Computer</em>, 29(2):57--60, 1996.
[&nbsp;<a href="http://dx.doi.org/10.1109/2.485847">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="PBS-14">PBS14</a>]
</td>
<td class="bibtexitem">
Thomas F.&nbsp;J.-M. Pasquier, Jean Bacon, and Brian Shand.
 Flowr: aspect oriented programming for information flow control in
  ruby.
 In <em>13th International Conference on Modularity, MODULARITY
  '14, Lugano, Switzerland, April 22-26, 2014</em>, pages 37--48, 2014.
[&nbsp;<a href="http://dx.doi.org/10.1145/2577080.2577090">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Pla-98">Pla98</a>]
</td>
<td class="bibtexitem">
Plato.
 <em>The Republic</em>.
 1998.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="PLM-06">PLM06</a>]
</td>
<td class="bibtexitem">
Yoann Padioleau, Julia&nbsp;L. Lawall, and Gilles Muller.
 Understanding Collateral Evolution in Linux Device Drivers.
 In <em>Proceedings of the 2006 EuroSys Conference, Leuven, Belgium,
  April 18-21, 2006</em>, pages 59--71, 2006.
[&nbsp;<a href="http://dx.doi.org/10.1145/1217935.1217942">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="PLM-07">PLM07</a>]
</td>
<td class="bibtexitem">
Yoann Padioleau, Julia&nbsp;L. Lawall, and Gilles Muller.
 Semantic patches.
 In <em>Proceedings of the Linux Symposium</em>, volume&nbsp;2, pages
  107--118, 2007.
[&nbsp;<a href="https://www.kernel.org/doc/ols/2007/ols2007v2-pages-107-118.pdf">.pdf</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Que-03">Que03</a>]
</td>
<td class="bibtexitem">
Christian Queinnec.
 <em>Lisp in small pieces</em>.
 Cambridge University Press, 2003.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Rao-91">Rao91</a>]
</td>
<td class="bibtexitem">
Ramana Rao.
 Implementational reflection in silica.
 In <em>ECOOP'91 European Conference on Object-Oriented Programming,
  Geneva, Switzerland, July 15-19, 1991, Proceedings</em>, pages 251--267, 1991.
[&nbsp;<a href="http://dx.doi.org/10.1007/BFb0057026">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="RC-02">RC02</a>]
</td>
<td class="bibtexitem">
Barry Redmond and Vinny Cahill.
 Supporting unanticipated dynamic adaptation of application behaviour.
 In <em>ECOOP 2002 - Object-Oriented Programming, 16th European
  Conference, Malaga, Spain, June 10-14, 2002, Proceedings</em>, pages 205--230,
  2002.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="RS-09a">RS09</a>]
</td>
<td class="bibtexitem">
Hridesh Rajan and Kevin&nbsp;J. Sullivan.
 Unifying aspect- and object-oriented design.
 <em>ACM Trans. Softw. Eng. Methodol.</em>, 19(1), 2009.
[&nbsp;<a href="http://dx.doi.org/10.1145/1555392.1555396">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="s3c">s3c</a>]
</td>
<td class="bibtexitem">
s3c - online javascript editor with code evaluation.
[&nbsp;<a href="https://fmdkdd.github.io/s3c/">http</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Smi-95">Smi95</a>]
</td>
<td class="bibtexitem">
Walter&nbsp;R. Smith.
 Using a prototype-based language for user interface: The newton
  project's experience.
 In <em>OOPSLA</em>, pages 61--72, 1995.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Sta-81">Sta81</a>]
</td>
<td class="bibtexitem">
Richard&nbsp;M. Stallman.
 EMACS The Extensible, Customizable Self-documenting Display Editor.
 In <em>Proceedings of the ACM SIGPLAN SIGOA Symposium on Text
  Manipulation</em>, pages 147--156, 1981.
[&nbsp;<a href="http://dx.doi.org/10.1145/800209.806466">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Ste-94a">Ste94</a>]
</td>
<td class="bibtexitem">
Patrick Steyaert.
 <em>Open Design of Object-Oriented Languages. A Foundation for
  Specialisable Reflective Language Frameworks</em>.
 PhD thesis, Vrije Universiteit Brussel, Belgium, 1994.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Ste-06">Ste06</a>]
</td>
<td class="bibtexitem">
Friedrich Steimann.
 The paradoxical success of aspect-oriented programming.
 In <em>Proceedings of the 21th Annual ACM SIGPLAN Conference on
  Object-Oriented Programming, Systems, Languages, and Applications, OOPSLA
  2006, October 22-26, 2006, Portland, Oregon, USA</em>, pages 481--497, 2006.
[&nbsp;<a href="http://dx.doi.org/10.1145/1167473.1167514">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="SU-95">SU95</a>]
</td>
<td class="bibtexitem">
Randall&nbsp;B. Smith and David Ungar.
 Programming as an experience: The inspiration for self.
 In <em>ECOOP'95 - Object-Oriented Programming, 9th European
  Conference, &Aring;rhus, Denmark, August 7-11, 1995, Proceedings</em>, pages
  303--330, 1995.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-49538-X_15">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="SW-96">SW96</a>]
</td>
<td class="bibtexitem">
Robert&nbsp;J. Stroud and Zhixue Wu.
 <em>Advances in Object-Oriented Architectures and Reflection</em>,
  chapter Using Metaobject Protocols to Satisfy Non-Functional Requirements.
 CRC Press, 1996.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Tai-93">Tai93a</a>]
</td>
<td class="bibtexitem">
Antero Taivalsaari.
 <em>A Critical View of Inheritance and Reusability in
  Object-Oriented Programming</em>.
 PhD thesis, University of Jyv√§skyl√§, Finland, 1993.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Tai-93b">Tai93b</a>]
</td>
<td class="bibtexitem">
Antero Taivalsaari.
 On the notion of object.
 <em>Journal of Systems and Software</em>, 21(1):3--16, 1993.
[&nbsp;<a href="http://dx.doi.org/10.1016/0164-1212(93)90013-N">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Tai-97">Tai97</a>]
</td>
<td class="bibtexitem">
Antero Taivalsaari.
 Classes versus prototypes: Some philosophical and historical
  observations.
 <em>Journal of Object-Oriented Programming</em>, 10(7):44--50, 1997.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="TLT-10">TL√T10</a>]
</td>
<td class="bibtexitem">
Rodolfo Toledo, Paul Leger, and √âric Tanter.
 Aspectscript: expressive aspects for the web.
 In Jean-Marc J√©z√©quel and Mario S√ºdholt, editors, <em>AOSD</em>. ACM,
  2010.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="TO-00">TO00</a>]
</td>
<td class="bibtexitem">
Peri Tarr and Harold Ossher.
 Hyper/J user and installation manual.
 Technical report, IBM T. J. Watson Research Center, 2000.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="TOH+99">TOHJ99</a>]
</td>
<td class="bibtexitem">
Peri&nbsp;L. Tarr, Harold Ossher, William&nbsp;H. Harrison, and Stanley M.&nbsp;Sutton Jr.
 <em>N</em> degrees of separation: Multi-dimensional separation of
  concerns.
 In <em>Proceedings of the 1999 International Conference on Software
  Engineering, ICSE' 99, Los Angeles, CA, USA, May 16-22, 1999.</em>, pages
  107--119, 1999.
[&nbsp;<a href="http://dx.doi.org/10.1145/302405.302457">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="UCC+91">UCH91</a>]
</td>
<td class="bibtexitem">
David Ungar, Craig Chambers&nbsp;Bay-Wei Chang, and Urs H√∂lzle.
 Organizing programs without classes.
 <em>Lisp and Symbolic Computation</em>, 4(3):223--242, 1991.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="US-91">US91</a>]
</td>
<td class="bibtexitem">
David Ungar and Randall&nbsp;B. Smith.
 SELF: The power of simplicity.
 <em>Lisp and Symbolic Computation</em>, 4(3):187--205, 1991.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Wad-98">Wad98</a>]
</td>
<td class="bibtexitem">
Philip Wadler.
 The expression problem, 1998.
[&nbsp;<a href="http://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt">.txt</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Wir-74a">Wir74a</a>]
</td>
<td class="bibtexitem">
Niklaus Wirth.
 On the composition of well-structured programs.
 <em>ACM Computing Surveys</em>, 6(4):247--259, 1974.
[&nbsp;<a href="http://dx.doi.org/10.1145/356635.356639">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Wir-74">Wir74b</a>]
</td>
<td class="bibtexitem">
Niklaus Wirth.
 On the design of programming languages.
 In <em>IFIP Congress</em>, pages 386--393, 1974.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Wir-95">Wir95</a>]
</td>
<td class="bibtexitem">
Niklaus Wirth.
 A plea for lean software.
 <em>IEEE Computer</em>, 28(2):64--68, 1995.
[&nbsp;<a href="http://dx.doi.org/10.1109/2.348001">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Wit-53">Wit53</a>]
</td>
<td class="bibtexitem">
Ludwig Wittgenstein.
 <em>Philosophical Investigations</em>.
 Macmillan, London, 1953.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Wol-96">Wol96</a>]
</td>
<td class="bibtexitem">
Mario Wolczko.
 self includes: Smalltalk, 1996.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Tan-09a">√T09a</a>]
</td>
<td class="bibtexitem">
√âric Tanter.
 Beyond static and dynamic scope.
 In <em>Proceedings of the 5th Symposium on Dynamic Languages, DLS
  2009, October 26, 2010, Orlando, Florida, USA</em>, pages 3--14, 2009.
[&nbsp;<a href="http://dx.doi.org/10.1145/1640134.1640137">DOI</a>&nbsp;]

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="Tan-09">√T09b</a>]
</td>
<td class="bibtexitem">
√âric Tanter.
 Reflection and open implementation.
 Technical Report TR/DCC-20091123-013, University of Chile, jun 2009.

</td>
</tr>


<tr valign="top">
<td align="right" class="bibtexnumber">
[<a name="TSN+02">√TSNP02</a>]
</td>
<td class="bibtexitem">
√âric Tanter, Marc S√©gura-Devillechaise, Jacques Noy√©, and Jos√©&nbsp;M. Piquer.
 Altering java semantics via bytecode manipulation.
 In <em>Generative Programming and Component Engineering, ACM
  SIGPLAN/SIGSOFT Conference, GPCE 2002, Pittsburgh, PA, USA, October 6-8,
  2002, Proceedings</em>, pages 283--298, 2002.
[&nbsp;<a href="http://dx.doi.org/10.1007/3-540-45821-2_18">DOI</a>&nbsp;]

</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Auteur: fmdkdd</p>
<p class="created">Cr√©e: 2016-05-12 jeu. 15:50 (<a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.3.4))</p>
</div>
</body>
</html>
